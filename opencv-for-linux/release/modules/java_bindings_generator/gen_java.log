
Remapped configured files (3):
{u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/core/misc/java/src/java/core+Core.jcode.in': u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/release/configured/modules/core/misc/java/src/java/core+Core.jcode',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/java/generator/android/java/org/opencv/android/OpenCVLoader.java.in': u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/release/configured/modules/java/generator/android/java/org/opencv/android/OpenCVLoader.java',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/java/generator/src/java/org/opencv/osgi/OpenCVNativeLoader.java.in': u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/release/configured/modules/java/generator/src/java/org/opencv/osgi/OpenCVNativeLoader.java'}

=== MODULE: core (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/core) ===


Files (4):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/core/include/opencv2/core/base.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/core/include/opencv2/core.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/core/include/opencv2/core/utility.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/core/misc/java/src/cpp/core_manual.hpp']

Common headers (0):
[]
ok: class CLASS ::.Core : , name: Core, base: 


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/core/include/opencv2/core/base.hpp =====
Namespaces: set([u'cv.ogl', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv'])

--- Incoming ---
[   u'enum cv.Error.Code',
    '',
    [],
    [   [u'const cv.Error.StsOk', u'0', [], [], None, ''],
        [u'const cv.Error.StsBackTrace', u'-1', [], [], None, ''],
        [u'const cv.Error.StsError', u'-2', [], [], None, ''],
        [u'const cv.Error.StsInternal', u'-3', [], [], None, ''],
        [u'const cv.Error.StsNoMem', u'-4', [], [], None, ''],
        [u'const cv.Error.StsBadArg', u'-5', [], [], None, ''],
        [u'const cv.Error.StsBadFunc', u'-6', [], [], None, ''],
        [u'const cv.Error.StsNoConv', u'-7', [], [], None, ''],
        [u'const cv.Error.StsAutoTrace', u'-8', [], [], None, ''],
        [u'const cv.Error.HeaderIsNull', u'-9', [], [], None, ''],
        [u'const cv.Error.BadImageSize', u'-10', [], [], None, ''],
        [u'const cv.Error.BadOffset', u'-11', [], [], None, ''],
        [u'const cv.Error.BadDataPtr', u'-12', [], [], None, ''],
        [u'const cv.Error.BadStep', u'-13', [], [], None, ''],
        [u'const cv.Error.BadModelOrChSeq', u'-14', [], [], None, ''],
        [u'const cv.Error.BadNumChannels', u'-15', [], [], None, ''],
        [u'const cv.Error.BadNumChannel1U', u'-16', [], [], None, ''],
        [u'const cv.Error.BadDepth', u'-17', [], [], None, ''],
        [u'const cv.Error.BadAlphaChannel', u'-18', [], [], None, ''],
        [u'const cv.Error.BadOrder', u'-19', [], [], None, ''],
        [u'const cv.Error.BadOrigin', u'-20', [], [], None, ''],
        [u'const cv.Error.BadAlign', u'-21', [], [], None, ''],
        [u'const cv.Error.BadCallBack', u'-22', [], [], None, ''],
        [u'const cv.Error.BadTileSize', u'-23', [], [], None, ''],
        [u'const cv.Error.BadCOI', u'-24', [], [], None, ''],
        [u'const cv.Error.BadROISize', u'-25', [], [], None, ''],
        [u'const cv.Error.MaskIsTiled', u'-26', [], [], None, ''],
        [u'const cv.Error.StsNullPtr', u'-27', [], [], None, ''],
        [u'const cv.Error.StsVecLengthErr', u'-28', [], [], None, ''],
        [   u'const cv.Error.StsFilterStructContentErr',
            u'-29',
            [],
            [],
            None,
            ''],
        [   u'const cv.Error.StsKernelStructContentErr',
            u'-30',
            [],
            [],
            None,
            ''],
        [u'const cv.Error.StsFilterOffsetErr', u'-31', [], [], None, ''],
        [u'const cv.Error.StsBadSize', u'-201', [], [], None, ''],
        [u'const cv.Error.StsDivByZero', u'-202', [], [], None, ''],
        [u'const cv.Error.StsInplaceNotSupported', u'-203', [], [], None, ''],
        [u'const cv.Error.StsObjectNotFound', u'-204', [], [], None, ''],
        [u'const cv.Error.StsUnmatchedFormats', u'-205', [], [], None, ''],
        [u'const cv.Error.StsBadFlag', u'-206', [], [], None, ''],
        [u'const cv.Error.StsBadPoint', u'-207', [], [], None, ''],
        [u'const cv.Error.StsBadMask', u'-208', [], [], None, ''],
        [u'const cv.Error.StsUnmatchedSizes', u'-209', [], [], None, ''],
        [u'const cv.Error.StsUnsupportedFormat', u'-210', [], [], None, ''],
        [u'const cv.Error.StsOutOfRange', u'-211', [], [], None, ''],
        [u'const cv.Error.StsParseError', u'-212', [], [], None, ''],
        [u'const cv.Error.StsNotImplemented', u'-213', [], [], None, ''],
        [u'const cv.Error.StsBadMemBlock', u'-214', [], [], None, ''],
        [u'const cv.Error.StsAssert', u'-215', [], [], None, ''],
        [u'const cv.Error.GpuNotSupported', u'-216', [], [], None, ''],
        [u'const cv.Error.GpuApiCallError', u'-217', [], [], None, ''],
        [u'const cv.Error.OpenGlNotSupported', u'-218', [], [], None, ''],
        [u'const cv.Error.OpenGlApiCallError', u'-219', [], [], None, ''],
        [u'const cv.Error.OpenCLApiCallError', u'-220', [], [], None, ''],
        [   u'const cv.Error.OpenCLDoubleNotSupported',
            u'-221',
            [],
            [],
            None,
            ''],
        [u'const cv.Error.OpenCLInitError', u'-222', [], [], None, ''],
        [u'const cv.Error.OpenCLNoAMDBlasFft', u'-223', [], [], None, '']],
    None]
ok: CONST StsOk=0
ok: CONST StsBackTrace=-1
ok: CONST StsError=-2
ok: CONST StsInternal=-3
ok: CONST StsNoMem=-4
ok: CONST StsBadArg=-5
ok: CONST StsBadFunc=-6
ok: CONST StsNoConv=-7
ok: CONST StsAutoTrace=-8
ok: CONST HeaderIsNull=-9
ok: CONST BadImageSize=-10
ok: CONST BadOffset=-11
ok: CONST BadDataPtr=-12
ok: CONST BadStep=-13
ok: CONST BadModelOrChSeq=-14
ok: CONST BadNumChannels=-15
ok: CONST BadNumChannel1U=-16
ok: CONST BadDepth=-17
ok: CONST BadAlphaChannel=-18
ok: CONST BadOrder=-19
ok: CONST BadOrigin=-20
ok: CONST BadAlign=-21
ok: CONST BadCallBack=-22
ok: CONST BadTileSize=-23
ok: CONST BadCOI=-24
ok: CONST BadROISize=-25
ok: CONST MaskIsTiled=-26
ok: CONST StsNullPtr=-27
ok: CONST StsVecLengthErr=-28
ok: CONST StsFilterStructContentErr=-29
ok: CONST StsKernelStructContentErr=-30
ok: CONST StsFilterOffsetErr=-31
ok: CONST StsBadSize=-201
ok: CONST StsDivByZero=-202
ok: CONST StsInplaceNotSupported=-203
ok: CONST StsObjectNotFound=-204
ok: CONST StsUnmatchedFormats=-205
ok: CONST StsBadFlag=-206
ok: CONST StsBadPoint=-207
ok: CONST StsBadMask=-208
ok: CONST StsUnmatchedSizes=-209
ok: CONST StsUnsupportedFormat=-210
ok: CONST StsOutOfRange=-211
ok: CONST StsParseError=-212
ok: CONST StsNotImplemented=-213
ok: CONST StsBadMemBlock=-214
ok: CONST StsAssert=-215
ok: CONST GpuNotSupported=-216
ok: CONST GpuApiCallError=-217
ok: CONST OpenGlNotSupported=-218
ok: CONST OpenGlApiCallError=-219
ok: CONST OpenCLApiCallError=-220
ok: CONST OpenCLDoubleNotSupported=-221
ok: CONST OpenCLInitError=-222
ok: CONST OpenCLNoAMDBlasFft=-223

--- Incoming ---
[   u'enum cv.DecompTypes',
    '',
    [],
    [   [u'const cv.DECOMP_LU', u'0', [], [], None, ''],
        [u'const cv.DECOMP_SVD', u'1', [], [], None, ''],
        [u'const cv.DECOMP_EIG', u'2', [], [], None, ''],
        [u'const cv.DECOMP_CHOLESKY', u'3', [], [], None, ''],
        [u'const cv.DECOMP_QR', u'4', [], [], None, ''],
        [u'const cv.DECOMP_NORMAL', u'16', [], [], None, '']],
    None]
ok: CONST DECOMP_LU=0
ok: CONST DECOMP_SVD=1
ok: CONST DECOMP_EIG=2
ok: CONST DECOMP_CHOLESKY=3
ok: CONST DECOMP_QR=4
ok: CONST DECOMP_NORMAL=16

--- Incoming ---
[   u'enum cv.NormTypes',
    '',
    [],
    [   [u'const cv.NORM_INF', u'1', [], [], None, ''],
        [u'const cv.NORM_L1', u'2', [], [], None, ''],
        [u'const cv.NORM_L2', u'4', [], [], None, ''],
        [u'const cv.NORM_L2SQR', u'5', [], [], None, ''],
        [u'const cv.NORM_HAMMING', u'6', [], [], None, ''],
        [u'const cv.NORM_HAMMING2', u'7', [], [], None, ''],
        [u'const cv.NORM_TYPE_MASK', u'7', [], [], None, ''],
        [u'const cv.NORM_RELATIVE', u'8', [], [], None, ''],
        [u'const cv.NORM_MINMAX', u'32', [], [], None, '']],
    None]
ok: CONST NORM_INF=1
ok: CONST NORM_L1=2
ok: CONST NORM_L2=4
ok: CONST NORM_L2SQR=5
ok: CONST NORM_HAMMING=6
ok: CONST NORM_HAMMING2=7
ok: CONST NORM_TYPE_MASK=7
ok: CONST NORM_RELATIVE=8
ok: CONST NORM_MINMAX=32

--- Incoming ---
[   u'enum cv.CmpTypes',
    '',
    [],
    [   [u'const cv.CMP_EQ', u'0', [], [], None, ''],
        [u'const cv.CMP_GT', u'1', [], [], None, ''],
        [u'const cv.CMP_GE', u'2', [], [], None, ''],
        [u'const cv.CMP_LT', u'3', [], [], None, ''],
        [u'const cv.CMP_LE', u'4', [], [], None, ''],
        [u'const cv.CMP_NE', u'5', [], [], None, '']],
    None]
ok: CONST CMP_EQ=0
ok: CONST CMP_GT=1
ok: CONST CMP_GE=2
ok: CONST CMP_LT=3
ok: CONST CMP_LE=4
ok: CONST CMP_NE=5

--- Incoming ---
[   u'enum cv.GemmFlags',
    '',
    [],
    [   [u'const cv.GEMM_1_T', u'1', [], [], None, ''],
        [u'const cv.GEMM_2_T', u'2', [], [], None, ''],
        [u'const cv.GEMM_3_T', u'4', [], [], None, '']],
    None]
ok: CONST GEMM_1_T=1
ok: CONST GEMM_2_T=2
ok: CONST GEMM_3_T=4

--- Incoming ---
[   u'enum cv.DftFlags',
    '',
    [],
    [   [u'const cv.DFT_INVERSE', u'1', [], [], None, ''],
        [u'const cv.DFT_SCALE', u'2', [], [], None, ''],
        [u'const cv.DFT_ROWS', u'4', [], [], None, ''],
        [u'const cv.DFT_COMPLEX_OUTPUT', u'16', [], [], None, ''],
        [u'const cv.DFT_REAL_OUTPUT', u'32', [], [], None, ''],
        [u'const cv.DFT_COMPLEX_INPUT', u'64', [], [], None, ''],
        [u'const cv.DCT_INVERSE', u'DFT_INVERSE', [], [], None, ''],
        [u'const cv.DCT_ROWS', u'DFT_ROWS', [], [], None, '']],
    None]
ok: CONST DFT_INVERSE=1
ok: CONST DFT_SCALE=2
ok: CONST DFT_ROWS=4
ok: CONST DFT_COMPLEX_OUTPUT=16
ok: CONST DFT_REAL_OUTPUT=32
ok: CONST DFT_COMPLEX_INPUT=64
ok: CONST DCT_INVERSE=DFT_INVERSE
ok: CONST DCT_ROWS=DFT_ROWS

--- Incoming ---
[   u'enum cv.BorderTypes',
    '',
    [],
    [   [u'const cv.BORDER_CONSTANT', u'0', [], [], None, ''],
        [u'const cv.BORDER_REPLICATE', u'1', [], [], None, ''],
        [u'const cv.BORDER_REFLECT', u'2', [], [], None, ''],
        [u'const cv.BORDER_WRAP', u'3', [], [], None, ''],
        [u'const cv.BORDER_REFLECT_101', u'4', [], [], None, ''],
        [u'const cv.BORDER_TRANSPARENT', u'5', [], [], None, ''],
        [   u'const cv.BORDER_REFLECT101',
            u'BORDER_REFLECT_101',
            [],
            [],
            None,
            ''],
        [u'const cv.BORDER_DEFAULT', u'BORDER_REFLECT_101', [], [], None, ''],
        [u'const cv.BORDER_ISOLATED', u'16', [], [], None, '']],
    None]
ok: CONST BORDER_CONSTANT=0
ok: CONST BORDER_REPLICATE=1
ok: CONST BORDER_REFLECT=2
ok: CONST BORDER_WRAP=3
ok: CONST BORDER_REFLECT_101=4
ok: CONST BORDER_TRANSPARENT=5
ok: CONST BORDER_REFLECT101=BORDER_REFLECT_101
ok: CONST BORDER_DEFAULT=BORDER_REFLECT_101
ok: CONST BORDER_ISOLATED=16

--- Incoming ---
[u'cv.cubeRoot', u'float', [], [[u'float', u'val', u'', []]], u'float']
ok: FUNC <float cv..cubeRoot [ARG float val=]>

--- Incoming ---
[   u'cv.fastAtan2',
    u'float',
    [],
    [[u'float', u'y', u'', []], [u'float', u'x', u'', []]],
    u'float']
ok: FUNC <float cv..fastAtan2 [ARG float y=, ARG float x=]>

--- Incoming ---
[u'cv.ipp.useIPP', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ipp..useIPP []>

--- Incoming ---
[u'cv.ipp.setUseIPP', u'void', [], [[u'bool', u'flag', u'', []]], u'void']
ok: FUNC <void cv.ipp..setUseIPP [ARG bool flag=]>

--- Incoming ---
[u'cv.ipp.getIppVersion', u'String', [], [], u'String']
ok: FUNC <String cv.ipp..getIppVersion []>

--- Incoming ---
[u'cv.ipp.useIPP_NotExact', u'bool', [], [], u'bool']
ok: FUNC <bool cv.ipp..useIPP_NotExact []>

--- Incoming ---
[   u'cv.ipp.setUseIPP_NotExact',
    u'void',
    [],
    [[u'bool', u'flag', u'', []]],
    u'void']
ok: FUNC <void cv.ipp..setUseIPP_NotExact [ARG bool flag=]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/core/include/opencv2/core.hpp =====
Namespaces: set([u'cv.ogl', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv'])

--- Incoming ---
[   u'enum cv.SortFlags',
    '',
    [],
    [   [u'const cv.SORT_EVERY_ROW', u'0', [], [], None, ''],
        [u'const cv.SORT_EVERY_COLUMN', u'1', [], [], None, ''],
        [u'const cv.SORT_ASCENDING', u'0', [], [], None, ''],
        [u'const cv.SORT_DESCENDING', u'16', [], [], None, '']],
    None]
ok: CONST SORT_EVERY_ROW=0
ok: CONST SORT_EVERY_COLUMN=1
ok: CONST SORT_ASCENDING=0
ok: CONST SORT_DESCENDING=16

--- Incoming ---
[   u'enum cv.CovarFlags',
    '',
    [],
    [   [u'const cv.COVAR_SCRAMBLED', u'0', [], [], None, ''],
        [u'const cv.COVAR_NORMAL', u'1', [], [], None, ''],
        [u'const cv.COVAR_USE_AVG', u'2', [], [], None, ''],
        [u'const cv.COVAR_SCALE', u'4', [], [], None, ''],
        [u'const cv.COVAR_ROWS', u'8', [], [], None, ''],
        [u'const cv.COVAR_COLS', u'16', [], [], None, '']],
    None]
ok: CONST COVAR_SCRAMBLED=0
ok: CONST COVAR_NORMAL=1
ok: CONST COVAR_USE_AVG=2
ok: CONST COVAR_SCALE=4
ok: CONST COVAR_ROWS=8
ok: CONST COVAR_COLS=16

--- Incoming ---
[   u'enum cv.KmeansFlags',
    '',
    [],
    [   [u'const cv.KMEANS_RANDOM_CENTERS', u'0', [], [], None, ''],
        [u'const cv.KMEANS_PP_CENTERS', u'2', [], [], None, ''],
        [u'const cv.KMEANS_USE_INITIAL_LABELS', u'1', [], [], None, '']],
    None]
ok: CONST KMEANS_RANDOM_CENTERS=0
ok: CONST KMEANS_PP_CENTERS=2
ok: CONST KMEANS_USE_INITIAL_LABELS=1

--- Incoming ---
[   u'enum cv.ReduceTypes',
    '',
    [],
    [   [u'const cv.REDUCE_SUM', u'0', [], [], None, ''],
        [u'const cv.REDUCE_AVG', u'1', [], [], None, ''],
        [u'const cv.REDUCE_MAX', u'2', [], [], None, ''],
        [u'const cv.REDUCE_MIN', u'3', [], [], None, '']],
    None]
manual: CONST REDUCE_SUM=0
manual: CONST REDUCE_AVG=1
manual: CONST REDUCE_MAX=2
manual: CONST REDUCE_MIN=3

--- Incoming ---
[   u'cv.borderInterpolate',
    u'int',
    [],
    [   [u'int', u'p', u'', []],
        [u'int', u'len', u'', []],
        [u'int', u'borderType', u'', []]],
    u'int']
ok: FUNC <int cv..borderInterpolate [ARG int p=, ARG int len=, ARG int borderType=]>

--- Incoming ---
[   u'cv.copyMakeBorder',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'top', u'', []],
        [u'int', u'bottom', u'', []],
        [u'int', u'left', u'', []],
        [u'int', u'right', u'', []],
        [u'int', u'borderType', u'', []],
        [u'Scalar', u'value', u'Scalar()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..copyMakeBorder [ARG Mat src=, ARG Mat dst=, ARG int top=, ARG int bottom=, ARG int left=, ARG int right=, ARG int borderType=, ARG Scalar value=Scalar()]>

--- Incoming ---
[   u'cv.add',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..add [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.subtract',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..subtract [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.multiply',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..multiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.divide',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..divide [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.divide',
    u'void',
    [],
    [   [u'double', u'scale', u'', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..divide [ARG double scale=, ARG Mat src2=, ARG Mat dst=, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.scaleAdd',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'double', u'alpha', u'', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..scaleAdd [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.addWeighted',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'double', u'alpha', u'', []],
        ['Mat', u'src2', '', []],
        [u'double', u'beta', u'', []],
        [u'double', u'gamma', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..addWeighted [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG double beta=, ARG double gamma=, ARG Mat dst=, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.convertScaleAbs',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'alpha', u'1', []],
        [u'double', u'beta', u'0', []]],
    u'void']
ok: FUNC <void cv..convertScaleAbs [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0]>

--- Incoming ---
[   u'cv.convertFp16',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..convertFp16 [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.LUT',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'lut', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..LUT [ARG Mat src=, ARG Mat lut=, ARG Mat dst=]>

--- Incoming ---
[u'cv.sum', u'Scalar', [u'=sumElems'], [['Mat', u'src', '', []]], u'Scalar']
ok: FUNC <Scalar cv..sum [ARG Mat src=]>

--- Incoming ---
[u'cv.countNonZero', u'int', [], [['Mat', u'src', '', []]], u'int']
ok: FUNC <int cv..countNonZero [ARG Mat src=]>

--- Incoming ---
[   u'cv.findNonZero',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'idx', '', ['/O']]],
    u'void']
ok: FUNC <void cv..findNonZero [ARG Mat src=, ARG Mat idx=]>

--- Incoming ---
[   u'cv.mean',
    u'Scalar',
    [],
    [['Mat', u'src', '', []], ['Mat', u'mask', u'Mat()', []]],
    u'Scalar']
ok: FUNC <Scalar cv..mean [ARG Mat src=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.meanStdDev',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mean', '', ['/O']],
        ['Mat', u'stddev', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..meanStdDev [ARG Mat src=, ARG vector_double mean=, ARG vector_double stddev=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.norm',
    u'double',
    [],
    [   ['Mat', u'src1', '', []],
        [u'int', u'normType', u'NORM_L2', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'double']
ok: FUNC <double cv..norm [ARG Mat src1=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.norm',
    u'double',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        [u'int', u'normType', u'NORM_L2', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'double']
ok: FUNC <double cv..norm [ARG Mat src1=, ARG Mat src2=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.PSNR',
    u'double',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        [u'double', u'R', u'255.', []]],
    u'double']
ok: FUNC <double cv..PSNR [ARG Mat src1=, ARG Mat src2=, ARG double R=255.]>

--- Incoming ---
[   u'cv.batchDistance',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dist', '', ['/O']],
        [u'int', u'dtype', u'', []],
        ['Mat', u'nidx', '', ['/O']],
        [u'int', u'normType', u'NORM_L2', []],
        [u'int', u'K', u'0', []],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'update', u'0', []],
        [u'bool', u'crosscheck', u'false', []]],
    u'void']
ok: FUNC <void cv..batchDistance [ARG Mat src1=, ARG Mat src2=, ARG Mat dist=, ARG int dtype=, ARG Mat nidx=, ARG int normType=NORM_L2, ARG int K=0, ARG Mat mask=Mat(), ARG int update=0, ARG bool crosscheck=false]>

--- Incoming ---
[   u'cv.normalize',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        [u'double', u'alpha', u'1', []],
        [u'double', u'beta', u'0', []],
        [u'int', u'norm_type', u'NORM_L2', []],
        [u'int', u'dtype', u'-1', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..normalize [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0, ARG int norm_type=NORM_L2, ARG int dtype=-1, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.minMaxLoc',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        [u'double*', u'minVal', u'', ['/O']],
        [u'double*', u'maxVal', u'0', ['/O']],
        [u'Point*', u'minLoc', u'0', ['/O']],
        [u'Point*', u'maxLoc', u'0', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
manual: FUNC <void cv..minMaxLoc [ARG Mat src=, ARG double * minVal=, ARG double * maxVal=0, ARG Point * minLoc=0, ARG Point * maxLoc=0, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.reduce',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'dim', u'', []],
        [u'int', u'rtype', u'', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..reduce [ARG Mat src=, ARG Mat dst=, ARG int dim=, ARG int rtype=, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.merge',
    u'void',
    [],
    [['vector_Mat', u'mv', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..merge [ARG vector_Mat mv=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.split',
    u'void',
    [],
    [['Mat', u'm', '', []], ['vector_Mat', u'mv', '', ['/O']]],
    u'void']
ok: FUNC <void cv..split [ARG Mat m=, ARG vector_Mat mv=]>

--- Incoming ---
[   u'cv.mixChannels',
    u'void',
    [],
    [   ['vector_Mat', u'src', '', []],
        ['vector_Mat', u'dst', '', ['/IO']],
        [u'vector_int', u'fromTo', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..mixChannels [ARG vector_Mat src=, ARG vector_Mat dst=, ARG vector_int fromTo=]>

--- Incoming ---
[   u'cv.extractChannel',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'coi', u'', []]],
    u'void']
ok: FUNC <void cv..extractChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>

--- Incoming ---
[   u'cv.insertChannel',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        [u'int', u'coi', u'', []]],
    u'void']
ok: FUNC <void cv..insertChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>

--- Incoming ---
[   u'cv.flip',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flipCode', u'', []]],
    u'void']
ok: FUNC <void cv..flip [ARG Mat src=, ARG Mat dst=, ARG int flipCode=]>

--- Incoming ---
[   u'enum cv.RotateFlags',
    '',
    [],
    [   [u'const cv.ROTATE_90_CLOCKWISE', u'0', [], [], None, ''],
        [u'const cv.ROTATE_180', u'1', [], [], None, ''],
        [u'const cv.ROTATE_90_COUNTERCLOCKWISE', u'2', [], [], None, '']],
    None]
ok: CONST ROTATE_90_CLOCKWISE=0
ok: CONST ROTATE_180=1
ok: CONST ROTATE_90_COUNTERCLOCKWISE=2

--- Incoming ---
[   u'cv.rotate',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'rotateCode', u'', []]],
    u'void']
ok: FUNC <void cv..rotate [ARG Mat src=, ARG Mat dst=, ARG int rotateCode=]>

--- Incoming ---
[   u'cv.repeat',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        [u'int', u'ny', u'', []],
        [u'int', u'nx', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..repeat [ARG Mat src=, ARG int ny=, ARG int nx=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.hconcat',
    u'void',
    [],
    [['vector_Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..hconcat [ARG vector_Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.vconcat',
    u'void',
    [],
    [['vector_Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..vconcat [ARG vector_Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.bitwise_and',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..bitwise_and [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.bitwise_or',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..bitwise_or [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.bitwise_xor',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..bitwise_xor [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.bitwise_not',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..bitwise_not [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.absdiff',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..absdiff [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.copyTo',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', '', []]],
    u'void']
ok: FUNC <void cv..copyTo [ARG Mat src=, ARG Mat dst=, ARG Mat mask=]>

--- Incoming ---
[   u'cv.inRange',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'lowerb', '', []],
        ['Mat', u'upperb', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..inRange [ARG Mat src=, ARG Scalar lowerb=, ARG Scalar upperb=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.compare',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'cmpop', u'', []]],
    u'void']
ok: FUNC <void cv..compare [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int cmpop=]>

--- Incoming ---
[   u'cv.min',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..min [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.max',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..max [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.sqrt',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..sqrt [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.pow',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        [u'double', u'power', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..pow [ARG Mat src=, ARG double power=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.exp',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..exp [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.log',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..log [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.polarToCart',
    u'void',
    [],
    [   ['Mat', u'magnitude', '', []],
        ['Mat', u'angle', '', []],
        ['Mat', u'x', '', ['/O']],
        ['Mat', u'y', '', ['/O']],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'void']
ok: FUNC <void cv..polarToCart [ARG Mat magnitude=, ARG Mat angle=, ARG Mat x=, ARG Mat y=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   u'cv.cartToPolar',
    u'void',
    [],
    [   ['Mat', u'x', '', []],
        ['Mat', u'y', '', []],
        ['Mat', u'magnitude', '', ['/O']],
        ['Mat', u'angle', '', ['/O']],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'void']
ok: FUNC <void cv..cartToPolar [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=, ARG Mat angle=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   u'cv.phase',
    u'void',
    [],
    [   ['Mat', u'x', '', []],
        ['Mat', u'y', '', []],
        ['Mat', u'angle', '', ['/O']],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'void']
ok: FUNC <void cv..phase [ARG Mat x=, ARG Mat y=, ARG Mat angle=, ARG bool angleInDegrees=false]>

--- Incoming ---
[   u'cv.magnitude',
    u'void',
    [],
    [   ['Mat', u'x', '', []],
        ['Mat', u'y', '', []],
        ['Mat', u'magnitude', '', ['/O']]],
    u'void']
ok: FUNC <void cv..magnitude [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=]>

--- Incoming ---
[   u'cv.checkRange',
    u'bool',
    [],
    [   ['Mat', u'a', '', []],
        [u'bool', u'quiet', u'true', []],
        [u'Point*', u'pos', u'0', ['/O']],
        [u'double', u'minVal', u'-DBL_MAX', []],
        [u'double', u'maxVal', u'DBL_MAX', []]],
    u'bool']
ok: FUNC <bool cv..checkRange [ARG Mat a=, ARG bool quiet=true, ARG  * pos=0, ARG double minVal=-DBL_MAX, ARG double maxVal=DBL_MAX]>

--- Incoming ---
[   u'cv.patchNaNs',
    u'void',
    [],
    [['Mat', u'a', '', ['/IO']], [u'double', u'val', u'0', []]],
    u'void']
ok: FUNC <void cv..patchNaNs [ARG Mat a=, ARG double val=0]>

--- Incoming ---
[   u'cv.gemm',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        [u'double', u'alpha', u'', []],
        ['Mat', u'src3', '', []],
        [u'double', u'beta', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void']
ok: FUNC <void cv..gemm [ARG Mat src1=, ARG Mat src2=, ARG double alpha=, ARG Mat src3=, ARG double beta=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   u'cv.mulTransposed',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'bool', u'aTa', u'', []],
        ['Mat', u'delta', u'Mat()', []],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..mulTransposed [ARG Mat src=, ARG Mat dst=, ARG bool aTa=, ARG Mat delta=Mat(), ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.transpose',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..transpose [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.transform',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'm', '', []]],
    u'void']
ok: FUNC <void cv..transform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>

--- Incoming ---
[   u'cv.perspectiveTransform',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'm', '', []]],
    u'void']
ok: FUNC <void cv..perspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>

--- Incoming ---
[   u'cv.completeSymm',
    u'void',
    [],
    [['Mat', u'm', '', ['/IO']], [u'bool', u'lowerToUpper', u'false', []]],
    u'void']
ok: FUNC <void cv..completeSymm [ARG Mat m=, ARG bool lowerToUpper=false]>

--- Incoming ---
[   u'cv.setIdentity',
    u'void',
    [],
    [   ['Mat', u'mtx', '', ['/IO']],
        [u'Scalar', u's', u'Scalar(1)', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..setIdentity [ARG Mat mtx=, ARG Scalar s=Scalar(1)]>

--- Incoming ---
[u'cv.determinant', u'double', [], [['Mat', u'mtx', '', []]], u'double']
ok: FUNC <double cv..determinant [ARG Mat mtx=]>

--- Incoming ---
[u'cv.trace', u'Scalar', [], [['Mat', u'mtx', '', []]], u'Scalar']
ok: FUNC <Scalar cv..trace [ARG Mat mtx=]>

--- Incoming ---
[   u'cv.invert',
    u'double',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'DECOMP_LU', []]],
    u'double']
ok: FUNC <double cv..invert [ARG Mat src=, ARG Mat dst=, ARG int flags=DECOMP_LU]>

--- Incoming ---
[   u'cv.solve',
    u'bool',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'DECOMP_LU', []]],
    u'bool']
ok: FUNC <bool cv..solve [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int flags=DECOMP_LU]>

--- Incoming ---
[   u'cv.sort',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..sort [ARG Mat src=, ARG Mat dst=, ARG int flags=]>

--- Incoming ---
[   u'cv.sortIdx',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..sortIdx [ARG Mat src=, ARG Mat dst=, ARG int flags=]>

--- Incoming ---
[   u'cv.solveCubic',
    u'int',
    [],
    [['Mat', u'coeffs', '', []], ['Mat', u'roots', '', ['/O']]],
    u'int']
ok: FUNC <int cv..solveCubic [ARG Mat coeffs=, ARG Mat roots=]>

--- Incoming ---
[   u'cv.solvePoly',
    u'double',
    [],
    [   ['Mat', u'coeffs', '', []],
        ['Mat', u'roots', '', ['/O']],
        [u'int', u'maxIters', u'300', []]],
    u'double']
ok: FUNC <double cv..solvePoly [ARG Mat coeffs=, ARG Mat roots=, ARG int maxIters=300]>

--- Incoming ---
[   u'cv.eigen',
    u'bool',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'eigenvalues', '', ['/O']],
        ['Mat', u'eigenvectors', u'Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv..eigen [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=Mat()]>

--- Incoming ---
[   u'cv.eigenNonSymmetric',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'eigenvalues', '', ['/O']],
        ['Mat', u'eigenvectors', '', ['/O']]],
    u'void']
ok: FUNC <void cv..eigenNonSymmetric [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=]>

--- Incoming ---
[   u'cv.calcCovarMatrix',
    u'void',
    [],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'covar', '', ['/O']],
        ['Mat', u'mean', '', ['/IO']],
        [u'int', u'flags', u'', []],
        [u'int', u'ctype', u'CV_64F', []]],
    u'void']
ok: FUNC <void cv..calcCovarMatrix [ARG Mat samples=, ARG Mat covar=, ARG Mat mean=, ARG int flags=, ARG int ctype=CV_64F]>

--- Incoming ---
[   u'cv.PCACompute',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', ['/IO']],
        ['Mat', u'eigenvectors', '', ['/O']],
        [u'int', u'maxComponents', u'0', []]],
    u'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG int maxComponents=0]>

--- Incoming ---
[   u'cv.PCACompute',
    u'void',
    [u'=PCACompute2'],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', ['/IO']],
        ['Mat', u'eigenvectors', '', ['/O']],
        ['Mat', u'eigenvalues', '', ['/O']],
        [u'int', u'maxComponents', u'0', []]],
    u'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG int maxComponents=0]>

--- Incoming ---
[   u'cv.PCACompute',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', ['/IO']],
        ['Mat', u'eigenvectors', '', ['/O']],
        [u'double', u'retainedVariance', u'', []]],
    u'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG double retainedVariance=]>

--- Incoming ---
[   u'cv.PCACompute',
    u'void',
    [u'=PCACompute2'],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', ['/IO']],
        ['Mat', u'eigenvectors', '', ['/O']],
        ['Mat', u'eigenvalues', '', ['/O']],
        [u'double', u'retainedVariance', u'', []]],
    u'void']
ok: FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG double retainedVariance=]>

--- Incoming ---
[   u'cv.PCAProject',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', []],
        ['Mat', u'eigenvectors', '', []],
        ['Mat', u'result', '', ['/O']]],
    u'void']
ok: FUNC <void cv..PCAProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>

--- Incoming ---
[   u'cv.PCABackProject',
    u'void',
    [],
    [   ['Mat', u'data', '', []],
        ['Mat', u'mean', '', []],
        ['Mat', u'eigenvectors', '', []],
        ['Mat', u'result', '', ['/O']]],
    u'void']
ok: FUNC <void cv..PCABackProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>

--- Incoming ---
[   u'cv.SVDecomp',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'w', '', ['/O']],
        ['Mat', u'u', '', ['/O']],
        ['Mat', u'vt', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void']
ok: FUNC <void cv..SVDecomp [ARG Mat src=, ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG int flags=0]>

--- Incoming ---
[   u'cv.SVBackSubst',
    u'void',
    [],
    [   ['Mat', u'w', '', []],
        ['Mat', u'u', '', []],
        ['Mat', u'vt', '', []],
        ['Mat', u'rhs', '', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..SVBackSubst [ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG Mat rhs=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.Mahalanobis',
    u'double',
    [],
    [   ['Mat', u'v1', '', []],
        ['Mat', u'v2', '', []],
        ['Mat', u'icovar', '', []]],
    u'double']
ok: FUNC <double cv..Mahalanobis [ARG Mat v1=, ARG Mat v2=, ARG Mat icovar=]>

--- Incoming ---
[   u'cv.dft',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [u'int', u'nonzeroRows', u'0', []]],
    u'void']
ok: FUNC <void cv..dft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>

--- Incoming ---
[   u'cv.idft',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [u'int', u'nonzeroRows', u'0', []]],
    u'void']
ok: FUNC <void cv..idft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>

--- Incoming ---
[   u'cv.dct',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void']
ok: FUNC <void cv..dct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   u'cv.idct',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'void']
ok: FUNC <void cv..idct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>

--- Incoming ---
[   u'cv.mulSpectrums',
    u'void',
    [],
    [   ['Mat', u'a', '', []],
        ['Mat', u'b', '', []],
        ['Mat', u'c', '', ['/O']],
        [u'int', u'flags', u'', []],
        [u'bool', u'conjB', u'false', []]],
    u'void']
ok: FUNC <void cv..mulSpectrums [ARG Mat a=, ARG Mat b=, ARG Mat c=, ARG int flags=, ARG bool conjB=false]>

--- Incoming ---
[u'cv.getOptimalDFTSize', u'int', [], [[u'int', u'vecsize', u'', []]], u'int']
ok: FUNC <int cv..getOptimalDFTSize [ARG int vecsize=]>

--- Incoming ---
[u'cv.setRNGSeed', u'void', [], [[u'int', u'seed', u'', []]], u'void']
ok: FUNC <void cv..setRNGSeed [ARG int seed=]>

--- Incoming ---
[   u'cv.randu',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'low', '', []],
        ['Mat', u'high', '', []]],
    u'void']
ok: FUNC <void cv..randu [ARG Mat dst=, ARG double low=, ARG double high=]>

--- Incoming ---
[   u'cv.randn',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mean', '', []],
        ['Mat', u'stddev', '', []]],
    u'void']
ok: FUNC <void cv..randn [ARG Mat dst=, ARG double mean=, ARG double stddev=]>

--- Incoming ---
[   u'cv.randShuffle',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/IO']],
        [u'double', u'iterFactor', u'1.', []],
        [u'RNG*', u'rng', u'0', []]],
    u'void']
ok: FUNC <void cv..randShuffle [ARG Mat dst=, ARG double iterFactor=1., ARG RNG * rng=0]>

--- Incoming ---
[   u'enum cv.PCA.Flags',
    '',
    [],
    [   [u'const cv.PCA.DATA_AS_ROW', u'0', [], [], None, ''],
        [u'const cv.PCA.DATA_AS_COL', u'1', [], [], None, ''],
        [u'const cv.PCA.USE_AVG', u'2', [], [], None, '']],
    None]
class not found: CONST DATA_AS_ROW=0
ok: CONST PCA_DATA_AS_ROW=0
class not found: CONST DATA_AS_COL=1
ok: CONST PCA_DATA_AS_COL=1
class not found: CONST USE_AVG=2
ok: CONST PCA_USE_AVG=2

--- Incoming ---
[   u'enum cv.SVD.Flags',
    '',
    [],
    [   [u'const cv.SVD.MODIFY_A', u'1', [], [], None, ''],
        [u'const cv.SVD.NO_UV', u'2', [], [], None, ''],
        [u'const cv.SVD.FULL_UV', u'4', [], [], None, '']],
    None]
class not found: CONST MODIFY_A=1
manual: CONST SVD_MODIFY_A=1
class not found: CONST NO_UV=2
manual: CONST SVD_NO_UV=2
class not found: CONST FULL_UV=4
manual: CONST SVD_FULL_UV=4

--- Incoming ---
[   u'enum cv.RNG.<unnamed>',
    '',
    [],
    [   [u'const cv.RNG.UNIFORM', u'0', [], [], None, ''],
        [u'const cv.RNG.NORMAL', u'1', [], [], None, '']],
    None]
class not found: CONST UNIFORM=0
ok: CONST RNG_UNIFORM=0
class not found: CONST NORMAL=1
ok: CONST RNG_NORMAL=1

--- Incoming ---
[   u'cv.kmeans',
    u'double',
    [],
    [   ['Mat', u'data', '', []],
        [u'int', u'K', u'', []],
        ['Mat', u'bestLabels', '', ['/IO']],
        [u'TermCriteria', u'criteria', u'', []],
        [u'int', u'attempts', u'', []],
        [u'int', u'flags', u'', []],
        ['Mat', u'centers', u'Mat()', ['/O']]],
    u'double']
ok: FUNC <double cv..kmeans [ARG Mat data=, ARG int K=, ARG Mat bestLabels=, ARG TermCriteria criteria=, ARG int attempts=, ARG int flags=, ARG Mat centers=Mat()]>

--- Incoming ---
[   u'enum cv.Formatter.FormatType',
    '',
    [],
    [   [u'const cv.Formatter.FMT_DEFAULT', u'0', [], [], None, ''],
        [u'const cv.Formatter.FMT_MATLAB', u'1', [], [], None, ''],
        [u'const cv.Formatter.FMT_CSV', u'2', [], [], None, ''],
        [u'const cv.Formatter.FMT_PYTHON', u'3', [], [], None, ''],
        [u'const cv.Formatter.FMT_NUMPY', u'4', [], [], None, ''],
        [u'const cv.Formatter.FMT_C', u'5', [], [], None, '']],
    None]
class not found: CONST FMT_DEFAULT=0
ok: CONST Formatter_FMT_DEFAULT=0
class not found: CONST FMT_MATLAB=1
ok: CONST Formatter_FMT_MATLAB=1
class not found: CONST FMT_CSV=2
ok: CONST Formatter_FMT_CSV=2
class not found: CONST FMT_PYTHON=3
ok: CONST Formatter_FMT_PYTHON=3
class not found: CONST FMT_NUMPY=4
ok: CONST Formatter_FMT_NUMPY=4
class not found: CONST FMT_C=5
ok: CONST Formatter_FMT_C=5

--- Incoming ---
[u'class cv.Algorithm', '', [], [], None]
duplicated: CLASS cv::.Algorithm : 

--- Incoming ---
[u'cv.Algorithm.clear', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.Algorithm.clear []>

--- Incoming ---
[   u'cv.Algorithm.write',
    u'void',
    ['/C'],
    [   [u'Ptr_FileStorage', u'fs', u'', ['/C', '/Ref']],
        [u'String', u'name', u'String()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Algorithm.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>

--- Incoming ---
[   u'cv.Algorithm.read',
    u'void',
    ['/V'],
    [[u'FileNode', u'fn', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Algorithm.read [ARG FileNode fn=]>

--- Incoming ---
[u'cv.Algorithm.empty', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.Algorithm.empty []>

--- Incoming ---
[   u'cv.Algorithm.save',
    u'void',
    ['/C', '/V'],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Algorithm.save [ARG String filename=]>

--- Incoming ---
[u'cv.Algorithm.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.Algorithm.getDefaultName []>

--- Incoming ---
[   u'enum struct cv.Param',
    '',
    [],
    [   [u'const cv.Param.INT', u'0', [], [], None, ''],
        [u'const cv.Param.BOOLEAN', u'1', [], [], None, ''],
        [u'const cv.Param.REAL', u'2', [], [], None, ''],
        [u'const cv.Param.STRING', u'3', [], [], None, ''],
        [u'const cv.Param.MAT', u'4', [], [], None, ''],
        [u'const cv.Param.MAT_VECTOR', u'5', [], [], None, ''],
        [u'const cv.Param.ALGORITHM', u'6', [], [], None, ''],
        [u'const cv.Param.FLOAT', u'7', [], [], None, ''],
        [u'const cv.Param.UNSIGNED_INT', u'8', [], [], None, ''],
        [u'const cv.Param.UINT64', u'9', [], [], None, ''],
        [u'const cv.Param.UCHAR', u'11', [], [], None, ''],
        [u'const cv.Param.SCALAR', u'12', [], [], None, '']],
    None]
class not found: CONST INT=0
ok: CONST Param_INT=0
class not found: CONST BOOLEAN=1
ok: CONST Param_BOOLEAN=1
class not found: CONST REAL=2
ok: CONST Param_REAL=2
class not found: CONST STRING=3
ok: CONST Param_STRING=3
class not found: CONST MAT=4
ok: CONST Param_MAT=4
class not found: CONST MAT_VECTOR=5
ok: CONST Param_MAT_VECTOR=5
class not found: CONST ALGORITHM=6
ok: CONST Param_ALGORITHM=6
class not found: CONST FLOAT=7
ok: CONST Param_FLOAT=7
class not found: CONST UNSIGNED_INT=8
ok: CONST Param_UNSIGNED_INT=8
class not found: CONST UINT64=9
ok: CONST Param_UINT64=9
class not found: CONST UCHAR=11
ok: CONST Param_UCHAR=11
class not found: CONST SCALAR=12
ok: CONST Param_SCALAR=12


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/core/include/opencv2/core/utility.hpp =====
Namespaces: set([u'cv.ogl', u'cv.utils', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv.samples', u'cv'])

--- Incoming ---
[u'cv.setNumThreads', u'void', [], [[u'int', u'nthreads', u'', []]], u'void']
ok: FUNC <void cv..setNumThreads [ARG int nthreads=]>

--- Incoming ---
[u'cv.getNumThreads', u'int', [], [], u'int']
ok: FUNC <int cv..getNumThreads []>

--- Incoming ---
[u'cv.getThreadNum', u'int', [], [], u'int']
ok: FUNC <int cv..getThreadNum []>

--- Incoming ---
[u'cv.getBuildInformation', u'String', [], [], u'String']
ok: FUNC <String cv..getBuildInformation []>

--- Incoming ---
[u'cv.getVersionString', u'String', [], [], u'String']
ok: FUNC <String cv..getVersionString []>

--- Incoming ---
[u'cv.getVersionMajor', u'int', [], [], u'int']
ok: FUNC <int cv..getVersionMajor []>

--- Incoming ---
[u'cv.getVersionMinor', u'int', [], [], u'int']
ok: FUNC <int cv..getVersionMinor []>

--- Incoming ---
[u'cv.getVersionRevision', u'int', [], [], u'int']
ok: FUNC <int cv..getVersionRevision []>

--- Incoming ---
[u'cv.getTickCount', u'int64', [], [], u'int64']
ok: FUNC <int64 cv..getTickCount []>

--- Incoming ---
[u'cv.getTickFrequency', u'double', [], [], u'double']
ok: FUNC <double cv..getTickFrequency []>

--- Incoming ---
[u'class cv.TickMeter', '', [], [], None]
ok: class CLASS cv::.TickMeter : , name: TickMeter, base: 

--- Incoming ---
[u'cv.TickMeter.TickMeter', '', [], [], None]
ok: FUNC < cv.TickMeter.TickMeter []>

--- Incoming ---
[u'cv.TickMeter.start', u'void', [], [], u'void']
ok: FUNC <void cv.TickMeter.start []>

--- Incoming ---
[u'cv.TickMeter.stop', u'void', [], [], u'void']
ok: FUNC <void cv.TickMeter.stop []>

--- Incoming ---
[u'cv.TickMeter.getTimeTicks', u'int64', ['/C'], [], u'int64']
ok: FUNC <int64 cv.TickMeter.getTimeTicks []>

--- Incoming ---
[u'cv.TickMeter.getTimeMicro', u'double', ['/C'], [], u'double']
ok: FUNC <double cv.TickMeter.getTimeMicro []>

--- Incoming ---
[u'cv.TickMeter.getTimeMilli', u'double', ['/C'], [], u'double']
ok: FUNC <double cv.TickMeter.getTimeMilli []>

--- Incoming ---
[u'cv.TickMeter.getTimeSec', u'double', ['/C'], [], u'double']
ok: FUNC <double cv.TickMeter.getTimeSec []>

--- Incoming ---
[u'cv.TickMeter.getCounter', u'int64', ['/C'], [], u'int64']
ok: FUNC <int64 cv.TickMeter.getCounter []>

--- Incoming ---
[u'cv.TickMeter.reset', u'void', [], [], u'void']
ok: FUNC <void cv.TickMeter.reset []>

--- Incoming ---
[u'cv.getCPUTickCount', u'int64', [], [], u'int64']
ok: FUNC <int64 cv..getCPUTickCount []>

--- Incoming ---
[   u'cv.checkHardwareSupport',
    u'bool',
    [],
    [[u'int', u'feature', u'', []]],
    u'bool']
manual: FUNC <bool cv..checkHardwareSupport [ARG int feature=]>

--- Incoming ---
[   u'cv.getHardwareFeatureName',
    u'String',
    [],
    [[u'int', u'feature', u'', []]],
    u'String']
ok: FUNC <String cv..getHardwareFeatureName [ARG int feature=]>

--- Incoming ---
[u'cv.getCPUFeaturesLine', u'string', [], [], u'std::string']
ok: FUNC <string cv..getCPUFeaturesLine []>

--- Incoming ---
[u'cv.getNumberOfCPUs', u'int', [], [], u'int']
ok: FUNC <int cv..getNumberOfCPUs []>

--- Incoming ---
[u'cv.setUseOptimized', u'void', [], [[u'bool', u'onoff', u'', []]], u'void']
manual: FUNC <void cv..setUseOptimized [ARG bool onoff=]>

--- Incoming ---
[u'cv.useOptimized', u'bool', [], [], u'bool']
manual: FUNC <bool cv..useOptimized []>

--- Incoming ---
[   u'cv.samples.findFile',
    u'String',
    [],
    [   [u'String', u'relative_path', u'', ['/C', '/Ref']],
        [u'bool', u'required', u'true', []],
        [u'bool', u'silentMode', u'false', []]],
    u'cv::String']
ok: FUNC <String cv.samples..findFile [ARG String relative_path=, ARG bool required=true, ARG bool silentMode=false]>

--- Incoming ---
[   u'cv.samples.findFileOrKeep',
    u'String',
    [],
    [   [u'String', u'relative_path', u'', ['/C', '/Ref']],
        [u'bool', u'silentMode', u'false', []]],
    u'cv::String']
ok: FUNC <String cv.samples..findFileOrKeep [ARG String relative_path=, ARG bool silentMode=false]>

--- Incoming ---
[   u'cv.samples.addSamplesDataSearchPath',
    u'void',
    [],
    [[u'String', u'path', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.samples..addSamplesDataSearchPath [ARG String path=]>

--- Incoming ---
[   u'cv.samples.addSamplesDataSearchSubDirectory',
    u'void',
    [],
    [[u'String', u'subdir', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.samples..addSamplesDataSearchSubDirectory [ARG String subdir=]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/core/misc/java/src/cpp/core_manual.hpp =====
Namespaces: set([u'cv.ogl', u'cv.utils', u'cv.cudev', u'cv.ipp', u'cv.Error', u'cv.cuda', u'cv.samples', u'cv'])

--- Incoming ---
[   u'cv.setErrorVerbosity',
    u'void',
    [],
    [[u'bool', u'verbose', u'', []]],
    u'void']
ok: FUNC <void cv..setErrorVerbosity [ARG bool verbose=]>

--- Incoming ---
[   u'cv.add',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..add [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.subtract',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..subtract [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>

--- Incoming ---
[   u'cv.multiply',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..multiply [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.divide',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'void']
ok: FUNC <void cv..divide [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>

--- Incoming ---
[   u'cv.absdiff',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..absdiff [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.compare',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'cmpop', u'', []]],
    u'void']
ok: FUNC <void cv..compare [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG int cmpop=]>

--- Incoming ---
[   u'cv.min',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..min [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.max',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        [u'Scalar', u'src2', u'', []],
        ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..max [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>


===== Generating... =====
CLASS ::.Core : 
[CONST CV_8U=0(manual), CONST CV_8S=1(manual), CONST CV_16U=2(manual), CONST CV_16S=3(manual), CONST CV_32S=4(manual), CONST CV_32F=5(manual), CONST CV_64F=6(manual), CONST CV_USRTYPE1=7(manual)]
[CONST DECOMP_LU=0, CONST DECOMP_SVD=1, CONST DECOMP_EIG=2, CONST DECOMP_CHOLESKY=3, CONST DECOMP_QR=4, CONST DECOMP_NORMAL=16]
[CONST BORDER_CONSTANT=0, CONST BORDER_REPLICATE=1, CONST BORDER_REFLECT=2, CONST BORDER_WRAP=3, CONST BORDER_REFLECT_101=4, CONST BORDER_TRANSPARENT=5, CONST BORDER_REFLECT101=BORDER_REFLECT_101, CONST BORDER_DEFAULT=BORDER_REFLECT_101, CONST BORDER_ISOLATED=16]
[CONST GEMM_1_T=1, CONST GEMM_2_T=2, CONST GEMM_3_T=4]
[CONST KMEANS_RANDOM_CENTERS=0, CONST KMEANS_PP_CENTERS=2, CONST KMEANS_USE_INITIAL_LABELS=1]
[CONST CMP_EQ=0, CONST CMP_GT=1, CONST CMP_GE=2, CONST CMP_LT=3, CONST CMP_LE=4, CONST CMP_NE=5]
[CONST PCA_DATA_AS_ROW=0, CONST PCA_DATA_AS_COL=1, CONST PCA_USE_AVG=2]
[CONST SVD_MODIFY_A=1(manual), CONST SVD_NO_UV=2(manual), CONST SVD_FULL_UV=4(manual), CONST FILLED=-1(manual), CONST REDUCE_SUM=0(manual), CONST REDUCE_AVG=1(manual), CONST REDUCE_MAX=2(manual), CONST REDUCE_MIN=3(manual), CONST RNG_UNIFORM=0, CONST RNG_NORMAL=1]
[CONST COVAR_SCRAMBLED=0, CONST COVAR_NORMAL=1, CONST COVAR_USE_AVG=2, CONST COVAR_SCALE=4, CONST COVAR_ROWS=8, CONST COVAR_COLS=16]
[CONST SORT_EVERY_ROW=0, CONST SORT_EVERY_COLUMN=1, CONST SORT_ASCENDING=0, CONST SORT_DESCENDING=16]
[CONST Formatter_FMT_DEFAULT=0, CONST Formatter_FMT_MATLAB=1, CONST Formatter_FMT_CSV=2, CONST Formatter_FMT_PYTHON=3, CONST Formatter_FMT_NUMPY=4, CONST Formatter_FMT_C=5]
[CONST Param_INT=0, CONST Param_BOOLEAN=1, CONST Param_REAL=2, CONST Param_STRING=3, CONST Param_MAT=4, CONST Param_MAT_VECTOR=5, CONST Param_ALGORITHM=6, CONST Param_FLOAT=7, CONST Param_UNSIGNED_INT=8, CONST Param_UINT64=9, CONST Param_UCHAR=11, CONST Param_SCALAR=12]
[CONST DFT_INVERSE=1, CONST DFT_SCALE=2, CONST DFT_ROWS=4, CONST DFT_COMPLEX_OUTPUT=16, CONST DFT_REAL_OUTPUT=32, CONST DFT_COMPLEX_INPUT=64, CONST DCT_INVERSE=DFT_INVERSE, CONST DCT_ROWS=DFT_ROWS]
[CONST NORM_INF=1, CONST NORM_L1=2, CONST NORM_L2=4, CONST NORM_L2SQR=5, CONST NORM_HAMMING=6, CONST NORM_HAMMING2=7, CONST NORM_TYPE_MASK=7, CONST NORM_RELATIVE=8, CONST NORM_MINMAX=32]
[CONST ROTATE_90_CLOCKWISE=0, CONST ROTATE_180=1, CONST ROTATE_90_COUNTERCLOCKWISE=2]
[CONST StsOk=0, CONST StsBackTrace=-1, CONST StsError=-2, CONST StsInternal=-3, CONST StsNoMem=-4, CONST StsBadArg=-5, CONST StsBadFunc=-6, CONST StsNoConv=-7, CONST StsAutoTrace=-8, CONST HeaderIsNull=-9, CONST BadImageSize=-10, CONST BadOffset=-11, CONST BadDataPtr=-12, CONST BadStep=-13, CONST BadModelOrChSeq=-14, CONST BadNumChannels=-15, CONST BadNumChannel1U=-16, CONST BadDepth=-17, CONST BadAlphaChannel=-18, CONST BadOrder=-19, CONST BadOrigin=-20, CONST BadAlign=-21, CONST BadCallBack=-22, CONST BadTileSize=-23, CONST BadCOI=-24, CONST BadROISize=-25, CONST MaskIsTiled=-26, CONST StsNullPtr=-27, CONST StsVecLengthErr=-28, CONST StsFilterStructContentErr=-29, CONST StsKernelStructContentErr=-30, CONST StsFilterOffsetErr=-31, CONST StsBadSize=-201, CONST StsDivByZero=-202, CONST StsInplaceNotSupported=-203, CONST StsObjectNotFound=-204, CONST StsUnmatchedFormats=-205, CONST StsBadFlag=-206, CONST StsBadPoint=-207, CONST StsBadMask=-208, CONST StsUnmatchedSizes=-209, CONST StsUnsupportedFormat=-210, CONST StsOutOfRange=-211, CONST StsParseError=-212, CONST StsNotImplemented=-213, CONST StsBadMemBlock=-214, CONST StsAssert=-215, CONST GpuNotSupported=-216, CONST GpuApiCallError=-217, CONST OpenGlNotSupported=-218, CONST OpenGlApiCallError=-219, CONST OpenCLApiCallError=-220, CONST OpenCLDoubleNotSupported=-221, CONST OpenCLInitError=-222, CONST OpenCLNoAMDBlasFft=-223]
FUNC <Scalar cv..mean [ARG Mat src=, ARG Mat mask=Mat()]>
java: Scalar mean(Mat src, Mat mask)
java: Scalar mean(Mat src)
FUNC <Scalar cv..sum [ARG Mat src=]>
java: Scalar sumElems(Mat src)
FUNC <Scalar cv..trace [ARG Mat mtx=]>
java: Scalar trace(Mat mtx)
FUNC <String cv..getBuildInformation []>
java: String getBuildInformation()
FUNC <String cv..getHardwareFeatureName [ARG int feature=]>
java: String getHardwareFeatureName(int feature)
FUNC <String cv..getVersionString []>
java: String getVersionString()
FUNC <String cv.ipp..getIppVersion []>
java: String getIppVersion()
FUNC <String cv.samples..findFile [ARG String relative_path=, ARG bool required=true, ARG bool silentMode=false]>
java: String findFile(String relative_path, boolean required, boolean silentMode)
java: String findFile(String relative_path, boolean required)
java: String findFile(String relative_path)
FUNC <String cv.samples..findFileOrKeep [ARG String relative_path=, ARG bool silentMode=false]>
java: String findFileOrKeep(String relative_path, boolean silentMode)
java: String findFileOrKeep(String relative_path)
FUNC <bool cv..checkRange [ARG Mat a=, ARG bool quiet=true, ARG  * pos=0, ARG double minVal=-DBL_MAX, ARG double maxVal=DBL_MAX]>
java: boolean checkRange(Mat a, boolean quiet, double minVal, double maxVal)
java: boolean checkRange(Mat a, boolean quiet, double minVal)
java: boolean checkRange(Mat a, boolean quiet)
java: boolean checkRange(Mat a, boolean quiet)
java: boolean checkRange(Mat a)
FUNC <bool cv..eigen [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=Mat()]>
java: boolean eigen(Mat src, Mat eigenvalues, Mat eigenvectors)
java: boolean eigen(Mat src, Mat eigenvalues)
FUNC <bool cv..solve [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int flags=DECOMP_LU]>
java: boolean solve(Mat src1, Mat src2, Mat dst, int flags)
java: boolean solve(Mat src1, Mat src2, Mat dst)
FUNC <bool cv.ipp..useIPP []>
java: boolean useIPP()
FUNC <bool cv.ipp..useIPP_NotExact []>
java: boolean useIPP_NotExact()
FUNC <double cv..Mahalanobis [ARG Mat v1=, ARG Mat v2=, ARG Mat icovar=]>
java: double Mahalanobis(Mat v1, Mat v2, Mat icovar)
FUNC <double cv..PSNR [ARG Mat src1=, ARG Mat src2=, ARG double R=255.]>
java: double PSNR(Mat src1, Mat src2, double R)
java: double PSNR(Mat src1, Mat src2)
FUNC <double cv..determinant [ARG Mat mtx=]>
java: double determinant(Mat mtx)
FUNC <double cv..getTickFrequency []>
java: double getTickFrequency()
FUNC <double cv..invert [ARG Mat src=, ARG Mat dst=, ARG int flags=DECOMP_LU]>
java: double invert(Mat src, Mat dst, int flags)
java: double invert(Mat src, Mat dst)
FUNC <double cv..kmeans [ARG Mat data=, ARG int K=, ARG Mat bestLabels=, ARG TermCriteria criteria=, ARG int attempts=, ARG int flags=, ARG Mat centers=Mat()]>
java: double kmeans(Mat data, int K, Mat bestLabels, TermCriteria criteria, int attempts, int flags, Mat centers)
java: double kmeans(Mat data, int K, Mat bestLabels, TermCriteria criteria, int attempts, int flags)
FUNC <double cv..norm [ARG Mat src1=, ARG Mat src2=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>
java: double norm(Mat src1, Mat src2, int normType, Mat mask)
java: double norm(Mat src1, Mat src2, int normType)
java: double norm(Mat src1, Mat src2)
FUNC <double cv..norm [ARG Mat src1=, ARG int normType=NORM_L2, ARG Mat mask=Mat()]>
java: double norm(Mat src1, int normType, Mat mask)
java: double norm(Mat src1, int normType)
java: double norm(Mat src1)
FUNC <double cv..solvePoly [ARG Mat coeffs=, ARG Mat roots=, ARG int maxIters=300]>
java: double solvePoly(Mat coeffs, Mat roots, int maxIters)
java: double solvePoly(Mat coeffs, Mat roots)
FUNC <float cv..cubeRoot [ARG float val=]>
java: float cubeRoot(float val)
FUNC <float cv..fastAtan2 [ARG float y=, ARG float x=]>
java: float fastAtan2(float y, float x)
FUNC <int cv..borderInterpolate [ARG int p=, ARG int len=, ARG int borderType=]>
java: int borderInterpolate(int p, int len, int borderType)
FUNC <int cv..countNonZero [ARG Mat src=]>
java: int countNonZero(Mat src)
FUNC <int cv..getNumThreads []>
java: int getNumThreads()
FUNC <int cv..getNumberOfCPUs []>
java: int getNumberOfCPUs()
FUNC <int cv..getOptimalDFTSize [ARG int vecsize=]>
java: int getOptimalDFTSize(int vecsize)
FUNC <int cv..getThreadNum []>
java: int getThreadNum()
FUNC <int cv..getVersionMajor []>
java: int getVersionMajor()
FUNC <int cv..getVersionMinor []>
java: int getVersionMinor()
FUNC <int cv..getVersionRevision []>
java: int getVersionRevision()
FUNC <int cv..solveCubic [ARG Mat coeffs=, ARG Mat roots=]>
java: int solveCubic(Mat coeffs, Mat roots)
FUNC <int64 cv..getCPUTickCount []>
java: long getCPUTickCount()
FUNC <int64 cv..getTickCount []>
java: long getTickCount()
FUNC <string cv..getCPUFeaturesLine []>
java: String getCPUFeaturesLine()
FUNC <void cv..LUT [ARG Mat src=, ARG Mat lut=, ARG Mat dst=]>
java: void LUT(Mat src, Mat lut, Mat dst)
FUNC <void cv..PCABackProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>
java: void PCABackProject(Mat data, Mat mean, Mat eigenvectors, Mat result)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG double retainedVariance=]>
java: void PCACompute2(Mat data, Mat mean, Mat eigenvectors, Mat eigenvalues, double retainedVariance)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat eigenvalues=, ARG int maxComponents=0]>
java: void PCACompute2(Mat data, Mat mean, Mat eigenvectors, Mat eigenvalues, int maxComponents)
java: void PCACompute2(Mat data, Mat mean, Mat eigenvectors, Mat eigenvalues)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG double retainedVariance=]>
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors, double retainedVariance)
FUNC <void cv..PCACompute [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG int maxComponents=0]>
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors, int maxComponents)
java: void PCACompute(Mat data, Mat mean, Mat eigenvectors)
FUNC <void cv..PCAProject [ARG Mat data=, ARG Mat mean=, ARG Mat eigenvectors=, ARG Mat result=]>
java: void PCAProject(Mat data, Mat mean, Mat eigenvectors, Mat result)
FUNC <void cv..SVBackSubst [ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG Mat rhs=, ARG Mat dst=]>
java: void SVBackSubst(Mat w, Mat u, Mat vt, Mat rhs, Mat dst)
FUNC <void cv..SVDecomp [ARG Mat src=, ARG Mat w=, ARG Mat u=, ARG Mat vt=, ARG int flags=0]>
java: void SVDecomp(Mat src, Mat w, Mat u, Mat vt, int flags)
java: void SVDecomp(Mat src, Mat w, Mat u, Mat vt)
FUNC <void cv..absdiff [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void absdiff(Mat src1, Mat src2, Mat dst)
FUNC <void cv..absdiff [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void absdiff(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..add [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void add(Mat src1, Mat src2, Mat dst, Mat mask, int dtype)
java: void add(Mat src1, Mat src2, Mat dst, Mat mask)
java: void add(Mat src1, Mat src2, Mat dst)
FUNC <void cv..add [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void add(Mat src1, Scalar src2, Mat dst, Mat mask, int dtype)
java: void add(Mat src1, Scalar src2, Mat dst, Mat mask)
java: void add(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..addWeighted [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG double beta=, ARG double gamma=, ARG Mat dst=, ARG int dtype=-1]>
java: void addWeighted(Mat src1, double alpha, Mat src2, double beta, double gamma, Mat dst, int dtype)
java: void addWeighted(Mat src1, double alpha, Mat src2, double beta, double gamma, Mat dst)
FUNC <void cv..batchDistance [ARG Mat src1=, ARG Mat src2=, ARG Mat dist=, ARG int dtype=, ARG Mat nidx=, ARG int normType=NORM_L2, ARG int K=0, ARG Mat mask=Mat(), ARG int update=0, ARG bool crosscheck=false]>
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K, Mat mask, int update, boolean crosscheck)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K, Mat mask, int update)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K, Mat mask)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType, int K)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx, int normType)
java: void batchDistance(Mat src1, Mat src2, Mat dist, int dtype, Mat nidx)
FUNC <void cv..bitwise_and [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_and(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_and(Mat src1, Mat src2, Mat dst)
FUNC <void cv..bitwise_not [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_not(Mat src, Mat dst, Mat mask)
java: void bitwise_not(Mat src, Mat dst)
FUNC <void cv..bitwise_or [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_or(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_or(Mat src1, Mat src2, Mat dst)
FUNC <void cv..bitwise_xor [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void bitwise_xor(Mat src1, Mat src2, Mat dst, Mat mask)
java: void bitwise_xor(Mat src1, Mat src2, Mat dst)
FUNC <void cv..calcCovarMatrix [ARG Mat samples=, ARG Mat covar=, ARG Mat mean=, ARG int flags=, ARG int ctype=CV_64F]>
java: void calcCovarMatrix(Mat samples, Mat covar, Mat mean, int flags, int ctype)
java: void calcCovarMatrix(Mat samples, Mat covar, Mat mean, int flags)
FUNC <void cv..cartToPolar [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=, ARG Mat angle=, ARG bool angleInDegrees=false]>
java: void cartToPolar(Mat x, Mat y, Mat magnitude, Mat angle, boolean angleInDegrees)
java: void cartToPolar(Mat x, Mat y, Mat magnitude, Mat angle)
FUNC <void cv..compare [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int cmpop=]>
java: void compare(Mat src1, Mat src2, Mat dst, int cmpop)
FUNC <void cv..compare [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG int cmpop=]>
java: void compare(Mat src1, Scalar src2, Mat dst, int cmpop)
FUNC <void cv..completeSymm [ARG Mat m=, ARG bool lowerToUpper=false]>
java: void completeSymm(Mat m, boolean lowerToUpper)
java: void completeSymm(Mat m)
FUNC <void cv..convertFp16 [ARG Mat src=, ARG Mat dst=]>
java: void convertFp16(Mat src, Mat dst)
FUNC <void cv..convertScaleAbs [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0]>
java: void convertScaleAbs(Mat src, Mat dst, double alpha, double beta)
java: void convertScaleAbs(Mat src, Mat dst, double alpha)
java: void convertScaleAbs(Mat src, Mat dst)
FUNC <void cv..copyMakeBorder [ARG Mat src=, ARG Mat dst=, ARG int top=, ARG int bottom=, ARG int left=, ARG int right=, ARG int borderType=, ARG Scalar value=Scalar()]>
java: void copyMakeBorder(Mat src, Mat dst, int top, int bottom, int left, int right, int borderType, Scalar value)
java: void copyMakeBorder(Mat src, Mat dst, int top, int bottom, int left, int right, int borderType)
FUNC <void cv..copyTo [ARG Mat src=, ARG Mat dst=, ARG Mat mask=]>
java: void copyTo(Mat src, Mat dst, Mat mask)
FUNC <void cv..dct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>
java: void dct(Mat src, Mat dst, int flags)
java: void dct(Mat src, Mat dst)
FUNC <void cv..dft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>
java: void dft(Mat src, Mat dst, int flags, int nonzeroRows)
java: void dft(Mat src, Mat dst, int flags)
java: void dft(Mat src, Mat dst)
FUNC <void cv..divide [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void divide(Mat src1, Mat src2, Mat dst, double scale, int dtype)
java: void divide(Mat src1, Mat src2, Mat dst, double scale)
java: void divide(Mat src1, Mat src2, Mat dst)
FUNC <void cv..divide [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void divide(Mat src1, Scalar src2, Mat dst, double scale, int dtype)
java: void divide(Mat src1, Scalar src2, Mat dst, double scale)
java: void divide(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..divide [ARG double scale=, ARG Mat src2=, ARG Mat dst=, ARG int dtype=-1]>
java: void divide(double scale, Mat src2, Mat dst, int dtype)
java: void divide(double scale, Mat src2, Mat dst)
FUNC <void cv..eigenNonSymmetric [ARG Mat src=, ARG Mat eigenvalues=, ARG Mat eigenvectors=]>
java: void eigenNonSymmetric(Mat src, Mat eigenvalues, Mat eigenvectors)
FUNC <void cv..exp [ARG Mat src=, ARG Mat dst=]>
java: void exp(Mat src, Mat dst)
FUNC <void cv..extractChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>
java: void extractChannel(Mat src, Mat dst, int coi)
FUNC <void cv..findNonZero [ARG Mat src=, ARG Mat idx=]>
java: void findNonZero(Mat src, Mat idx)
FUNC <void cv..flip [ARG Mat src=, ARG Mat dst=, ARG int flipCode=]>
java: void flip(Mat src, Mat dst, int flipCode)
FUNC <void cv..gemm [ARG Mat src1=, ARG Mat src2=, ARG double alpha=, ARG Mat src3=, ARG double beta=, ARG Mat dst=, ARG int flags=0]>
java: void gemm(Mat src1, Mat src2, double alpha, Mat src3, double beta, Mat dst, int flags)
java: void gemm(Mat src1, Mat src2, double alpha, Mat src3, double beta, Mat dst)
FUNC <void cv..hconcat [ARG vector_Mat src=, ARG Mat dst=]>
java: void hconcat(List<Mat> src, Mat dst)
FUNC <void cv..idct [ARG Mat src=, ARG Mat dst=, ARG int flags=0]>
java: void idct(Mat src, Mat dst, int flags)
java: void idct(Mat src, Mat dst)
FUNC <void cv..idft [ARG Mat src=, ARG Mat dst=, ARG int flags=0, ARG int nonzeroRows=0]>
java: void idft(Mat src, Mat dst, int flags, int nonzeroRows)
java: void idft(Mat src, Mat dst, int flags)
java: void idft(Mat src, Mat dst)
FUNC <void cv..inRange [ARG Mat src=, ARG Scalar lowerb=, ARG Scalar upperb=, ARG Mat dst=]>
java: void inRange(Mat src, Scalar lowerb, Scalar upperb, Mat dst)
FUNC <void cv..insertChannel [ARG Mat src=, ARG Mat dst=, ARG int coi=]>
java: void insertChannel(Mat src, Mat dst, int coi)
FUNC <void cv..log [ARG Mat src=, ARG Mat dst=]>
java: void log(Mat src, Mat dst)
FUNC <void cv..magnitude [ARG Mat x=, ARG Mat y=, ARG Mat magnitude=]>
java: void magnitude(Mat x, Mat y, Mat magnitude)
FUNC <void cv..max [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void max(Mat src1, Mat src2, Mat dst)
FUNC <void cv..max [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void max(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..meanStdDev [ARG Mat src=, ARG vector_double mean=, ARG vector_double stddev=, ARG Mat mask=Mat()]>
java: void meanStdDev(Mat src, MatOfDouble mean, MatOfDouble stddev, Mat mask)
java: void meanStdDev(Mat src, MatOfDouble mean, MatOfDouble stddev)
FUNC <void cv..merge [ARG vector_Mat mv=, ARG Mat dst=]>
java: void merge(List<Mat> mv, Mat dst)
FUNC <void cv..min [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=]>
java: void min(Mat src1, Mat src2, Mat dst)
FUNC <void cv..min [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=]>
java: void min(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..mixChannels [ARG vector_Mat src=, ARG vector_Mat dst=, ARG vector_int fromTo=]>
java: void mixChannels(List<Mat> src, List<Mat> dst, MatOfInt fromTo)
FUNC <void cv..mulSpectrums [ARG Mat a=, ARG Mat b=, ARG Mat c=, ARG int flags=, ARG bool conjB=false]>
java: void mulSpectrums(Mat a, Mat b, Mat c, int flags, boolean conjB)
java: void mulSpectrums(Mat a, Mat b, Mat c, int flags)
FUNC <void cv..mulTransposed [ARG Mat src=, ARG Mat dst=, ARG bool aTa=, ARG Mat delta=Mat(), ARG double scale=1, ARG int dtype=-1]>
java: void mulTransposed(Mat src, Mat dst, boolean aTa, Mat delta, double scale, int dtype)
java: void mulTransposed(Mat src, Mat dst, boolean aTa, Mat delta, double scale)
java: void mulTransposed(Mat src, Mat dst, boolean aTa, Mat delta)
java: void mulTransposed(Mat src, Mat dst, boolean aTa)
FUNC <void cv..multiply [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void multiply(Mat src1, Mat src2, Mat dst, double scale, int dtype)
java: void multiply(Mat src1, Mat src2, Mat dst, double scale)
java: void multiply(Mat src1, Mat src2, Mat dst)
FUNC <void cv..multiply [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG double scale=1, ARG int dtype=-1]>
java: void multiply(Mat src1, Scalar src2, Mat dst, double scale, int dtype)
java: void multiply(Mat src1, Scalar src2, Mat dst, double scale)
java: void multiply(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..normalize [ARG Mat src=, ARG Mat dst=, ARG double alpha=1, ARG double beta=0, ARG int norm_type=NORM_L2, ARG int dtype=-1, ARG Mat mask=Mat()]>
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type, int dtype, Mat mask)
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type, int dtype)
java: void normalize(Mat src, Mat dst, double alpha, double beta, int norm_type)
java: void normalize(Mat src, Mat dst, double alpha, double beta)
java: void normalize(Mat src, Mat dst, double alpha)
java: void normalize(Mat src, Mat dst)
FUNC <void cv..patchNaNs [ARG Mat a=, ARG double val=0]>
java: void patchNaNs(Mat a, double val)
java: void patchNaNs(Mat a)
FUNC <void cv..perspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>
java: void perspectiveTransform(Mat src, Mat dst, Mat m)
FUNC <void cv..phase [ARG Mat x=, ARG Mat y=, ARG Mat angle=, ARG bool angleInDegrees=false]>
java: void phase(Mat x, Mat y, Mat angle, boolean angleInDegrees)
java: void phase(Mat x, Mat y, Mat angle)
FUNC <void cv..polarToCart [ARG Mat magnitude=, ARG Mat angle=, ARG Mat x=, ARG Mat y=, ARG bool angleInDegrees=false]>
java: void polarToCart(Mat magnitude, Mat angle, Mat x, Mat y, boolean angleInDegrees)
java: void polarToCart(Mat magnitude, Mat angle, Mat x, Mat y)
FUNC <void cv..pow [ARG Mat src=, ARG double power=, ARG Mat dst=]>
java: void pow(Mat src, double power, Mat dst)
FUNC <void cv..randShuffle [ARG Mat dst=, ARG double iterFactor=1., ARG RNG * rng=0]>
java: void randShuffle(Mat dst, double iterFactor)
java: void randShuffle(Mat dst, double iterFactor)
java: void randShuffle(Mat dst)
FUNC <void cv..randn [ARG Mat dst=, ARG double mean=, ARG double stddev=]>
java: void randn(Mat dst, double mean, double stddev)
FUNC <void cv..randu [ARG Mat dst=, ARG double low=, ARG double high=]>
java: void randu(Mat dst, double low, double high)
FUNC <void cv..reduce [ARG Mat src=, ARG Mat dst=, ARG int dim=, ARG int rtype=, ARG int dtype=-1]>
java: void reduce(Mat src, Mat dst, int dim, int rtype, int dtype)
java: void reduce(Mat src, Mat dst, int dim, int rtype)
FUNC <void cv..repeat [ARG Mat src=, ARG int ny=, ARG int nx=, ARG Mat dst=]>
java: void repeat(Mat src, int ny, int nx, Mat dst)
FUNC <void cv..rotate [ARG Mat src=, ARG Mat dst=, ARG int rotateCode=]>
java: void rotate(Mat src, Mat dst, int rotateCode)
FUNC <void cv..scaleAdd [ARG Mat src1=, ARG double alpha=, ARG Mat src2=, ARG Mat dst=]>
java: void scaleAdd(Mat src1, double alpha, Mat src2, Mat dst)
FUNC <void cv..setErrorVerbosity [ARG bool verbose=]>
java: void setErrorVerbosity(boolean verbose)
FUNC <void cv..setIdentity [ARG Mat mtx=, ARG Scalar s=Scalar(1)]>
java: void setIdentity(Mat mtx, Scalar s)
java: void setIdentity(Mat mtx)
FUNC <void cv..setNumThreads [ARG int nthreads=]>
java: void setNumThreads(int nthreads)
FUNC <void cv..setRNGSeed [ARG int seed=]>
java: void setRNGSeed(int seed)
FUNC <void cv..sort [ARG Mat src=, ARG Mat dst=, ARG int flags=]>
java: void sort(Mat src, Mat dst, int flags)
FUNC <void cv..sortIdx [ARG Mat src=, ARG Mat dst=, ARG int flags=]>
java: void sortIdx(Mat src, Mat dst, int flags)
FUNC <void cv..split [ARG Mat m=, ARG vector_Mat mv=]>
java: void split(Mat m, List<Mat> mv)
FUNC <void cv..sqrt [ARG Mat src=, ARG Mat dst=]>
java: void sqrt(Mat src, Mat dst)
FUNC <void cv..subtract [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void subtract(Mat src1, Mat src2, Mat dst, Mat mask, int dtype)
java: void subtract(Mat src1, Mat src2, Mat dst, Mat mask)
java: void subtract(Mat src1, Mat src2, Mat dst)
FUNC <void cv..subtract [ARG Mat src1=, ARG Scalar src2=, ARG Mat dst=, ARG Mat mask=Mat(), ARG int dtype=-1]>
java: void subtract(Mat src1, Scalar src2, Mat dst, Mat mask, int dtype)
java: void subtract(Mat src1, Scalar src2, Mat dst, Mat mask)
java: void subtract(Mat src1, Scalar src2, Mat dst)
FUNC <void cv..transform [ARG Mat src=, ARG Mat dst=, ARG Mat m=]>
java: void transform(Mat src, Mat dst, Mat m)
FUNC <void cv..transpose [ARG Mat src=, ARG Mat dst=]>
java: void transpose(Mat src, Mat dst)
FUNC <void cv..vconcat [ARG vector_Mat src=, ARG Mat dst=]>
java: void vconcat(List<Mat> src, Mat dst)
FUNC <void cv.ipp..setUseIPP [ARG bool flag=]>
java: void setUseIPP(boolean flag)
FUNC <void cv.ipp..setUseIPP_NotExact [ARG bool flag=]>
java: void setUseIPP_NotExact(boolean flag)
FUNC <void cv.samples..addSamplesDataSearchPath [ARG String path=]>
java: void addSamplesDataSearchPath(String path)
FUNC <void cv.samples..addSamplesDataSearchSubDirectory [ARG String subdir=]>
java: void addSamplesDataSearchSubDirectory(String subdir)
CLASS cv::.Algorithm : 
FUNC <String cv.Algorithm.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.Algorithm.empty []>
java: boolean empty()
FUNC <void cv.Algorithm.clear []>
java: void clear()
FUNC <void cv.Algorithm.read [ARG FileNode fn=]>
SKIP:void cv::Algorithm::read(FileNode fn)	 due to ARG type FileNode/I
FUNC <void cv.Algorithm.save [ARG String filename=]>
java: void save(String filename)
FUNC <void cv.Algorithm.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>
SKIP:void cv::Algorithm::write(Ptr_FileStorage fs, String name = String())	 due to ARG type Ptr_FileStorage/I
CLASS cv::.TickMeter : 
FUNC < cv.TickMeter.TickMeter []>
java:  TickMeter()
FUNC <double cv.TickMeter.getTimeMicro []>
java: double getTimeMicro()
FUNC <double cv.TickMeter.getTimeMilli []>
java: double getTimeMilli()
FUNC <double cv.TickMeter.getTimeSec []>
java: double getTimeSec()
FUNC <int64 cv.TickMeter.getCounter []>
java: long getCounter()
FUNC <int64 cv.TickMeter.getTimeTicks []>
java: long getTimeTicks()
FUNC <void cv.TickMeter.reset []>
java: void reset()
FUNC <void cv.TickMeter.start []>
java: void start()
FUNC <void cv.TickMeter.stop []>
java: void stop()

=== MODULE: imgproc (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc) ===


Files (7):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/imgproc_c.h',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/types_c.h',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/hal/interface.h',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/imgproc.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/hal/hal.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/detail/gcgraph.hpp']

Common headers (0):
[]
ok: class CLASS ::.Imgproc : , name: Imgproc, base: 


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/imgproc_c.h =====
Namespaces: set([''])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/imgproc_c.h


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/types_c.h =====
Namespaces: set([''])

--- Incoming ---
[   u'enum SmoothMethod_c',
    '',
    [],
    [   [u'const CV_BLUR_NO_SCALE', u'0', [], [], None, ''],
        [u'const CV_BLUR', u'1', [], [], None, ''],
        [u'const CV_GAUSSIAN', u'2', [], [], None, ''],
        [u'const CV_MEDIAN', u'3', [], [], None, ''],
        [u'const CV_BILATERAL', u'4', [], [], None, '']],
    None]
ok: CONST CV_BLUR_NO_SCALE=0
ok: CONST CV_BLUR=1
ok: CONST CV_GAUSSIAN=2
ok: CONST CV_MEDIAN=3
ok: CONST CV_BILATERAL=4

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [[u'const CV_GAUSSIAN_5x5', u'7', [], [], None, '']],
    None]
ok: CONST CV_GAUSSIAN_5x5=7

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_SCHARR', u'-1', [], [], None, ''],
        [u'const CV_MAX_SOBEL_KSIZE', u'7', [], [], None, '']],
    None]
ok: CONST CV_SCHARR=-1
ok: CONST CV_MAX_SOBEL_KSIZE=7

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_BGR2BGRA', u'0', [], [], None, ''],
        [u'const CV_RGB2RGBA', u'CV_BGR2BGRA', [], [], None, ''],
        [u'const CV_BGRA2BGR', u'1', [], [], None, ''],
        [u'const CV_RGBA2RGB', u'CV_BGRA2BGR', [], [], None, ''],
        [u'const CV_BGR2RGBA', u'2', [], [], None, ''],
        [u'const CV_RGB2BGRA', u'CV_BGR2RGBA', [], [], None, ''],
        [u'const CV_RGBA2BGR', u'3', [], [], None, ''],
        [u'const CV_BGRA2RGB', u'CV_RGBA2BGR', [], [], None, ''],
        [u'const CV_BGR2RGB', u'4', [], [], None, ''],
        [u'const CV_RGB2BGR', u'CV_BGR2RGB', [], [], None, ''],
        [u'const CV_BGRA2RGBA', u'5', [], [], None, ''],
        [u'const CV_RGBA2BGRA', u'CV_BGRA2RGBA', [], [], None, ''],
        [u'const CV_BGR2GRAY', u'6', [], [], None, ''],
        [u'const CV_RGB2GRAY', u'7', [], [], None, ''],
        [u'const CV_GRAY2BGR', u'8', [], [], None, ''],
        [u'const CV_GRAY2RGB', u'CV_GRAY2BGR', [], [], None, ''],
        [u'const CV_GRAY2BGRA', u'9', [], [], None, ''],
        [u'const CV_GRAY2RGBA', u'CV_GRAY2BGRA', [], [], None, ''],
        [u'const CV_BGRA2GRAY', u'10', [], [], None, ''],
        [u'const CV_RGBA2GRAY', u'11', [], [], None, ''],
        [u'const CV_BGR2BGR565', u'12', [], [], None, ''],
        [u'const CV_RGB2BGR565', u'13', [], [], None, ''],
        [u'const CV_BGR5652BGR', u'14', [], [], None, ''],
        [u'const CV_BGR5652RGB', u'15', [], [], None, ''],
        [u'const CV_BGRA2BGR565', u'16', [], [], None, ''],
        [u'const CV_RGBA2BGR565', u'17', [], [], None, ''],
        [u'const CV_BGR5652BGRA', u'18', [], [], None, ''],
        [u'const CV_BGR5652RGBA', u'19', [], [], None, ''],
        [u'const CV_GRAY2BGR565', u'20', [], [], None, ''],
        [u'const CV_BGR5652GRAY', u'21', [], [], None, ''],
        [u'const CV_BGR2BGR555', u'22', [], [], None, ''],
        [u'const CV_RGB2BGR555', u'23', [], [], None, ''],
        [u'const CV_BGR5552BGR', u'24', [], [], None, ''],
        [u'const CV_BGR5552RGB', u'25', [], [], None, ''],
        [u'const CV_BGRA2BGR555', u'26', [], [], None, ''],
        [u'const CV_RGBA2BGR555', u'27', [], [], None, ''],
        [u'const CV_BGR5552BGRA', u'28', [], [], None, ''],
        [u'const CV_BGR5552RGBA', u'29', [], [], None, ''],
        [u'const CV_GRAY2BGR555', u'30', [], [], None, ''],
        [u'const CV_BGR5552GRAY', u'31', [], [], None, ''],
        [u'const CV_BGR2XYZ', u'32', [], [], None, ''],
        [u'const CV_RGB2XYZ', u'33', [], [], None, ''],
        [u'const CV_XYZ2BGR', u'34', [], [], None, ''],
        [u'const CV_XYZ2RGB', u'35', [], [], None, ''],
        [u'const CV_BGR2YCrCb', u'36', [], [], None, ''],
        [u'const CV_RGB2YCrCb', u'37', [], [], None, ''],
        [u'const CV_YCrCb2BGR', u'38', [], [], None, ''],
        [u'const CV_YCrCb2RGB', u'39', [], [], None, ''],
        [u'const CV_BGR2HSV', u'40', [], [], None, ''],
        [u'const CV_RGB2HSV', u'41', [], [], None, ''],
        [u'const CV_BGR2Lab', u'44', [], [], None, ''],
        [u'const CV_RGB2Lab', u'45', [], [], None, ''],
        [u'const CV_BayerBG2BGR', u'46', [], [], None, ''],
        [u'const CV_BayerGB2BGR', u'47', [], [], None, ''],
        [u'const CV_BayerRG2BGR', u'48', [], [], None, ''],
        [u'const CV_BayerGR2BGR', u'49', [], [], None, ''],
        [u'const CV_BayerBG2RGB', u'CV_BayerRG2BGR', [], [], None, ''],
        [u'const CV_BayerGB2RGB', u'CV_BayerGR2BGR', [], [], None, ''],
        [u'const CV_BayerRG2RGB', u'CV_BayerBG2BGR', [], [], None, ''],
        [u'const CV_BayerGR2RGB', u'CV_BayerGB2BGR', [], [], None, ''],
        [u'const CV_BGR2Luv', u'50', [], [], None, ''],
        [u'const CV_RGB2Luv', u'51', [], [], None, ''],
        [u'const CV_BGR2HLS', u'52', [], [], None, ''],
        [u'const CV_RGB2HLS', u'53', [], [], None, ''],
        [u'const CV_HSV2BGR', u'54', [], [], None, ''],
        [u'const CV_HSV2RGB', u'55', [], [], None, ''],
        [u'const CV_Lab2BGR', u'56', [], [], None, ''],
        [u'const CV_Lab2RGB', u'57', [], [], None, ''],
        [u'const CV_Luv2BGR', u'58', [], [], None, ''],
        [u'const CV_Luv2RGB', u'59', [], [], None, ''],
        [u'const CV_HLS2BGR', u'60', [], [], None, ''],
        [u'const CV_HLS2RGB', u'61', [], [], None, ''],
        [u'const CV_BayerBG2BGR_VNG', u'62', [], [], None, ''],
        [u'const CV_BayerGB2BGR_VNG', u'63', [], [], None, ''],
        [u'const CV_BayerRG2BGR_VNG', u'64', [], [], None, ''],
        [u'const CV_BayerGR2BGR_VNG', u'65', [], [], None, ''],
        [   u'const CV_BayerBG2RGB_VNG',
            u'CV_BayerRG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const CV_BayerGB2RGB_VNG',
            u'CV_BayerGR2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const CV_BayerRG2RGB_VNG',
            u'CV_BayerBG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const CV_BayerGR2RGB_VNG',
            u'CV_BayerGB2BGR_VNG',
            [],
            [],
            None,
            ''],
        [u'const CV_BGR2HSV_FULL', u'66', [], [], None, ''],
        [u'const CV_RGB2HSV_FULL', u'67', [], [], None, ''],
        [u'const CV_BGR2HLS_FULL', u'68', [], [], None, ''],
        [u'const CV_RGB2HLS_FULL', u'69', [], [], None, ''],
        [u'const CV_HSV2BGR_FULL', u'70', [], [], None, ''],
        [u'const CV_HSV2RGB_FULL', u'71', [], [], None, ''],
        [u'const CV_HLS2BGR_FULL', u'72', [], [], None, ''],
        [u'const CV_HLS2RGB_FULL', u'73', [], [], None, ''],
        [u'const CV_LBGR2Lab', u'74', [], [], None, ''],
        [u'const CV_LRGB2Lab', u'75', [], [], None, ''],
        [u'const CV_LBGR2Luv', u'76', [], [], None, ''],
        [u'const CV_LRGB2Luv', u'77', [], [], None, ''],
        [u'const CV_Lab2LBGR', u'78', [], [], None, ''],
        [u'const CV_Lab2LRGB', u'79', [], [], None, ''],
        [u'const CV_Luv2LBGR', u'80', [], [], None, ''],
        [u'const CV_Luv2LRGB', u'81', [], [], None, ''],
        [u'const CV_BGR2YUV', u'82', [], [], None, ''],
        [u'const CV_RGB2YUV', u'83', [], [], None, ''],
        [u'const CV_YUV2BGR', u'84', [], [], None, ''],
        [u'const CV_YUV2RGB', u'85', [], [], None, ''],
        [u'const CV_BayerBG2GRAY', u'86', [], [], None, ''],
        [u'const CV_BayerGB2GRAY', u'87', [], [], None, ''],
        [u'const CV_BayerRG2GRAY', u'88', [], [], None, ''],
        [u'const CV_BayerGR2GRAY', u'89', [], [], None, ''],
        [u'const CV_YUV2RGB_NV12', u'90', [], [], None, ''],
        [u'const CV_YUV2BGR_NV12', u'91', [], [], None, ''],
        [u'const CV_YUV2RGB_NV21', u'92', [], [], None, ''],
        [u'const CV_YUV2BGR_NV21', u'93', [], [], None, ''],
        [u'const CV_YUV420sp2RGB', u'CV_YUV2RGB_NV21', [], [], None, ''],
        [u'const CV_YUV420sp2BGR', u'CV_YUV2BGR_NV21', [], [], None, ''],
        [u'const CV_YUV2RGBA_NV12', u'94', [], [], None, ''],
        [u'const CV_YUV2BGRA_NV12', u'95', [], [], None, ''],
        [u'const CV_YUV2RGBA_NV21', u'96', [], [], None, ''],
        [u'const CV_YUV2BGRA_NV21', u'97', [], [], None, ''],
        [u'const CV_YUV420sp2RGBA', u'CV_YUV2RGBA_NV21', [], [], None, ''],
        [u'const CV_YUV420sp2BGRA', u'CV_YUV2BGRA_NV21', [], [], None, ''],
        [u'const CV_YUV2RGB_YV12', u'98', [], [], None, ''],
        [u'const CV_YUV2BGR_YV12', u'99', [], [], None, ''],
        [u'const CV_YUV2RGB_IYUV', u'100', [], [], None, ''],
        [u'const CV_YUV2BGR_IYUV', u'101', [], [], None, ''],
        [u'const CV_YUV2RGB_I420', u'CV_YUV2RGB_IYUV', [], [], None, ''],
        [u'const CV_YUV2BGR_I420', u'CV_YUV2BGR_IYUV', [], [], None, ''],
        [u'const CV_YUV420p2RGB', u'CV_YUV2RGB_YV12', [], [], None, ''],
        [u'const CV_YUV420p2BGR', u'CV_YUV2BGR_YV12', [], [], None, ''],
        [u'const CV_YUV2RGBA_YV12', u'102', [], [], None, ''],
        [u'const CV_YUV2BGRA_YV12', u'103', [], [], None, ''],
        [u'const CV_YUV2RGBA_IYUV', u'104', [], [], None, ''],
        [u'const CV_YUV2BGRA_IYUV', u'105', [], [], None, ''],
        [u'const CV_YUV2RGBA_I420', u'CV_YUV2RGBA_IYUV', [], [], None, ''],
        [u'const CV_YUV2BGRA_I420', u'CV_YUV2BGRA_IYUV', [], [], None, ''],
        [u'const CV_YUV420p2RGBA', u'CV_YUV2RGBA_YV12', [], [], None, ''],
        [u'const CV_YUV420p2BGRA', u'CV_YUV2BGRA_YV12', [], [], None, ''],
        [u'const CV_YUV2GRAY_420', u'106', [], [], None, ''],
        [u'const CV_YUV2GRAY_NV21', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV2GRAY_NV12', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV2GRAY_YV12', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV2GRAY_IYUV', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV2GRAY_I420', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV420sp2GRAY', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV420p2GRAY', u'CV_YUV2GRAY_420', [], [], None, ''],
        [u'const CV_YUV2RGB_UYVY', u'107', [], [], None, ''],
        [u'const CV_YUV2BGR_UYVY', u'108', [], [], None, ''],
        [u'const CV_YUV2RGB_Y422', u'CV_YUV2RGB_UYVY', [], [], None, ''],
        [u'const CV_YUV2BGR_Y422', u'CV_YUV2BGR_UYVY', [], [], None, ''],
        [u'const CV_YUV2RGB_UYNV', u'CV_YUV2RGB_UYVY', [], [], None, ''],
        [u'const CV_YUV2BGR_UYNV', u'CV_YUV2BGR_UYVY', [], [], None, ''],
        [u'const CV_YUV2RGBA_UYVY', u'111', [], [], None, ''],
        [u'const CV_YUV2BGRA_UYVY', u'112', [], [], None, ''],
        [u'const CV_YUV2RGBA_Y422', u'CV_YUV2RGBA_UYVY', [], [], None, ''],
        [u'const CV_YUV2BGRA_Y422', u'CV_YUV2BGRA_UYVY', [], [], None, ''],
        [u'const CV_YUV2RGBA_UYNV', u'CV_YUV2RGBA_UYVY', [], [], None, ''],
        [u'const CV_YUV2BGRA_UYNV', u'CV_YUV2BGRA_UYVY', [], [], None, ''],
        [u'const CV_YUV2RGB_YUY2', u'115', [], [], None, ''],
        [u'const CV_YUV2BGR_YUY2', u'116', [], [], None, ''],
        [u'const CV_YUV2RGB_YVYU', u'117', [], [], None, ''],
        [u'const CV_YUV2BGR_YVYU', u'118', [], [], None, ''],
        [u'const CV_YUV2RGB_YUYV', u'CV_YUV2RGB_YUY2', [], [], None, ''],
        [u'const CV_YUV2BGR_YUYV', u'CV_YUV2BGR_YUY2', [], [], None, ''],
        [u'const CV_YUV2RGB_YUNV', u'CV_YUV2RGB_YUY2', [], [], None, ''],
        [u'const CV_YUV2BGR_YUNV', u'CV_YUV2BGR_YUY2', [], [], None, ''],
        [u'const CV_YUV2RGBA_YUY2', u'119', [], [], None, ''],
        [u'const CV_YUV2BGRA_YUY2', u'120', [], [], None, ''],
        [u'const CV_YUV2RGBA_YVYU', u'121', [], [], None, ''],
        [u'const CV_YUV2BGRA_YVYU', u'122', [], [], None, ''],
        [u'const CV_YUV2RGBA_YUYV', u'CV_YUV2RGBA_YUY2', [], [], None, ''],
        [u'const CV_YUV2BGRA_YUYV', u'CV_YUV2BGRA_YUY2', [], [], None, ''],
        [u'const CV_YUV2RGBA_YUNV', u'CV_YUV2RGBA_YUY2', [], [], None, ''],
        [u'const CV_YUV2BGRA_YUNV', u'CV_YUV2BGRA_YUY2', [], [], None, ''],
        [u'const CV_YUV2GRAY_UYVY', u'123', [], [], None, ''],
        [u'const CV_YUV2GRAY_YUY2', u'124', [], [], None, ''],
        [u'const CV_YUV2GRAY_Y422', u'CV_YUV2GRAY_UYVY', [], [], None, ''],
        [u'const CV_YUV2GRAY_UYNV', u'CV_YUV2GRAY_UYVY', [], [], None, ''],
        [u'const CV_YUV2GRAY_YVYU', u'CV_YUV2GRAY_YUY2', [], [], None, ''],
        [u'const CV_YUV2GRAY_YUYV', u'CV_YUV2GRAY_YUY2', [], [], None, ''],
        [u'const CV_YUV2GRAY_YUNV', u'CV_YUV2GRAY_YUY2', [], [], None, ''],
        [u'const CV_RGBA2mRGBA', u'125', [], [], None, ''],
        [u'const CV_mRGBA2RGBA', u'126', [], [], None, ''],
        [u'const CV_RGB2YUV_I420', u'127', [], [], None, ''],
        [u'const CV_BGR2YUV_I420', u'128', [], [], None, ''],
        [u'const CV_RGB2YUV_IYUV', u'CV_RGB2YUV_I420', [], [], None, ''],
        [u'const CV_BGR2YUV_IYUV', u'CV_BGR2YUV_I420', [], [], None, ''],
        [u'const CV_RGBA2YUV_I420', u'129', [], [], None, ''],
        [u'const CV_BGRA2YUV_I420', u'130', [], [], None, ''],
        [u'const CV_RGBA2YUV_IYUV', u'CV_RGBA2YUV_I420', [], [], None, ''],
        [u'const CV_BGRA2YUV_IYUV', u'CV_BGRA2YUV_I420', [], [], None, ''],
        [u'const CV_RGB2YUV_YV12', u'131', [], [], None, ''],
        [u'const CV_BGR2YUV_YV12', u'132', [], [], None, ''],
        [u'const CV_RGBA2YUV_YV12', u'133', [], [], None, ''],
        [u'const CV_BGRA2YUV_YV12', u'134', [], [], None, ''],
        [u'const CV_BayerBG2BGR_EA', u'135', [], [], None, ''],
        [u'const CV_BayerGB2BGR_EA', u'136', [], [], None, ''],
        [u'const CV_BayerRG2BGR_EA', u'137', [], [], None, ''],
        [u'const CV_BayerGR2BGR_EA', u'138', [], [], None, ''],
        [u'const CV_BayerBG2RGB_EA', u'CV_BayerRG2BGR_EA', [], [], None, ''],
        [u'const CV_BayerGB2RGB_EA', u'CV_BayerGR2BGR_EA', [], [], None, ''],
        [u'const CV_BayerRG2RGB_EA', u'CV_BayerBG2BGR_EA', [], [], None, ''],
        [u'const CV_BayerGR2RGB_EA', u'CV_BayerGB2BGR_EA', [], [], None, ''],
        [u'const CV_BayerBG2BGRA', u'139', [], [], None, ''],
        [u'const CV_BayerGB2BGRA', u'140', [], [], None, ''],
        [u'const CV_BayerRG2BGRA', u'141', [], [], None, ''],
        [u'const CV_BayerGR2BGRA', u'142', [], [], None, ''],
        [u'const CV_BayerBG2RGBA', u'CV_BayerRG2BGRA', [], [], None, ''],
        [u'const CV_BayerGB2RGBA', u'CV_BayerGR2BGRA', [], [], None, ''],
        [u'const CV_BayerRG2RGBA', u'CV_BayerBG2BGRA', [], [], None, ''],
        [u'const CV_BayerGR2RGBA', u'CV_BayerGB2BGRA', [], [], None, ''],
        [u'const CV_COLORCVT_MAX', u'143', [], [], None, '']],
    None]
ignored: CONST CV_BGR2BGRA=0
ignored: CONST CV_RGB2RGBA=CV_BGR2BGRA
ignored: CONST CV_BGRA2BGR=1
ignored: CONST CV_RGBA2RGB=CV_BGRA2BGR
ignored: CONST CV_BGR2RGBA=2
ignored: CONST CV_RGB2BGRA=CV_BGR2RGBA
ignored: CONST CV_RGBA2BGR=3
ignored: CONST CV_BGRA2RGB=CV_RGBA2BGR
ignored: CONST CV_BGR2RGB=4
ignored: CONST CV_RGB2BGR=CV_BGR2RGB
ignored: CONST CV_BGRA2RGBA=5
ignored: CONST CV_RGBA2BGRA=CV_BGRA2RGBA
ignored: CONST CV_BGR2GRAY=6
ignored: CONST CV_RGB2GRAY=7
ignored: CONST CV_GRAY2BGR=8
ignored: CONST CV_GRAY2RGB=CV_GRAY2BGR
ignored: CONST CV_GRAY2BGRA=9
ignored: CONST CV_GRAY2RGBA=CV_GRAY2BGRA
ignored: CONST CV_BGRA2GRAY=10
ignored: CONST CV_RGBA2GRAY=11
ignored: CONST CV_BGR2BGR565=12
ignored: CONST CV_RGB2BGR565=13
ignored: CONST CV_BGR5652BGR=14
ignored: CONST CV_BGR5652RGB=15
ignored: CONST CV_BGRA2BGR565=16
ignored: CONST CV_RGBA2BGR565=17
ignored: CONST CV_BGR5652BGRA=18
ignored: CONST CV_BGR5652RGBA=19
ignored: CONST CV_GRAY2BGR565=20
ignored: CONST CV_BGR5652GRAY=21
ignored: CONST CV_BGR2BGR555=22
ignored: CONST CV_RGB2BGR555=23
ignored: CONST CV_BGR5552BGR=24
ignored: CONST CV_BGR5552RGB=25
ignored: CONST CV_BGRA2BGR555=26
ignored: CONST CV_RGBA2BGR555=27
ignored: CONST CV_BGR5552BGRA=28
ignored: CONST CV_BGR5552RGBA=29
ignored: CONST CV_GRAY2BGR555=30
ignored: CONST CV_BGR5552GRAY=31
ignored: CONST CV_BGR2XYZ=32
ignored: CONST CV_RGB2XYZ=33
ignored: CONST CV_XYZ2BGR=34
ignored: CONST CV_XYZ2RGB=35
ignored: CONST CV_BGR2YCrCb=36
ignored: CONST CV_RGB2YCrCb=37
ignored: CONST CV_YCrCb2BGR=38
ignored: CONST CV_YCrCb2RGB=39
ignored: CONST CV_BGR2HSV=40
ignored: CONST CV_RGB2HSV=41
ignored: CONST CV_BGR2Lab=44
ignored: CONST CV_RGB2Lab=45
ignored: CONST CV_BayerBG2BGR=46
ignored: CONST CV_BayerGB2BGR=47
ignored: CONST CV_BayerRG2BGR=48
ignored: CONST CV_BayerGR2BGR=49
ignored: CONST CV_BayerBG2RGB=CV_BayerRG2BGR
ignored: CONST CV_BayerGB2RGB=CV_BayerGR2BGR
ignored: CONST CV_BayerRG2RGB=CV_BayerBG2BGR
ignored: CONST CV_BayerGR2RGB=CV_BayerGB2BGR
ignored: CONST CV_BGR2Luv=50
ignored: CONST CV_RGB2Luv=51
ignored: CONST CV_BGR2HLS=52
ignored: CONST CV_RGB2HLS=53
ignored: CONST CV_HSV2BGR=54
ignored: CONST CV_HSV2RGB=55
ignored: CONST CV_Lab2BGR=56
ignored: CONST CV_Lab2RGB=57
ignored: CONST CV_Luv2BGR=58
ignored: CONST CV_Luv2RGB=59
ignored: CONST CV_HLS2BGR=60
ignored: CONST CV_HLS2RGB=61
ignored: CONST CV_BayerBG2BGR_VNG=62
ignored: CONST CV_BayerGB2BGR_VNG=63
ignored: CONST CV_BayerRG2BGR_VNG=64
ignored: CONST CV_BayerGR2BGR_VNG=65
ignored: CONST CV_BayerBG2RGB_VNG=CV_BayerRG2BGR_VNG
ignored: CONST CV_BayerGB2RGB_VNG=CV_BayerGR2BGR_VNG
ignored: CONST CV_BayerRG2RGB_VNG=CV_BayerBG2BGR_VNG
ignored: CONST CV_BayerGR2RGB_VNG=CV_BayerGB2BGR_VNG
ignored: CONST CV_BGR2HSV_FULL=66
ignored: CONST CV_RGB2HSV_FULL=67
ignored: CONST CV_BGR2HLS_FULL=68
ignored: CONST CV_RGB2HLS_FULL=69
ignored: CONST CV_HSV2BGR_FULL=70
ignored: CONST CV_HSV2RGB_FULL=71
ignored: CONST CV_HLS2BGR_FULL=72
ignored: CONST CV_HLS2RGB_FULL=73
ignored: CONST CV_LBGR2Lab=74
ignored: CONST CV_LRGB2Lab=75
ignored: CONST CV_LBGR2Luv=76
ignored: CONST CV_LRGB2Luv=77
ignored: CONST CV_Lab2LBGR=78
ignored: CONST CV_Lab2LRGB=79
ignored: CONST CV_Luv2LBGR=80
ignored: CONST CV_Luv2LRGB=81
ignored: CONST CV_BGR2YUV=82
ignored: CONST CV_RGB2YUV=83
ignored: CONST CV_YUV2BGR=84
ignored: CONST CV_YUV2RGB=85
ignored: CONST CV_BayerBG2GRAY=86
ignored: CONST CV_BayerGB2GRAY=87
ignored: CONST CV_BayerRG2GRAY=88
ignored: CONST CV_BayerGR2GRAY=89
ignored: CONST CV_YUV2RGB_NV12=90
ignored: CONST CV_YUV2BGR_NV12=91
ignored: CONST CV_YUV2RGB_NV21=92
ignored: CONST CV_YUV2BGR_NV21=93
ignored: CONST CV_YUV420sp2RGB=CV_YUV2RGB_NV21
ignored: CONST CV_YUV420sp2BGR=CV_YUV2BGR_NV21
ignored: CONST CV_YUV2RGBA_NV12=94
ignored: CONST CV_YUV2BGRA_NV12=95
ignored: CONST CV_YUV2RGBA_NV21=96
ignored: CONST CV_YUV2BGRA_NV21=97
ignored: CONST CV_YUV420sp2RGBA=CV_YUV2RGBA_NV21
ignored: CONST CV_YUV420sp2BGRA=CV_YUV2BGRA_NV21
ignored: CONST CV_YUV2RGB_YV12=98
ignored: CONST CV_YUV2BGR_YV12=99
ignored: CONST CV_YUV2RGB_IYUV=100
ignored: CONST CV_YUV2BGR_IYUV=101
ignored: CONST CV_YUV2RGB_I420=CV_YUV2RGB_IYUV
ignored: CONST CV_YUV2BGR_I420=CV_YUV2BGR_IYUV
ignored: CONST CV_YUV420p2RGB=CV_YUV2RGB_YV12
ignored: CONST CV_YUV420p2BGR=CV_YUV2BGR_YV12
ignored: CONST CV_YUV2RGBA_YV12=102
ignored: CONST CV_YUV2BGRA_YV12=103
ignored: CONST CV_YUV2RGBA_IYUV=104
ignored: CONST CV_YUV2BGRA_IYUV=105
ignored: CONST CV_YUV2RGBA_I420=CV_YUV2RGBA_IYUV
ignored: CONST CV_YUV2BGRA_I420=CV_YUV2BGRA_IYUV
ignored: CONST CV_YUV420p2RGBA=CV_YUV2RGBA_YV12
ignored: CONST CV_YUV420p2BGRA=CV_YUV2BGRA_YV12
ignored: CONST CV_YUV2GRAY_420=106
ignored: CONST CV_YUV2GRAY_NV21=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_NV12=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_YV12=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_IYUV=CV_YUV2GRAY_420
ignored: CONST CV_YUV2GRAY_I420=CV_YUV2GRAY_420
ignored: CONST CV_YUV420sp2GRAY=CV_YUV2GRAY_420
ignored: CONST CV_YUV420p2GRAY=CV_YUV2GRAY_420
ignored: CONST CV_YUV2RGB_UYVY=107
ignored: CONST CV_YUV2BGR_UYVY=108
ignored: CONST CV_YUV2RGB_Y422=CV_YUV2RGB_UYVY
ignored: CONST CV_YUV2BGR_Y422=CV_YUV2BGR_UYVY
ignored: CONST CV_YUV2RGB_UYNV=CV_YUV2RGB_UYVY
ignored: CONST CV_YUV2BGR_UYNV=CV_YUV2BGR_UYVY
ignored: CONST CV_YUV2RGBA_UYVY=111
ignored: CONST CV_YUV2BGRA_UYVY=112
ignored: CONST CV_YUV2RGBA_Y422=CV_YUV2RGBA_UYVY
ignored: CONST CV_YUV2BGRA_Y422=CV_YUV2BGRA_UYVY
ignored: CONST CV_YUV2RGBA_UYNV=CV_YUV2RGBA_UYVY
ignored: CONST CV_YUV2BGRA_UYNV=CV_YUV2BGRA_UYVY
ignored: CONST CV_YUV2RGB_YUY2=115
ignored: CONST CV_YUV2BGR_YUY2=116
ignored: CONST CV_YUV2RGB_YVYU=117
ignored: CONST CV_YUV2BGR_YVYU=118
ignored: CONST CV_YUV2RGB_YUYV=CV_YUV2RGB_YUY2
ignored: CONST CV_YUV2BGR_YUYV=CV_YUV2BGR_YUY2
ignored: CONST CV_YUV2RGB_YUNV=CV_YUV2RGB_YUY2
ignored: CONST CV_YUV2BGR_YUNV=CV_YUV2BGR_YUY2
ignored: CONST CV_YUV2RGBA_YUY2=119
ignored: CONST CV_YUV2BGRA_YUY2=120
ignored: CONST CV_YUV2RGBA_YVYU=121
ignored: CONST CV_YUV2BGRA_YVYU=122
ignored: CONST CV_YUV2RGBA_YUYV=CV_YUV2RGBA_YUY2
ignored: CONST CV_YUV2BGRA_YUYV=CV_YUV2BGRA_YUY2
ignored: CONST CV_YUV2RGBA_YUNV=CV_YUV2RGBA_YUY2
ignored: CONST CV_YUV2BGRA_YUNV=CV_YUV2BGRA_YUY2
ignored: CONST CV_YUV2GRAY_UYVY=123
ignored: CONST CV_YUV2GRAY_YUY2=124
ignored: CONST CV_YUV2GRAY_Y422=CV_YUV2GRAY_UYVY
ignored: CONST CV_YUV2GRAY_UYNV=CV_YUV2GRAY_UYVY
ignored: CONST CV_YUV2GRAY_YVYU=CV_YUV2GRAY_YUY2
ignored: CONST CV_YUV2GRAY_YUYV=CV_YUV2GRAY_YUY2
ignored: CONST CV_YUV2GRAY_YUNV=CV_YUV2GRAY_YUY2
ok: CONST CV_RGBA2mRGBA=125
ok: CONST CV_mRGBA2RGBA=126
ignored: CONST CV_RGB2YUV_I420=127
ignored: CONST CV_BGR2YUV_I420=128
ignored: CONST CV_RGB2YUV_IYUV=CV_RGB2YUV_I420
ignored: CONST CV_BGR2YUV_IYUV=CV_BGR2YUV_I420
ignored: CONST CV_RGBA2YUV_I420=129
ignored: CONST CV_BGRA2YUV_I420=130
ignored: CONST CV_RGBA2YUV_IYUV=CV_RGBA2YUV_I420
ignored: CONST CV_BGRA2YUV_IYUV=CV_BGRA2YUV_I420
ignored: CONST CV_RGB2YUV_YV12=131
ignored: CONST CV_BGR2YUV_YV12=132
ignored: CONST CV_RGBA2YUV_YV12=133
ignored: CONST CV_BGRA2YUV_YV12=134
ignored: CONST CV_BayerBG2BGR_EA=135
ignored: CONST CV_BayerGB2BGR_EA=136
ignored: CONST CV_BayerRG2BGR_EA=137
ignored: CONST CV_BayerGR2BGR_EA=138
ignored: CONST CV_BayerBG2RGB_EA=CV_BayerRG2BGR_EA
ignored: CONST CV_BayerGB2RGB_EA=CV_BayerGR2BGR_EA
ignored: CONST CV_BayerRG2RGB_EA=CV_BayerBG2BGR_EA
ignored: CONST CV_BayerGR2RGB_EA=CV_BayerGB2BGR_EA
ignored: CONST CV_BayerBG2BGRA=139
ignored: CONST CV_BayerGB2BGRA=140
ignored: CONST CV_BayerRG2BGRA=141
ignored: CONST CV_BayerGR2BGRA=142
ignored: CONST CV_BayerBG2RGBA=CV_BayerRG2BGRA
ignored: CONST CV_BayerGB2RGBA=CV_BayerGR2BGRA
ignored: CONST CV_BayerRG2RGBA=CV_BayerBG2BGRA
ignored: CONST CV_BayerGR2RGBA=CV_BayerGB2BGRA
ignored: CONST CV_COLORCVT_MAX=143

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_INTER_NN', u'0', [], [], None, ''],
        [u'const CV_INTER_LINEAR', u'1', [], [], None, ''],
        [u'const CV_INTER_CUBIC', u'2', [], [], None, ''],
        [u'const CV_INTER_AREA', u'3', [], [], None, ''],
        [u'const CV_INTER_LANCZOS4', u'4', [], [], None, '']],
    None]
ok: CONST CV_INTER_NN=0
ok: CONST CV_INTER_LINEAR=1
ok: CONST CV_INTER_CUBIC=2
ok: CONST CV_INTER_AREA=3
ok: CONST CV_INTER_LANCZOS4=4

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_WARP_FILL_OUTLIERS', u'8', [], [], None, ''],
        [u'const CV_WARP_INVERSE_MAP', u'16', [], [], None, '']],
    None]
ok: CONST CV_WARP_FILL_OUTLIERS=8
ok: CONST CV_WARP_INVERSE_MAP=16

--- Incoming ---
[   u'enum MorphShapes_c',
    '',
    [],
    [   [u'const CV_SHAPE_RECT', u'0', [], [], None, ''],
        [u'const CV_SHAPE_CROSS', u'1', [], [], None, ''],
        [u'const CV_SHAPE_ELLIPSE', u'2', [], [], None, ''],
        [u'const CV_SHAPE_CUSTOM', u'100', [], [], None, '']],
    None]
ok: CONST CV_SHAPE_RECT=0
ok: CONST CV_SHAPE_CROSS=1
ok: CONST CV_SHAPE_ELLIPSE=2
ok: CONST CV_SHAPE_CUSTOM=100

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_MOP_ERODE', u'0', [], [], None, ''],
        [u'const CV_MOP_DILATE', u'1', [], [], None, ''],
        [u'const CV_MOP_OPEN', u'2', [], [], None, ''],
        [u'const CV_MOP_CLOSE', u'3', [], [], None, ''],
        [u'const CV_MOP_GRADIENT', u'4', [], [], None, ''],
        [u'const CV_MOP_TOPHAT', u'5', [], [], None, ''],
        [u'const CV_MOP_BLACKHAT', u'6', [], [], None, '']],
    None]
ok: CONST CV_MOP_ERODE=0
ok: CONST CV_MOP_DILATE=1
ok: CONST CV_MOP_OPEN=2
ok: CONST CV_MOP_CLOSE=3
ok: CONST CV_MOP_GRADIENT=4
ok: CONST CV_MOP_TOPHAT=5
ok: CONST CV_MOP_BLACKHAT=6

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_TM_SQDIFF', u'0', [], [], None, ''],
        [u'const CV_TM_SQDIFF_NORMED', u'1', [], [], None, ''],
        [u'const CV_TM_CCORR', u'2', [], [], None, ''],
        [u'const CV_TM_CCORR_NORMED', u'3', [], [], None, ''],
        [u'const CV_TM_CCOEFF', u'4', [], [], None, ''],
        [u'const CV_TM_CCOEFF_NORMED', u'5', [], [], None, '']],
    None]
ignored: CONST CV_TM_SQDIFF=0
ignored: CONST CV_TM_SQDIFF_NORMED=1
ignored: CONST CV_TM_CCORR=2
ignored: CONST CV_TM_CCORR_NORMED=3
ignored: CONST CV_TM_CCOEFF=4
ignored: CONST CV_TM_CCOEFF_NORMED=5

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_RETR_EXTERNAL', u'0', [], [], None, ''],
        [u'const CV_RETR_LIST', u'1', [], [], None, ''],
        [u'const CV_RETR_CCOMP', u'2', [], [], None, ''],
        [u'const CV_RETR_TREE', u'3', [], [], None, ''],
        [u'const CV_RETR_FLOODFILL', u'4', [], [], None, '']],
    None]
ok: CONST CV_RETR_EXTERNAL=0
ok: CONST CV_RETR_LIST=1
ok: CONST CV_RETR_CCOMP=2
ok: CONST CV_RETR_TREE=3
ok: CONST CV_RETR_FLOODFILL=4

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_CHAIN_CODE', u'0', [], [], None, ''],
        [u'const CV_CHAIN_APPROX_NONE', u'1', [], [], None, ''],
        [u'const CV_CHAIN_APPROX_SIMPLE', u'2', [], [], None, ''],
        [u'const CV_CHAIN_APPROX_TC89_L1', u'3', [], [], None, ''],
        [u'const CV_CHAIN_APPROX_TC89_KCOS', u'4', [], [], None, ''],
        [u'const CV_LINK_RUNS', u'5', [], [], None, '']],
    None]
ok: CONST CV_CHAIN_CODE=0
ok: CONST CV_CHAIN_APPROX_NONE=1
ok: CONST CV_CHAIN_APPROX_SIMPLE=2
ok: CONST CV_CHAIN_APPROX_TC89_L1=3
ok: CONST CV_CHAIN_APPROX_TC89_KCOS=4
ok: CONST CV_LINK_RUNS=5

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [[u'const CV_POLY_APPROX_DP', u'0', [], [], None, '']],
    None]
ok: CONST CV_POLY_APPROX_DP=0

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_CONTOURS_MATCH_I1', u'1', [], [], None, ''],
        [u'const CV_CONTOURS_MATCH_I2', u'2', [], [], None, ''],
        [u'const CV_CONTOURS_MATCH_I3', u'3', [], [], None, '']],
    None]
ok: CONST CV_CONTOURS_MATCH_I1=1
ok: CONST CV_CONTOURS_MATCH_I2=2
ok: CONST CV_CONTOURS_MATCH_I3=3

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_CLOCKWISE', u'1', [], [], None, ''],
        [u'const CV_COUNTER_CLOCKWISE', u'2', [], [], None, '']],
    None]
ok: CONST CV_CLOCKWISE=1
ok: CONST CV_COUNTER_CLOCKWISE=2

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_COMP_CORREL', u'0', [], [], None, ''],
        [u'const CV_COMP_CHISQR', u'1', [], [], None, ''],
        [u'const CV_COMP_INTERSECT', u'2', [], [], None, ''],
        [u'const CV_COMP_BHATTACHARYYA', u'3', [], [], None, ''],
        [   u'const CV_COMP_HELLINGER',
            u'CV_COMP_BHATTACHARYYA',
            [],
            [],
            None,
            ''],
        [u'const CV_COMP_CHISQR_ALT', u'4', [], [], None, ''],
        [u'const CV_COMP_KL_DIV', u'5', [], [], None, '']],
    None]
ok: CONST CV_COMP_CORREL=0
ok: CONST CV_COMP_CHISQR=1
ok: CONST CV_COMP_INTERSECT=2
ok: CONST CV_COMP_BHATTACHARYYA=3
ok: CONST CV_COMP_HELLINGER=CV_COMP_BHATTACHARYYA
ok: CONST CV_COMP_CHISQR_ALT=4
ok: CONST CV_COMP_KL_DIV=5

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_DIST_MASK_3', u'3', [], [], None, ''],
        [u'const CV_DIST_MASK_5', u'5', [], [], None, ''],
        [u'const CV_DIST_MASK_PRECISE', u'0', [], [], None, '']],
    None]
ok: CONST CV_DIST_MASK_3=3
ok: CONST CV_DIST_MASK_5=5
ok: CONST CV_DIST_MASK_PRECISE=0

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_DIST_LABEL_CCOMP', u'0', [], [], None, ''],
        [u'const CV_DIST_LABEL_PIXEL', u'1', [], [], None, '']],
    None]
ok: CONST CV_DIST_LABEL_CCOMP=0
ok: CONST CV_DIST_LABEL_PIXEL=1

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_DIST_USER', u'-1', [], [], None, ''],
        [u'const CV_DIST_L1', u'1', [], [], None, ''],
        [u'const CV_DIST_L2', u'2', [], [], None, ''],
        [u'const CV_DIST_C', u'3', [], [], None, ''],
        [u'const CV_DIST_L12', u'4', [], [], None, ''],
        [u'const CV_DIST_FAIR', u'5', [], [], None, ''],
        [u'const CV_DIST_WELSCH', u'6', [], [], None, ''],
        [u'const CV_DIST_HUBER', u'7', [], [], None, '']],
    None]
ok: CONST CV_DIST_USER=-1
ok: CONST CV_DIST_L1=1
ok: CONST CV_DIST_L2=2
ok: CONST CV_DIST_C=3
ok: CONST CV_DIST_L12=4
ok: CONST CV_DIST_FAIR=5
ok: CONST CV_DIST_WELSCH=6
ok: CONST CV_DIST_HUBER=7

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_THRESH_BINARY', u'0', [], [], None, ''],
        [u'const CV_THRESH_BINARY_INV', u'1', [], [], None, ''],
        [u'const CV_THRESH_TRUNC', u'2', [], [], None, ''],
        [u'const CV_THRESH_TOZERO', u'3', [], [], None, ''],
        [u'const CV_THRESH_TOZERO_INV', u'4', [], [], None, ''],
        [u'const CV_THRESH_MASK', u'7', [], [], None, ''],
        [u'const CV_THRESH_OTSU', u'8', [], [], None, ''],
        [u'const CV_THRESH_TRIANGLE', u'16', [], [], None, '']],
    None]
ok: CONST CV_THRESH_BINARY=0
ok: CONST CV_THRESH_BINARY_INV=1
ok: CONST CV_THRESH_TRUNC=2
ok: CONST CV_THRESH_TOZERO=3
ok: CONST CV_THRESH_TOZERO_INV=4
ok: CONST CV_THRESH_MASK=7
ok: CONST CV_THRESH_OTSU=8
ok: CONST CV_THRESH_TRIANGLE=16

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_ADAPTIVE_THRESH_MEAN_C', u'0', [], [], None, ''],
        [u'const CV_ADAPTIVE_THRESH_GAUSSIAN_C', u'1', [], [], None, '']],
    None]
ignored: CONST CV_ADAPTIVE_THRESH_MEAN_C=0
ignored: CONST CV_ADAPTIVE_THRESH_GAUSSIAN_C=1

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_FLOODFILL_FIXED_RANGE', u'(1 << 16)', [], [], None, ''],
        [u'const CV_FLOODFILL_MASK_ONLY', u'(1 << 17)', [], [], None, '']],
    None]
ignored: CONST CV_FLOODFILL_FIXED_RANGE=(1 << 16)
ignored: CONST CV_FLOODFILL_MASK_ONLY=(1 << 17)

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [[u'const CV_CANNY_L2_GRADIENT', u'(1 << 31)', [], [], None, '']],
    None]
ok: CONST CV_CANNY_L2_GRADIENT=(1 << 31)

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_HOUGH_STANDARD', u'0', [], [], None, ''],
        [u'const CV_HOUGH_PROBABILISTIC', u'1', [], [], None, ''],
        [u'const CV_HOUGH_MULTI_SCALE', u'2', [], [], None, ''],
        [u'const CV_HOUGH_GRADIENT', u'3', [], [], None, '']],
    None]
ok: CONST CV_HOUGH_STANDARD=0
ok: CONST CV_HOUGH_PROBABILISTIC=1
ok: CONST CV_HOUGH_MULTI_SCALE=2
ok: CONST CV_HOUGH_GRADIENT=3


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/hal/interface.h =====
Namespaces: set([''])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/hal/interface.h


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc.hpp =====
Namespaces: set(['', u'cv'])

--- Incoming ---
[   u'enum cv.SpecialFilter',
    '',
    [],
    [[u'const cv.FILTER_SCHARR', u'-1', [], [], None, '']],
    None]
ok: CONST FILTER_SCHARR=-1

--- Incoming ---
[   u'enum cv.MorphTypes',
    '',
    [],
    [   [u'const cv.MORPH_ERODE', u'0', [], [], None, ''],
        [u'const cv.MORPH_DILATE', u'1', [], [], None, ''],
        [u'const cv.MORPH_OPEN', u'2', [], [], None, ''],
        [u'const cv.MORPH_CLOSE', u'3', [], [], None, ''],
        [u'const cv.MORPH_GRADIENT', u'4', [], [], None, ''],
        [u'const cv.MORPH_TOPHAT', u'5', [], [], None, ''],
        [u'const cv.MORPH_BLACKHAT', u'6', [], [], None, ''],
        [u'const cv.MORPH_HITMISS', u'7', [], [], None, '']],
    None]
ok: CONST MORPH_ERODE=0
ok: CONST MORPH_DILATE=1
ok: CONST MORPH_OPEN=2
ok: CONST MORPH_CLOSE=3
ok: CONST MORPH_GRADIENT=4
ok: CONST MORPH_TOPHAT=5
ok: CONST MORPH_BLACKHAT=6
ok: CONST MORPH_HITMISS=7

--- Incoming ---
[   u'enum cv.MorphShapes',
    '',
    [],
    [   [u'const cv.MORPH_RECT', u'0', [], [], None, ''],
        [u'const cv.MORPH_CROSS', u'1', [], [], None, ''],
        [u'const cv.MORPH_ELLIPSE', u'2', [], [], None, '']],
    None]
ok: CONST MORPH_RECT=0
ok: CONST MORPH_CROSS=1
ok: CONST MORPH_ELLIPSE=2

--- Incoming ---
[   u'enum cv.InterpolationFlags',
    '',
    [],
    [   [u'const cv.INTER_NEAREST', u'0', [], [], None, ''],
        [u'const cv.INTER_LINEAR', u'1', [], [], None, ''],
        [u'const cv.INTER_CUBIC', u'2', [], [], None, ''],
        [u'const cv.INTER_AREA', u'3', [], [], None, ''],
        [u'const cv.INTER_LANCZOS4', u'4', [], [], None, ''],
        [u'const cv.INTER_LINEAR_EXACT', u'5', [], [], None, ''],
        [u'const cv.INTER_MAX', u'7', [], [], None, ''],
        [u'const cv.WARP_FILL_OUTLIERS', u'8', [], [], None, ''],
        [u'const cv.WARP_INVERSE_MAP', u'16', [], [], None, '']],
    None]
ok: CONST INTER_NEAREST=0
ok: CONST INTER_LINEAR=1
ok: CONST INTER_CUBIC=2
ok: CONST INTER_AREA=3
ok: CONST INTER_LANCZOS4=4
ok: CONST INTER_LINEAR_EXACT=5
ok: CONST INTER_MAX=7
ok: CONST WARP_FILL_OUTLIERS=8
ok: CONST WARP_INVERSE_MAP=16

--- Incoming ---
[   u'enum cv.WarpPolarMode',
    '',
    [],
    [   [u'const cv.WARP_POLAR_LINEAR', u'0', [], [], None, ''],
        [u'const cv.WARP_POLAR_LOG', u'256', [], [], None, '']],
    None]
ok: CONST WARP_POLAR_LINEAR=0
ok: CONST WARP_POLAR_LOG=256

--- Incoming ---
[   u'enum cv.InterpolationMasks',
    '',
    [],
    [   [u'const cv.INTER_BITS', u'5', [], [], None, ''],
        [u'const cv.INTER_BITS2', u'INTER_BITS * 2', [], [], None, ''],
        [u'const cv.INTER_TAB_SIZE', u'1 << INTER_BITS', [], [], None, ''],
        [   u'const cv.INTER_TAB_SIZE2',
            u'INTER_TAB_SIZE * INTER_TAB_SIZE',
            [],
            [],
            None,
            '']],
    None]
ok: CONST INTER_BITS=5
ok: CONST INTER_BITS2=INTER_BITS * 2
ok: CONST INTER_TAB_SIZE=1 << INTER_BITS
ok: CONST INTER_TAB_SIZE2=INTER_TAB_SIZE * INTER_TAB_SIZE

--- Incoming ---
[   u'enum cv.DistanceTypes',
    '',
    [],
    [   [u'const cv.DIST_USER', u'-1', [], [], None, ''],
        [u'const cv.DIST_L1', u'1', [], [], None, ''],
        [u'const cv.DIST_L2', u'2', [], [], None, ''],
        [u'const cv.DIST_C', u'3', [], [], None, ''],
        [u'const cv.DIST_L12', u'4', [], [], None, ''],
        [u'const cv.DIST_FAIR', u'5', [], [], None, ''],
        [u'const cv.DIST_WELSCH', u'6', [], [], None, ''],
        [u'const cv.DIST_HUBER', u'7', [], [], None, '']],
    None]
ok: CONST DIST_USER=-1
ok: CONST DIST_L1=1
ok: CONST DIST_L2=2
ok: CONST DIST_C=3
ok: CONST DIST_L12=4
ok: CONST DIST_FAIR=5
ok: CONST DIST_WELSCH=6
ok: CONST DIST_HUBER=7

--- Incoming ---
[   u'enum cv.DistanceTransformMasks',
    '',
    [],
    [   [u'const cv.DIST_MASK_3', u'3', [], [], None, ''],
        [u'const cv.DIST_MASK_5', u'5', [], [], None, ''],
        [u'const cv.DIST_MASK_PRECISE', u'0', [], [], None, '']],
    None]
ok: CONST DIST_MASK_3=3
ok: CONST DIST_MASK_5=5
ok: CONST DIST_MASK_PRECISE=0

--- Incoming ---
[   u'enum cv.ThresholdTypes',
    '',
    [],
    [   [u'const cv.THRESH_BINARY', u'0', [], [], None, ''],
        [u'const cv.THRESH_BINARY_INV', u'1', [], [], None, ''],
        [u'const cv.THRESH_TRUNC', u'2', [], [], None, ''],
        [u'const cv.THRESH_TOZERO', u'3', [], [], None, ''],
        [u'const cv.THRESH_TOZERO_INV', u'4', [], [], None, ''],
        [u'const cv.THRESH_MASK', u'7', [], [], None, ''],
        [u'const cv.THRESH_OTSU', u'8', [], [], None, ''],
        [u'const cv.THRESH_TRIANGLE', u'16', [], [], None, '']],
    None]
ok: CONST THRESH_BINARY=0
ok: CONST THRESH_BINARY_INV=1
ok: CONST THRESH_TRUNC=2
ok: CONST THRESH_TOZERO=3
ok: CONST THRESH_TOZERO_INV=4
ok: CONST THRESH_MASK=7
ok: CONST THRESH_OTSU=8
ok: CONST THRESH_TRIANGLE=16

--- Incoming ---
[   u'enum cv.AdaptiveThresholdTypes',
    '',
    [],
    [   [u'const cv.ADAPTIVE_THRESH_MEAN_C', u'0', [], [], None, ''],
        [u'const cv.ADAPTIVE_THRESH_GAUSSIAN_C', u'1', [], [], None, '']],
    None]
ok: CONST ADAPTIVE_THRESH_MEAN_C=0
ok: CONST ADAPTIVE_THRESH_GAUSSIAN_C=1

--- Incoming ---
[   u'enum cv.GrabCutClasses',
    '',
    [],
    [   [u'const cv.GC_BGD', u'0', [], [], None, ''],
        [u'const cv.GC_FGD', u'1', [], [], None, ''],
        [u'const cv.GC_PR_BGD', u'2', [], [], None, ''],
        [u'const cv.GC_PR_FGD', u'3', [], [], None, '']],
    None]
ok: CONST GC_BGD=0
ok: CONST GC_FGD=1
ok: CONST GC_PR_BGD=2
ok: CONST GC_PR_FGD=3

--- Incoming ---
[   u'enum cv.GrabCutModes',
    '',
    [],
    [   [u'const cv.GC_INIT_WITH_RECT', u'0', [], [], None, ''],
        [u'const cv.GC_INIT_WITH_MASK', u'1', [], [], None, ''],
        [u'const cv.GC_EVAL', u'2', [], [], None, ''],
        [u'const cv.GC_EVAL_FREEZE_MODEL', u'3', [], [], None, '']],
    None]
ok: CONST GC_INIT_WITH_RECT=0
ok: CONST GC_INIT_WITH_MASK=1
ok: CONST GC_EVAL=2
ok: CONST GC_EVAL_FREEZE_MODEL=3

--- Incoming ---
[   u'enum cv.DistanceTransformLabelTypes',
    '',
    [],
    [   [u'const cv.DIST_LABEL_CCOMP', u'0', [], [], None, ''],
        [u'const cv.DIST_LABEL_PIXEL', u'1', [], [], None, '']],
    None]
ok: CONST DIST_LABEL_CCOMP=0
ok: CONST DIST_LABEL_PIXEL=1

--- Incoming ---
[   u'enum cv.FloodFillFlags',
    '',
    [],
    [   [u'const cv.FLOODFILL_FIXED_RANGE', u'1 << 16', [], [], None, ''],
        [u'const cv.FLOODFILL_MASK_ONLY', u'1 << 17', [], [], None, '']],
    None]
ok: CONST FLOODFILL_FIXED_RANGE=1 << 16
ok: CONST FLOODFILL_MASK_ONLY=1 << 17

--- Incoming ---
[   u'enum cv.ConnectedComponentsTypes',
    '',
    [],
    [   [u'const cv.CC_STAT_LEFT', u'0', [], [], None, ''],
        [u'const cv.CC_STAT_TOP', u'1', [], [], None, ''],
        [u'const cv.CC_STAT_WIDTH', u'2', [], [], None, ''],
        [u'const cv.CC_STAT_HEIGHT', u'3', [], [], None, ''],
        [u'const cv.CC_STAT_AREA', u'4', [], [], None, ''],
        [u'const cv.CC_STAT_MAX', u'5', [], [], None, '']],
    None]
ok: CONST CC_STAT_LEFT=0
ok: CONST CC_STAT_TOP=1
ok: CONST CC_STAT_WIDTH=2
ok: CONST CC_STAT_HEIGHT=3
ok: CONST CC_STAT_AREA=4
ok: CONST CC_STAT_MAX=5

--- Incoming ---
[   u'enum cv.ConnectedComponentsAlgorithmsTypes',
    '',
    [],
    [   [u'const cv.CCL_WU', u'0', [], [], None, ''],
        [u'const cv.CCL_DEFAULT', u'-1', [], [], None, ''],
        [u'const cv.CCL_GRANA', u'1', [], [], None, '']],
    None]
ok: CONST CCL_WU=0
ok: CONST CCL_DEFAULT=-1
ok: CONST CCL_GRANA=1

--- Incoming ---
[   u'enum cv.RetrievalModes',
    '',
    [],
    [   [u'const cv.RETR_EXTERNAL', u'0', [], [], None, ''],
        [u'const cv.RETR_LIST', u'1', [], [], None, ''],
        [u'const cv.RETR_CCOMP', u'2', [], [], None, ''],
        [u'const cv.RETR_TREE', u'3', [], [], None, ''],
        [u'const cv.RETR_FLOODFILL', u'4', [], [], None, '']],
    None]
ok: CONST RETR_EXTERNAL=0
ok: CONST RETR_LIST=1
ok: CONST RETR_CCOMP=2
ok: CONST RETR_TREE=3
ok: CONST RETR_FLOODFILL=4

--- Incoming ---
[   u'enum cv.ContourApproximationModes',
    '',
    [],
    [   [u'const cv.CHAIN_APPROX_NONE', u'1', [], [], None, ''],
        [u'const cv.CHAIN_APPROX_SIMPLE', u'2', [], [], None, ''],
        [u'const cv.CHAIN_APPROX_TC89_L1', u'3', [], [], None, ''],
        [u'const cv.CHAIN_APPROX_TC89_KCOS', u'4', [], [], None, '']],
    None]
ok: CONST CHAIN_APPROX_NONE=1
ok: CONST CHAIN_APPROX_SIMPLE=2
ok: CONST CHAIN_APPROX_TC89_L1=3
ok: CONST CHAIN_APPROX_TC89_KCOS=4

--- Incoming ---
[   u'enum cv.ShapeMatchModes',
    '',
    [],
    [   [u'const cv.CONTOURS_MATCH_I1', u'1', [], [], None, ''],
        [u'const cv.CONTOURS_MATCH_I2', u'2', [], [], None, ''],
        [u'const cv.CONTOURS_MATCH_I3', u'3', [], [], None, '']],
    None]
ok: CONST CONTOURS_MATCH_I1=1
ok: CONST CONTOURS_MATCH_I2=2
ok: CONST CONTOURS_MATCH_I3=3

--- Incoming ---
[   u'enum cv.HoughModes',
    '',
    [],
    [   [u'const cv.HOUGH_STANDARD', u'0', [], [], None, ''],
        [u'const cv.HOUGH_PROBABILISTIC', u'1', [], [], None, ''],
        [u'const cv.HOUGH_MULTI_SCALE', u'2', [], [], None, ''],
        [u'const cv.HOUGH_GRADIENT', u'3', [], [], None, ''],
        [u'const cv.HOUGH_GRADIENT_ALT', u'4', [], [], None, '']],
    None]
ok: CONST HOUGH_STANDARD=0
ok: CONST HOUGH_PROBABILISTIC=1
ok: CONST HOUGH_MULTI_SCALE=2
ok: CONST HOUGH_GRADIENT=3
ok: CONST HOUGH_GRADIENT_ALT=4

--- Incoming ---
[   u'enum cv.LineSegmentDetectorModes',
    '',
    [],
    [   [u'const cv.LSD_REFINE_NONE', u'0', [], [], None, ''],
        [u'const cv.LSD_REFINE_STD', u'1', [], [], None, ''],
        [u'const cv.LSD_REFINE_ADV', u'2', [], [], None, '']],
    None]
ok: CONST LSD_REFINE_NONE=0
ok: CONST LSD_REFINE_STD=1
ok: CONST LSD_REFINE_ADV=2

--- Incoming ---
[   u'enum cv.HistCompMethods',
    '',
    [],
    [   [u'const cv.HISTCMP_CORREL', u'0', [], [], None, ''],
        [u'const cv.HISTCMP_CHISQR', u'1', [], [], None, ''],
        [u'const cv.HISTCMP_INTERSECT', u'2', [], [], None, ''],
        [u'const cv.HISTCMP_BHATTACHARYYA', u'3', [], [], None, ''],
        [   u'const cv.HISTCMP_HELLINGER',
            u'HISTCMP_BHATTACHARYYA',
            [],
            [],
            None,
            ''],
        [u'const cv.HISTCMP_CHISQR_ALT', u'4', [], [], None, ''],
        [u'const cv.HISTCMP_KL_DIV', u'5', [], [], None, '']],
    None]
ok: CONST HISTCMP_CORREL=0
ok: CONST HISTCMP_CHISQR=1
ok: CONST HISTCMP_INTERSECT=2
ok: CONST HISTCMP_BHATTACHARYYA=3
ok: CONST HISTCMP_HELLINGER=HISTCMP_BHATTACHARYYA
ok: CONST HISTCMP_CHISQR_ALT=4
ok: CONST HISTCMP_KL_DIV=5

--- Incoming ---
[   u'enum cv.ColorConversionCodes',
    '',
    [],
    [   [u'const cv.COLOR_BGR2BGRA', u'0', [], [], None, ''],
        [u'const cv.COLOR_RGB2RGBA', u'COLOR_BGR2BGRA', [], [], None, ''],
        [u'const cv.COLOR_BGRA2BGR', u'1', [], [], None, ''],
        [u'const cv.COLOR_RGBA2RGB', u'COLOR_BGRA2BGR', [], [], None, ''],
        [u'const cv.COLOR_BGR2RGBA', u'2', [], [], None, ''],
        [u'const cv.COLOR_RGB2BGRA', u'COLOR_BGR2RGBA', [], [], None, ''],
        [u'const cv.COLOR_RGBA2BGR', u'3', [], [], None, ''],
        [u'const cv.COLOR_BGRA2RGB', u'COLOR_RGBA2BGR', [], [], None, ''],
        [u'const cv.COLOR_BGR2RGB', u'4', [], [], None, ''],
        [u'const cv.COLOR_RGB2BGR', u'COLOR_BGR2RGB', [], [], None, ''],
        [u'const cv.COLOR_BGRA2RGBA', u'5', [], [], None, ''],
        [u'const cv.COLOR_RGBA2BGRA', u'COLOR_BGRA2RGBA', [], [], None, ''],
        [u'const cv.COLOR_BGR2GRAY', u'6', [], [], None, ''],
        [u'const cv.COLOR_RGB2GRAY', u'7', [], [], None, ''],
        [u'const cv.COLOR_GRAY2BGR', u'8', [], [], None, ''],
        [u'const cv.COLOR_GRAY2RGB', u'COLOR_GRAY2BGR', [], [], None, ''],
        [u'const cv.COLOR_GRAY2BGRA', u'9', [], [], None, ''],
        [u'const cv.COLOR_GRAY2RGBA', u'COLOR_GRAY2BGRA', [], [], None, ''],
        [u'const cv.COLOR_BGRA2GRAY', u'10', [], [], None, ''],
        [u'const cv.COLOR_RGBA2GRAY', u'11', [], [], None, ''],
        [u'const cv.COLOR_BGR2BGR565', u'12', [], [], None, ''],
        [u'const cv.COLOR_RGB2BGR565', u'13', [], [], None, ''],
        [u'const cv.COLOR_BGR5652BGR', u'14', [], [], None, ''],
        [u'const cv.COLOR_BGR5652RGB', u'15', [], [], None, ''],
        [u'const cv.COLOR_BGRA2BGR565', u'16', [], [], None, ''],
        [u'const cv.COLOR_RGBA2BGR565', u'17', [], [], None, ''],
        [u'const cv.COLOR_BGR5652BGRA', u'18', [], [], None, ''],
        [u'const cv.COLOR_BGR5652RGBA', u'19', [], [], None, ''],
        [u'const cv.COLOR_GRAY2BGR565', u'20', [], [], None, ''],
        [u'const cv.COLOR_BGR5652GRAY', u'21', [], [], None, ''],
        [u'const cv.COLOR_BGR2BGR555', u'22', [], [], None, ''],
        [u'const cv.COLOR_RGB2BGR555', u'23', [], [], None, ''],
        [u'const cv.COLOR_BGR5552BGR', u'24', [], [], None, ''],
        [u'const cv.COLOR_BGR5552RGB', u'25', [], [], None, ''],
        [u'const cv.COLOR_BGRA2BGR555', u'26', [], [], None, ''],
        [u'const cv.COLOR_RGBA2BGR555', u'27', [], [], None, ''],
        [u'const cv.COLOR_BGR5552BGRA', u'28', [], [], None, ''],
        [u'const cv.COLOR_BGR5552RGBA', u'29', [], [], None, ''],
        [u'const cv.COLOR_GRAY2BGR555', u'30', [], [], None, ''],
        [u'const cv.COLOR_BGR5552GRAY', u'31', [], [], None, ''],
        [u'const cv.COLOR_BGR2XYZ', u'32', [], [], None, ''],
        [u'const cv.COLOR_RGB2XYZ', u'33', [], [], None, ''],
        [u'const cv.COLOR_XYZ2BGR', u'34', [], [], None, ''],
        [u'const cv.COLOR_XYZ2RGB', u'35', [], [], None, ''],
        [u'const cv.COLOR_BGR2YCrCb', u'36', [], [], None, ''],
        [u'const cv.COLOR_RGB2YCrCb', u'37', [], [], None, ''],
        [u'const cv.COLOR_YCrCb2BGR', u'38', [], [], None, ''],
        [u'const cv.COLOR_YCrCb2RGB', u'39', [], [], None, ''],
        [u'const cv.COLOR_BGR2HSV', u'40', [], [], None, ''],
        [u'const cv.COLOR_RGB2HSV', u'41', [], [], None, ''],
        [u'const cv.COLOR_BGR2Lab', u'44', [], [], None, ''],
        [u'const cv.COLOR_RGB2Lab', u'45', [], [], None, ''],
        [u'const cv.COLOR_BGR2Luv', u'50', [], [], None, ''],
        [u'const cv.COLOR_RGB2Luv', u'51', [], [], None, ''],
        [u'const cv.COLOR_BGR2HLS', u'52', [], [], None, ''],
        [u'const cv.COLOR_RGB2HLS', u'53', [], [], None, ''],
        [u'const cv.COLOR_HSV2BGR', u'54', [], [], None, ''],
        [u'const cv.COLOR_HSV2RGB', u'55', [], [], None, ''],
        [u'const cv.COLOR_Lab2BGR', u'56', [], [], None, ''],
        [u'const cv.COLOR_Lab2RGB', u'57', [], [], None, ''],
        [u'const cv.COLOR_Luv2BGR', u'58', [], [], None, ''],
        [u'const cv.COLOR_Luv2RGB', u'59', [], [], None, ''],
        [u'const cv.COLOR_HLS2BGR', u'60', [], [], None, ''],
        [u'const cv.COLOR_HLS2RGB', u'61', [], [], None, ''],
        [u'const cv.COLOR_BGR2HSV_FULL', u'66', [], [], None, ''],
        [u'const cv.COLOR_RGB2HSV_FULL', u'67', [], [], None, ''],
        [u'const cv.COLOR_BGR2HLS_FULL', u'68', [], [], None, ''],
        [u'const cv.COLOR_RGB2HLS_FULL', u'69', [], [], None, ''],
        [u'const cv.COLOR_HSV2BGR_FULL', u'70', [], [], None, ''],
        [u'const cv.COLOR_HSV2RGB_FULL', u'71', [], [], None, ''],
        [u'const cv.COLOR_HLS2BGR_FULL', u'72', [], [], None, ''],
        [u'const cv.COLOR_HLS2RGB_FULL', u'73', [], [], None, ''],
        [u'const cv.COLOR_LBGR2Lab', u'74', [], [], None, ''],
        [u'const cv.COLOR_LRGB2Lab', u'75', [], [], None, ''],
        [u'const cv.COLOR_LBGR2Luv', u'76', [], [], None, ''],
        [u'const cv.COLOR_LRGB2Luv', u'77', [], [], None, ''],
        [u'const cv.COLOR_Lab2LBGR', u'78', [], [], None, ''],
        [u'const cv.COLOR_Lab2LRGB', u'79', [], [], None, ''],
        [u'const cv.COLOR_Luv2LBGR', u'80', [], [], None, ''],
        [u'const cv.COLOR_Luv2LRGB', u'81', [], [], None, ''],
        [u'const cv.COLOR_BGR2YUV', u'82', [], [], None, ''],
        [u'const cv.COLOR_RGB2YUV', u'83', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR', u'84', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGB', u'85', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGB_NV12', u'90', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_NV12', u'91', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGB_NV21', u'92', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_NV21', u'93', [], [], None, ''],
        [   u'const cv.COLOR_YUV420sp2RGB',
            u'COLOR_YUV2RGB_NV21',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420sp2BGR',
            u'COLOR_YUV2BGR_NV21',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGBA_NV12', u'94', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_NV12', u'95', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGBA_NV21', u'96', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_NV21', u'97', [], [], None, ''],
        [   u'const cv.COLOR_YUV420sp2RGBA',
            u'COLOR_YUV2RGBA_NV21',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420sp2BGRA',
            u'COLOR_YUV2BGRA_NV21',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGB_YV12', u'98', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_YV12', u'99', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGB_IYUV', u'100', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_IYUV', u'101', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGB_I420',
            u'COLOR_YUV2RGB_IYUV',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGR_I420',
            u'COLOR_YUV2BGR_IYUV',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420p2RGB',
            u'COLOR_YUV2RGB_YV12',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420p2BGR',
            u'COLOR_YUV2BGR_YV12',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGBA_YV12', u'102', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_YV12', u'103', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGBA_IYUV', u'104', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_IYUV', u'105', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGBA_I420',
            u'COLOR_YUV2RGBA_IYUV',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGRA_I420',
            u'COLOR_YUV2BGRA_IYUV',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420p2RGBA',
            u'COLOR_YUV2RGBA_YV12',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420p2BGRA',
            u'COLOR_YUV2BGRA_YV12',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2GRAY_420', u'106', [], [], None, ''],
        [   u'const cv.COLOR_YUV2GRAY_NV21',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_NV12',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_YV12',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_IYUV',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_I420',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420sp2GRAY',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV420p2GRAY',
            u'COLOR_YUV2GRAY_420',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGB_UYVY', u'107', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_UYVY', u'108', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGB_Y422',
            u'COLOR_YUV2RGB_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGR_Y422',
            u'COLOR_YUV2BGR_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2RGB_UYNV',
            u'COLOR_YUV2RGB_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGR_UYNV',
            u'COLOR_YUV2BGR_UYVY',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGBA_UYVY', u'111', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_UYVY', u'112', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGBA_Y422',
            u'COLOR_YUV2RGBA_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGRA_Y422',
            u'COLOR_YUV2BGRA_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2RGBA_UYNV',
            u'COLOR_YUV2RGBA_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGRA_UYNV',
            u'COLOR_YUV2BGRA_UYVY',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGB_YUY2', u'115', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_YUY2', u'116', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGB_YVYU', u'117', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGR_YVYU', u'118', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGB_YUYV',
            u'COLOR_YUV2RGB_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGR_YUYV',
            u'COLOR_YUV2BGR_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2RGB_YUNV',
            u'COLOR_YUV2RGB_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGR_YUNV',
            u'COLOR_YUV2BGR_YUY2',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2RGBA_YUY2', u'119', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_YUY2', u'120', [], [], None, ''],
        [u'const cv.COLOR_YUV2RGBA_YVYU', u'121', [], [], None, ''],
        [u'const cv.COLOR_YUV2BGRA_YVYU', u'122', [], [], None, ''],
        [   u'const cv.COLOR_YUV2RGBA_YUYV',
            u'COLOR_YUV2RGBA_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGRA_YUYV',
            u'COLOR_YUV2BGRA_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2RGBA_YUNV',
            u'COLOR_YUV2RGBA_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2BGRA_YUNV',
            u'COLOR_YUV2BGRA_YUY2',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_YUV2GRAY_UYVY', u'123', [], [], None, ''],
        [u'const cv.COLOR_YUV2GRAY_YUY2', u'124', [], [], None, ''],
        [   u'const cv.COLOR_YUV2GRAY_Y422',
            u'COLOR_YUV2GRAY_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_UYNV',
            u'COLOR_YUV2GRAY_UYVY',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_YVYU',
            u'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_YUYV',
            u'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_YUV2GRAY_YUNV',
            u'COLOR_YUV2GRAY_YUY2',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_RGBA2mRGBA', u'125', [], [], None, ''],
        [u'const cv.COLOR_mRGBA2RGBA', u'126', [], [], None, ''],
        [u'const cv.COLOR_RGB2YUV_I420', u'127', [], [], None, ''],
        [u'const cv.COLOR_BGR2YUV_I420', u'128', [], [], None, ''],
        [   u'const cv.COLOR_RGB2YUV_IYUV',
            u'COLOR_RGB2YUV_I420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BGR2YUV_IYUV',
            u'COLOR_BGR2YUV_I420',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_RGBA2YUV_I420', u'129', [], [], None, ''],
        [u'const cv.COLOR_BGRA2YUV_I420', u'130', [], [], None, ''],
        [   u'const cv.COLOR_RGBA2YUV_IYUV',
            u'COLOR_RGBA2YUV_I420',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BGRA2YUV_IYUV',
            u'COLOR_BGRA2YUV_I420',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_RGB2YUV_YV12', u'131', [], [], None, ''],
        [u'const cv.COLOR_BGR2YUV_YV12', u'132', [], [], None, ''],
        [u'const cv.COLOR_RGBA2YUV_YV12', u'133', [], [], None, ''],
        [u'const cv.COLOR_BGRA2YUV_YV12', u'134', [], [], None, ''],
        [u'const cv.COLOR_BayerBG2BGR', u'46', [], [], None, ''],
        [u'const cv.COLOR_BayerGB2BGR', u'47', [], [], None, ''],
        [u'const cv.COLOR_BayerRG2BGR', u'48', [], [], None, ''],
        [u'const cv.COLOR_BayerGR2BGR', u'49', [], [], None, ''],
        [   u'const cv.COLOR_BayerBG2RGB',
            u'COLOR_BayerRG2BGR',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGB2RGB',
            u'COLOR_BayerGR2BGR',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerRG2RGB',
            u'COLOR_BayerBG2BGR',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGR2RGB',
            u'COLOR_BayerGB2BGR',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_BayerBG2GRAY', u'86', [], [], None, ''],
        [u'const cv.COLOR_BayerGB2GRAY', u'87', [], [], None, ''],
        [u'const cv.COLOR_BayerRG2GRAY', u'88', [], [], None, ''],
        [u'const cv.COLOR_BayerGR2GRAY', u'89', [], [], None, ''],
        [u'const cv.COLOR_BayerBG2BGR_VNG', u'62', [], [], None, ''],
        [u'const cv.COLOR_BayerGB2BGR_VNG', u'63', [], [], None, ''],
        [u'const cv.COLOR_BayerRG2BGR_VNG', u'64', [], [], None, ''],
        [u'const cv.COLOR_BayerGR2BGR_VNG', u'65', [], [], None, ''],
        [   u'const cv.COLOR_BayerBG2RGB_VNG',
            u'COLOR_BayerRG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGB2RGB_VNG',
            u'COLOR_BayerGR2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerRG2RGB_VNG',
            u'COLOR_BayerBG2BGR_VNG',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGR2RGB_VNG',
            u'COLOR_BayerGB2BGR_VNG',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_BayerBG2BGR_EA', u'135', [], [], None, ''],
        [u'const cv.COLOR_BayerGB2BGR_EA', u'136', [], [], None, ''],
        [u'const cv.COLOR_BayerRG2BGR_EA', u'137', [], [], None, ''],
        [u'const cv.COLOR_BayerGR2BGR_EA', u'138', [], [], None, ''],
        [   u'const cv.COLOR_BayerBG2RGB_EA',
            u'COLOR_BayerRG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGB2RGB_EA',
            u'COLOR_BayerGR2BGR_EA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerRG2RGB_EA',
            u'COLOR_BayerBG2BGR_EA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGR2RGB_EA',
            u'COLOR_BayerGB2BGR_EA',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_BayerBG2BGRA', u'139', [], [], None, ''],
        [u'const cv.COLOR_BayerGB2BGRA', u'140', [], [], None, ''],
        [u'const cv.COLOR_BayerRG2BGRA', u'141', [], [], None, ''],
        [u'const cv.COLOR_BayerGR2BGRA', u'142', [], [], None, ''],
        [   u'const cv.COLOR_BayerBG2RGBA',
            u'COLOR_BayerRG2BGRA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGB2RGBA',
            u'COLOR_BayerGR2BGRA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerRG2RGBA',
            u'COLOR_BayerBG2BGRA',
            [],
            [],
            None,
            ''],
        [   u'const cv.COLOR_BayerGR2RGBA',
            u'COLOR_BayerGB2BGRA',
            [],
            [],
            None,
            ''],
        [u'const cv.COLOR_COLORCVT_MAX', u'143', [], [], None, '']],
    None]
ok: CONST COLOR_BGR2BGRA=0
ok: CONST COLOR_RGB2RGBA=COLOR_BGR2BGRA
ok: CONST COLOR_BGRA2BGR=1
ok: CONST COLOR_RGBA2RGB=COLOR_BGRA2BGR
ok: CONST COLOR_BGR2RGBA=2
ok: CONST COLOR_RGB2BGRA=COLOR_BGR2RGBA
ok: CONST COLOR_RGBA2BGR=3
ok: CONST COLOR_BGRA2RGB=COLOR_RGBA2BGR
ok: CONST COLOR_BGR2RGB=4
ok: CONST COLOR_RGB2BGR=COLOR_BGR2RGB
ok: CONST COLOR_BGRA2RGBA=5
ok: CONST COLOR_RGBA2BGRA=COLOR_BGRA2RGBA
ok: CONST COLOR_BGR2GRAY=6
ok: CONST COLOR_RGB2GRAY=7
ok: CONST COLOR_GRAY2BGR=8
ok: CONST COLOR_GRAY2RGB=COLOR_GRAY2BGR
ok: CONST COLOR_GRAY2BGRA=9
ok: CONST COLOR_GRAY2RGBA=COLOR_GRAY2BGRA
ok: CONST COLOR_BGRA2GRAY=10
ok: CONST COLOR_RGBA2GRAY=11
ok: CONST COLOR_BGR2BGR565=12
ok: CONST COLOR_RGB2BGR565=13
ok: CONST COLOR_BGR5652BGR=14
ok: CONST COLOR_BGR5652RGB=15
ok: CONST COLOR_BGRA2BGR565=16
ok: CONST COLOR_RGBA2BGR565=17
ok: CONST COLOR_BGR5652BGRA=18
ok: CONST COLOR_BGR5652RGBA=19
ok: CONST COLOR_GRAY2BGR565=20
ok: CONST COLOR_BGR5652GRAY=21
ok: CONST COLOR_BGR2BGR555=22
ok: CONST COLOR_RGB2BGR555=23
ok: CONST COLOR_BGR5552BGR=24
ok: CONST COLOR_BGR5552RGB=25
ok: CONST COLOR_BGRA2BGR555=26
ok: CONST COLOR_RGBA2BGR555=27
ok: CONST COLOR_BGR5552BGRA=28
ok: CONST COLOR_BGR5552RGBA=29
ok: CONST COLOR_GRAY2BGR555=30
ok: CONST COLOR_BGR5552GRAY=31
ok: CONST COLOR_BGR2XYZ=32
ok: CONST COLOR_RGB2XYZ=33
ok: CONST COLOR_XYZ2BGR=34
ok: CONST COLOR_XYZ2RGB=35
ok: CONST COLOR_BGR2YCrCb=36
ok: CONST COLOR_RGB2YCrCb=37
ok: CONST COLOR_YCrCb2BGR=38
ok: CONST COLOR_YCrCb2RGB=39
ok: CONST COLOR_BGR2HSV=40
ok: CONST COLOR_RGB2HSV=41
ok: CONST COLOR_BGR2Lab=44
ok: CONST COLOR_RGB2Lab=45
ok: CONST COLOR_BGR2Luv=50
ok: CONST COLOR_RGB2Luv=51
ok: CONST COLOR_BGR2HLS=52
ok: CONST COLOR_RGB2HLS=53
ok: CONST COLOR_HSV2BGR=54
ok: CONST COLOR_HSV2RGB=55
ok: CONST COLOR_Lab2BGR=56
ok: CONST COLOR_Lab2RGB=57
ok: CONST COLOR_Luv2BGR=58
ok: CONST COLOR_Luv2RGB=59
ok: CONST COLOR_HLS2BGR=60
ok: CONST COLOR_HLS2RGB=61
ok: CONST COLOR_BGR2HSV_FULL=66
ok: CONST COLOR_RGB2HSV_FULL=67
ok: CONST COLOR_BGR2HLS_FULL=68
ok: CONST COLOR_RGB2HLS_FULL=69
ok: CONST COLOR_HSV2BGR_FULL=70
ok: CONST COLOR_HSV2RGB_FULL=71
ok: CONST COLOR_HLS2BGR_FULL=72
ok: CONST COLOR_HLS2RGB_FULL=73
ok: CONST COLOR_LBGR2Lab=74
ok: CONST COLOR_LRGB2Lab=75
ok: CONST COLOR_LBGR2Luv=76
ok: CONST COLOR_LRGB2Luv=77
ok: CONST COLOR_Lab2LBGR=78
ok: CONST COLOR_Lab2LRGB=79
ok: CONST COLOR_Luv2LBGR=80
ok: CONST COLOR_Luv2LRGB=81
ok: CONST COLOR_BGR2YUV=82
ok: CONST COLOR_RGB2YUV=83
ok: CONST COLOR_YUV2BGR=84
ok: CONST COLOR_YUV2RGB=85
ok: CONST COLOR_YUV2RGB_NV12=90
ok: CONST COLOR_YUV2BGR_NV12=91
ok: CONST COLOR_YUV2RGB_NV21=92
ok: CONST COLOR_YUV2BGR_NV21=93
ok: CONST COLOR_YUV420sp2RGB=COLOR_YUV2RGB_NV21
ok: CONST COLOR_YUV420sp2BGR=COLOR_YUV2BGR_NV21
ok: CONST COLOR_YUV2RGBA_NV12=94
ok: CONST COLOR_YUV2BGRA_NV12=95
ok: CONST COLOR_YUV2RGBA_NV21=96
ok: CONST COLOR_YUV2BGRA_NV21=97
ok: CONST COLOR_YUV420sp2RGBA=COLOR_YUV2RGBA_NV21
ok: CONST COLOR_YUV420sp2BGRA=COLOR_YUV2BGRA_NV21
ok: CONST COLOR_YUV2RGB_YV12=98
ok: CONST COLOR_YUV2BGR_YV12=99
ok: CONST COLOR_YUV2RGB_IYUV=100
ok: CONST COLOR_YUV2BGR_IYUV=101
ok: CONST COLOR_YUV2RGB_I420=COLOR_YUV2RGB_IYUV
ok: CONST COLOR_YUV2BGR_I420=COLOR_YUV2BGR_IYUV
ok: CONST COLOR_YUV420p2RGB=COLOR_YUV2RGB_YV12
ok: CONST COLOR_YUV420p2BGR=COLOR_YUV2BGR_YV12
ok: CONST COLOR_YUV2RGBA_YV12=102
ok: CONST COLOR_YUV2BGRA_YV12=103
ok: CONST COLOR_YUV2RGBA_IYUV=104
ok: CONST COLOR_YUV2BGRA_IYUV=105
ok: CONST COLOR_YUV2RGBA_I420=COLOR_YUV2RGBA_IYUV
ok: CONST COLOR_YUV2BGRA_I420=COLOR_YUV2BGRA_IYUV
ok: CONST COLOR_YUV420p2RGBA=COLOR_YUV2RGBA_YV12
ok: CONST COLOR_YUV420p2BGRA=COLOR_YUV2BGRA_YV12
ok: CONST COLOR_YUV2GRAY_420=106
ok: CONST COLOR_YUV2GRAY_NV21=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_NV12=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_YV12=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_IYUV=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2GRAY_I420=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV420sp2GRAY=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV420p2GRAY=COLOR_YUV2GRAY_420
ok: CONST COLOR_YUV2RGB_UYVY=107
ok: CONST COLOR_YUV2BGR_UYVY=108
ok: CONST COLOR_YUV2RGB_Y422=COLOR_YUV2RGB_UYVY
ok: CONST COLOR_YUV2BGR_Y422=COLOR_YUV2BGR_UYVY
ok: CONST COLOR_YUV2RGB_UYNV=COLOR_YUV2RGB_UYVY
ok: CONST COLOR_YUV2BGR_UYNV=COLOR_YUV2BGR_UYVY
ok: CONST COLOR_YUV2RGBA_UYVY=111
ok: CONST COLOR_YUV2BGRA_UYVY=112
ok: CONST COLOR_YUV2RGBA_Y422=COLOR_YUV2RGBA_UYVY
ok: CONST COLOR_YUV2BGRA_Y422=COLOR_YUV2BGRA_UYVY
ok: CONST COLOR_YUV2RGBA_UYNV=COLOR_YUV2RGBA_UYVY
ok: CONST COLOR_YUV2BGRA_UYNV=COLOR_YUV2BGRA_UYVY
ok: CONST COLOR_YUV2RGB_YUY2=115
ok: CONST COLOR_YUV2BGR_YUY2=116
ok: CONST COLOR_YUV2RGB_YVYU=117
ok: CONST COLOR_YUV2BGR_YVYU=118
ok: CONST COLOR_YUV2RGB_YUYV=COLOR_YUV2RGB_YUY2
ok: CONST COLOR_YUV2BGR_YUYV=COLOR_YUV2BGR_YUY2
ok: CONST COLOR_YUV2RGB_YUNV=COLOR_YUV2RGB_YUY2
ok: CONST COLOR_YUV2BGR_YUNV=COLOR_YUV2BGR_YUY2
ok: CONST COLOR_YUV2RGBA_YUY2=119
ok: CONST COLOR_YUV2BGRA_YUY2=120
ok: CONST COLOR_YUV2RGBA_YVYU=121
ok: CONST COLOR_YUV2BGRA_YVYU=122
ok: CONST COLOR_YUV2RGBA_YUYV=COLOR_YUV2RGBA_YUY2
ok: CONST COLOR_YUV2BGRA_YUYV=COLOR_YUV2BGRA_YUY2
ok: CONST COLOR_YUV2RGBA_YUNV=COLOR_YUV2RGBA_YUY2
ok: CONST COLOR_YUV2BGRA_YUNV=COLOR_YUV2BGRA_YUY2
ok: CONST COLOR_YUV2GRAY_UYVY=123
ok: CONST COLOR_YUV2GRAY_YUY2=124
ok: CONST COLOR_YUV2GRAY_Y422=COLOR_YUV2GRAY_UYVY
ok: CONST COLOR_YUV2GRAY_UYNV=COLOR_YUV2GRAY_UYVY
ok: CONST COLOR_YUV2GRAY_YVYU=COLOR_YUV2GRAY_YUY2
ok: CONST COLOR_YUV2GRAY_YUYV=COLOR_YUV2GRAY_YUY2
ok: CONST COLOR_YUV2GRAY_YUNV=COLOR_YUV2GRAY_YUY2
ok: CONST COLOR_RGBA2mRGBA=125
ok: CONST COLOR_mRGBA2RGBA=126
ok: CONST COLOR_RGB2YUV_I420=127
ok: CONST COLOR_BGR2YUV_I420=128
ok: CONST COLOR_RGB2YUV_IYUV=COLOR_RGB2YUV_I420
ok: CONST COLOR_BGR2YUV_IYUV=COLOR_BGR2YUV_I420
ok: CONST COLOR_RGBA2YUV_I420=129
ok: CONST COLOR_BGRA2YUV_I420=130
ok: CONST COLOR_RGBA2YUV_IYUV=COLOR_RGBA2YUV_I420
ok: CONST COLOR_BGRA2YUV_IYUV=COLOR_BGRA2YUV_I420
ok: CONST COLOR_RGB2YUV_YV12=131
ok: CONST COLOR_BGR2YUV_YV12=132
ok: CONST COLOR_RGBA2YUV_YV12=133
ok: CONST COLOR_BGRA2YUV_YV12=134
ok: CONST COLOR_BayerBG2BGR=46
ok: CONST COLOR_BayerGB2BGR=47
ok: CONST COLOR_BayerRG2BGR=48
ok: CONST COLOR_BayerGR2BGR=49
ok: CONST COLOR_BayerBG2RGB=COLOR_BayerRG2BGR
ok: CONST COLOR_BayerGB2RGB=COLOR_BayerGR2BGR
ok: CONST COLOR_BayerRG2RGB=COLOR_BayerBG2BGR
ok: CONST COLOR_BayerGR2RGB=COLOR_BayerGB2BGR
ok: CONST COLOR_BayerBG2GRAY=86
ok: CONST COLOR_BayerGB2GRAY=87
ok: CONST COLOR_BayerRG2GRAY=88
ok: CONST COLOR_BayerGR2GRAY=89
ok: CONST COLOR_BayerBG2BGR_VNG=62
ok: CONST COLOR_BayerGB2BGR_VNG=63
ok: CONST COLOR_BayerRG2BGR_VNG=64
ok: CONST COLOR_BayerGR2BGR_VNG=65
ok: CONST COLOR_BayerBG2RGB_VNG=COLOR_BayerRG2BGR_VNG
ok: CONST COLOR_BayerGB2RGB_VNG=COLOR_BayerGR2BGR_VNG
ok: CONST COLOR_BayerRG2RGB_VNG=COLOR_BayerBG2BGR_VNG
ok: CONST COLOR_BayerGR2RGB_VNG=COLOR_BayerGB2BGR_VNG
ok: CONST COLOR_BayerBG2BGR_EA=135
ok: CONST COLOR_BayerGB2BGR_EA=136
ok: CONST COLOR_BayerRG2BGR_EA=137
ok: CONST COLOR_BayerGR2BGR_EA=138
ok: CONST COLOR_BayerBG2RGB_EA=COLOR_BayerRG2BGR_EA
ok: CONST COLOR_BayerGB2RGB_EA=COLOR_BayerGR2BGR_EA
ok: CONST COLOR_BayerRG2RGB_EA=COLOR_BayerBG2BGR_EA
ok: CONST COLOR_BayerGR2RGB_EA=COLOR_BayerGB2BGR_EA
ok: CONST COLOR_BayerBG2BGRA=139
ok: CONST COLOR_BayerGB2BGRA=140
ok: CONST COLOR_BayerRG2BGRA=141
ok: CONST COLOR_BayerGR2BGRA=142
ok: CONST COLOR_BayerBG2RGBA=COLOR_BayerRG2BGRA
ok: CONST COLOR_BayerGB2RGBA=COLOR_BayerGR2BGRA
ok: CONST COLOR_BayerRG2RGBA=COLOR_BayerBG2BGRA
ok: CONST COLOR_BayerGR2RGBA=COLOR_BayerGB2BGRA
ok: CONST COLOR_COLORCVT_MAX=143

--- Incoming ---
[   u'enum cv.RectanglesIntersectTypes',
    '',
    [],
    [   [u'const cv.INTERSECT_NONE', u'0', [], [], None, ''],
        [u'const cv.INTERSECT_PARTIAL', u'1', [], [], None, ''],
        [u'const cv.INTERSECT_FULL', u'2', [], [], None, '']],
    None]
ok: CONST INTERSECT_NONE=0
ok: CONST INTERSECT_PARTIAL=1
ok: CONST INTERSECT_FULL=2

--- Incoming ---
[   u'enum cv.LineTypes',
    '',
    [],
    [   [u'const cv.FILLED', u'-1', [], [], None, ''],
        [u'const cv.LINE_4', u'4', [], [], None, ''],
        [u'const cv.LINE_8', u'8', [], [], None, ''],
        [u'const cv.LINE_AA', u'16', [], [], None, '']],
    None]
ok: CONST FILLED=-1
ok: CONST LINE_4=4
ok: CONST LINE_8=8
ok: CONST LINE_AA=16

--- Incoming ---
[   u'enum cv.HersheyFonts',
    '',
    [],
    [   [u'const cv.FONT_HERSHEY_SIMPLEX', u'0', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_PLAIN', u'1', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_DUPLEX', u'2', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_COMPLEX', u'3', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_TRIPLEX', u'4', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_COMPLEX_SMALL', u'5', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_SCRIPT_SIMPLEX', u'6', [], [], None, ''],
        [u'const cv.FONT_HERSHEY_SCRIPT_COMPLEX', u'7', [], [], None, ''],
        [u'const cv.FONT_ITALIC', u'16', [], [], None, '']],
    None]
ok: CONST FONT_HERSHEY_SIMPLEX=0
ok: CONST FONT_HERSHEY_PLAIN=1
ok: CONST FONT_HERSHEY_DUPLEX=2
ok: CONST FONT_HERSHEY_COMPLEX=3
ok: CONST FONT_HERSHEY_TRIPLEX=4
ok: CONST FONT_HERSHEY_COMPLEX_SMALL=5
ok: CONST FONT_HERSHEY_SCRIPT_SIMPLEX=6
ok: CONST FONT_HERSHEY_SCRIPT_COMPLEX=7
ok: CONST FONT_ITALIC=16

--- Incoming ---
[   u'enum cv.MarkerTypes',
    '',
    [],
    [   [u'const cv.MARKER_CROSS', u'0', [], [], None, ''],
        [u'const cv.MARKER_TILTED_CROSS', u'1', [], [], None, ''],
        [u'const cv.MARKER_STAR', u'2', [], [], None, ''],
        [u'const cv.MARKER_DIAMOND', u'3', [], [], None, ''],
        [u'const cv.MARKER_SQUARE', u'4', [], [], None, ''],
        [u'const cv.MARKER_TRIANGLE_UP', u'5', [], [], None, ''],
        [u'const cv.MARKER_TRIANGLE_DOWN', u'6', [], [], None, '']],
    None]
ok: CONST MARKER_CROSS=0
ok: CONST MARKER_TILTED_CROSS=1
ok: CONST MARKER_STAR=2
ok: CONST MARKER_DIAMOND=3
ok: CONST MARKER_SQUARE=4
ok: CONST MARKER_TRIANGLE_UP=5
ok: CONST MARKER_TRIANGLE_DOWN=6

--- Incoming ---
[u'class cv.GeneralizedHough', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.GeneralizedHough : Algorithm, name: GeneralizedHough, base: Algorithm

--- Incoming ---
[   u'cv.GeneralizedHough.setTemplate',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'templ', '', []],
        [u'Point', u'templCenter', u'Point(-1, -1)', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat templ=, ARG Point templCenter=Point(-1, -1)]>

--- Incoming ---
[   u'cv.GeneralizedHough.setTemplate',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'edges', '', []],
        ['Mat', u'dx', '', []],
        ['Mat', u'dy', '', []],
        [u'Point', u'templCenter', u'Point(-1, -1)', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Point templCenter=Point(-1, -1)]>

--- Incoming ---
[   u'cv.GeneralizedHough.detect',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'positions', '', ['/O']],
        ['Mat', u'votes', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.detect [ARG Mat image=, ARG Mat positions=, ARG Mat votes=Mat()]>

--- Incoming ---
[   u'cv.GeneralizedHough.detect',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'edges', '', []],
        ['Mat', u'dx', '', []],
        ['Mat', u'dy', '', []],
        ['Mat', u'positions', '', ['/O']],
        ['Mat', u'votes', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.detect [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Mat positions=, ARG Mat votes=Mat()]>

--- Incoming ---
[   u'cv.GeneralizedHough.setCannyLowThresh',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'cannyLowThresh', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setCannyLowThresh [ARG int cannyLowThresh=]>

--- Incoming ---
[   u'cv.GeneralizedHough.getCannyLowThresh',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHough.getCannyLowThresh []>

--- Incoming ---
[   u'cv.GeneralizedHough.setCannyHighThresh',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'cannyHighThresh', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setCannyHighThresh [ARG int cannyHighThresh=]>

--- Incoming ---
[   u'cv.GeneralizedHough.getCannyHighThresh',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHough.getCannyHighThresh []>

--- Incoming ---
[   u'cv.GeneralizedHough.setMinDist',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'minDist', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setMinDist [ARG double minDist=]>

--- Incoming ---
[   u'cv.GeneralizedHough.getMinDist',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHough.getMinDist []>

--- Incoming ---
[   u'cv.GeneralizedHough.setDp',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'dp', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setDp [ARG double dp=]>

--- Incoming ---
[u'cv.GeneralizedHough.getDp', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.GeneralizedHough.getDp []>

--- Incoming ---
[   u'cv.GeneralizedHough.setMaxBufferSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxBufferSize', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHough.setMaxBufferSize [ARG int maxBufferSize=]>

--- Incoming ---
[   u'cv.GeneralizedHough.getMaxBufferSize',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHough.getMaxBufferSize []>

--- Incoming ---
[u'class cv.GeneralizedHoughBallard', u': cv::GeneralizedHough', [], [], None]
ok: class CLASS cv::.GeneralizedHoughBallard : GeneralizedHough, name: GeneralizedHoughBallard, base: GeneralizedHough

--- Incoming ---
[   u'cv.GeneralizedHoughBallard.setLevels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'levels', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughBallard.setLevels [ARG int levels=]>

--- Incoming ---
[   u'cv.GeneralizedHoughBallard.getLevels',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHoughBallard.getLevels []>

--- Incoming ---
[   u'cv.GeneralizedHoughBallard.setVotesThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'votesThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughBallard.setVotesThreshold [ARG int votesThreshold=]>

--- Incoming ---
[   u'cv.GeneralizedHoughBallard.getVotesThreshold',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHoughBallard.getVotesThreshold []>

--- Incoming ---
[u'class cv.GeneralizedHoughGuil', u': cv::GeneralizedHough', [], [], None]
ok: class CLASS cv::.GeneralizedHoughGuil : GeneralizedHough, name: GeneralizedHoughGuil, base: GeneralizedHough

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setXi',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'xi', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setXi [ARG double xi=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getXi',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getXi []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setLevels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'levels', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setLevels [ARG int levels=]>

--- Incoming ---
[u'cv.GeneralizedHoughGuil.getLevels', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getLevels []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setAngleEpsilon',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'angleEpsilon', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setAngleEpsilon [ARG double angleEpsilon=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getAngleEpsilon',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getAngleEpsilon []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setMinAngle',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'minAngle', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMinAngle [ARG double minAngle=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getMinAngle',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMinAngle []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setMaxAngle',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'maxAngle', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMaxAngle [ARG double maxAngle=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getMaxAngle',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMaxAngle []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setAngleStep',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'angleStep', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setAngleStep [ARG double angleStep=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getAngleStep',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getAngleStep []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setAngleThresh',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'angleThresh', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setAngleThresh [ARG int angleThresh=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getAngleThresh',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getAngleThresh []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setMinScale',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'minScale', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMinScale [ARG double minScale=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getMinScale',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMinScale []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setMaxScale',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'maxScale', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setMaxScale [ARG double maxScale=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getMaxScale',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getMaxScale []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setScaleStep',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'scaleStep', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setScaleStep [ARG double scaleStep=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getScaleStep',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GeneralizedHoughGuil.getScaleStep []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setScaleThresh',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'scaleThresh', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setScaleThresh [ARG int scaleThresh=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getScaleThresh',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getScaleThresh []>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.setPosThresh',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'posThresh', u'', []]],
    u'void']
ok: FUNC <void cv.GeneralizedHoughGuil.setPosThresh [ARG int posThresh=]>

--- Incoming ---
[   u'cv.GeneralizedHoughGuil.getPosThresh',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.GeneralizedHoughGuil.getPosThresh []>

--- Incoming ---
[u'class cv.CLAHE', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.CLAHE : Algorithm, name: CLAHE, base: Algorithm

--- Incoming ---
[   u'cv.CLAHE.apply',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.CLAHE.apply [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.CLAHE.setClipLimit',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'clipLimit', u'', []]],
    u'void']
ok: FUNC <void cv.CLAHE.setClipLimit [ARG double clipLimit=]>

--- Incoming ---
[u'cv.CLAHE.getClipLimit', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.CLAHE.getClipLimit []>

--- Incoming ---
[   u'cv.CLAHE.setTilesGridSize',
    u'void',
    ['/V', '/PV'],
    [[u'Size', u'tileGridSize', u'', []]],
    u'void']
ok: FUNC <void cv.CLAHE.setTilesGridSize [ARG Size tileGridSize=]>

--- Incoming ---
[u'cv.CLAHE.getTilesGridSize', u'Size', ['/C', '/V', '/PV'], [], u'Size']
ok: FUNC <Size cv.CLAHE.getTilesGridSize []>

--- Incoming ---
[u'cv.CLAHE.collectGarbage', u'void', ['/V', '/PV'], [], u'void']
ok: FUNC <void cv.CLAHE.collectGarbage []>

--- Incoming ---
[u'class cv.Subdiv2D', '', [], [], None]
ok: class CLASS cv::.Subdiv2D : , name: Subdiv2D, base: 

--- Incoming ---
[   u'enum cv.Subdiv2D.<unnamed>',
    '',
    [],
    [   [u'const cv.Subdiv2D.PTLOC_ERROR', u'-2', [], [], None, ''],
        [u'const cv.Subdiv2D.PTLOC_OUTSIDE_RECT', u'-1', [], [], None, ''],
        [u'const cv.Subdiv2D.PTLOC_INSIDE', u'0', [], [], None, ''],
        [u'const cv.Subdiv2D.PTLOC_VERTEX', u'1', [], [], None, ''],
        [u'const cv.Subdiv2D.PTLOC_ON_EDGE', u'2', [], [], None, '']],
    None]
ok: CONST PTLOC_ERROR=-2
ok: CONST PTLOC_OUTSIDE_RECT=-1
ok: CONST PTLOC_INSIDE=0
ok: CONST PTLOC_VERTEX=1
ok: CONST PTLOC_ON_EDGE=2

--- Incoming ---
[   u'enum cv.Subdiv2D.<unnamed>',
    '',
    [],
    [   [u'const cv.Subdiv2D.NEXT_AROUND_ORG', u'0x00', [], [], None, ''],
        [u'const cv.Subdiv2D.NEXT_AROUND_DST', u'0x22', [], [], None, ''],
        [u'const cv.Subdiv2D.PREV_AROUND_ORG', u'0x11', [], [], None, ''],
        [u'const cv.Subdiv2D.PREV_AROUND_DST', u'0x33', [], [], None, ''],
        [u'const cv.Subdiv2D.NEXT_AROUND_LEFT', u'0x13', [], [], None, ''],
        [u'const cv.Subdiv2D.NEXT_AROUND_RIGHT', u'0x31', [], [], None, ''],
        [u'const cv.Subdiv2D.PREV_AROUND_LEFT', u'0x20', [], [], None, ''],
        [u'const cv.Subdiv2D.PREV_AROUND_RIGHT', u'0x02', [], [], None, '']],
    None]
ok: CONST NEXT_AROUND_ORG=0x00
ok: CONST NEXT_AROUND_DST=0x22
ok: CONST PREV_AROUND_ORG=0x11
ok: CONST PREV_AROUND_DST=0x33
ok: CONST NEXT_AROUND_LEFT=0x13
ok: CONST NEXT_AROUND_RIGHT=0x31
ok: CONST PREV_AROUND_LEFT=0x20
ok: CONST PREV_AROUND_RIGHT=0x02

--- Incoming ---
[u'cv.Subdiv2D.Subdiv2D', '', [], [], None]
ok: FUNC < cv.Subdiv2D.Subdiv2D []>

--- Incoming ---
[u'cv.Subdiv2D.Subdiv2D', '', [], [[u'Rect', u'rect', u'', []]], None]
ok: FUNC < cv.Subdiv2D.Subdiv2D [ARG Rect rect=]>

--- Incoming ---
[   u'cv.Subdiv2D.initDelaunay',
    u'void',
    [],
    [[u'Rect', u'rect', u'', []]],
    u'void']
ok: FUNC <void cv.Subdiv2D.initDelaunay [ARG Rect rect=]>

--- Incoming ---
[u'cv.Subdiv2D.insert', u'int', [], [[u'Point2f', u'pt', u'', []]], u'int']
ok: FUNC <int cv.Subdiv2D.insert [ARG Point2f pt=]>

--- Incoming ---
[   u'cv.Subdiv2D.insert',
    u'void',
    [],
    [[u'vector_Point2f', u'ptvec', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Subdiv2D.insert [ARG vector_Point2f ptvec=]>

--- Incoming ---
[   u'cv.Subdiv2D.locate',
    u'int',
    [],
    [   [u'Point2f', u'pt', u'', []],
        [u'int', u'edge', u'', ['/O', '/Ref']],
        [u'int', u'vertex', u'', ['/O', '/Ref']]],
    u'int']
ok: FUNC <int cv.Subdiv2D.locate [ARG Point2f pt=, ARG int edge=, ARG int vertex=]>

--- Incoming ---
[   u'cv.Subdiv2D.findNearest',
    u'int',
    [],
    [[u'Point2f', u'pt', u'', []], [u'Point2f*', u'nearestPt', u'0', ['/O']]],
    u'int']
ok: FUNC <int cv.Subdiv2D.findNearest [ARG Point2f pt=, ARG Point2f * nearestPt=0]>

--- Incoming ---
[   u'cv.Subdiv2D.getEdgeList',
    u'void',
    ['/C'],
    [[u'vector_Vec4f', u'edgeList', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.Subdiv2D.getEdgeList [ARG vector_Vec4f edgeList=]>

--- Incoming ---
[   u'cv.Subdiv2D.getLeadingEdgeList',
    u'void',
    ['/C'],
    [[u'vector_int', u'leadingEdgeList', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.Subdiv2D.getLeadingEdgeList [ARG vector_int leadingEdgeList=]>

--- Incoming ---
[   u'cv.Subdiv2D.getTriangleList',
    u'void',
    ['/C'],
    [[u'vector_Vec6f', u'triangleList', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.Subdiv2D.getTriangleList [ARG vector_Vec6f triangleList=]>

--- Incoming ---
[   u'cv.Subdiv2D.getVoronoiFacetList',
    u'void',
    [],
    [   [u'vector_int', u'idx', u'', ['/C', '/Ref']],
        [u'vector_vector_Point2f', u'facetList', u'', ['/O', '/Ref']],
        [u'vector_Point2f', u'facetCenters', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.Subdiv2D.getVoronoiFacetList [ARG vector_int idx=, ARG vector_vector_Point2f facetList=, ARG vector_Point2f facetCenters=]>

--- Incoming ---
[   u'cv.Subdiv2D.getVertex',
    u'Point2f',
    ['/C'],
    [[u'int', u'vertex', u'', []], [u'int*', u'firstEdge', u'0', ['/O']]],
    u'Point2f']
ok: FUNC <Point2f cv.Subdiv2D.getVertex [ARG int vertex=, ARG int * firstEdge=0]>

--- Incoming ---
[   u'cv.Subdiv2D.getEdge',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'int', u'nextEdgeType', u'', []]],
    u'int']
ok: FUNC <int cv.Subdiv2D.getEdge [ARG int edge=, ARG int nextEdgeType=]>

--- Incoming ---
[u'cv.Subdiv2D.nextEdge', u'int', ['/C'], [[u'int', u'edge', u'', []]], u'int']
ok: FUNC <int cv.Subdiv2D.nextEdge [ARG int edge=]>

--- Incoming ---
[   u'cv.Subdiv2D.rotateEdge',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'int', u'rotate', u'', []]],
    u'int']
ok: FUNC <int cv.Subdiv2D.rotateEdge [ARG int edge=, ARG int rotate=]>

--- Incoming ---
[u'cv.Subdiv2D.symEdge', u'int', ['/C'], [[u'int', u'edge', u'', []]], u'int']
ok: FUNC <int cv.Subdiv2D.symEdge [ARG int edge=]>

--- Incoming ---
[   u'cv.Subdiv2D.edgeOrg',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'Point2f*', u'orgpt', u'0', ['/O']]],
    u'int']
ok: FUNC <int cv.Subdiv2D.edgeOrg [ARG int edge=, ARG Point2f * orgpt=0]>

--- Incoming ---
[   u'cv.Subdiv2D.edgeDst',
    u'int',
    ['/C'],
    [[u'int', u'edge', u'', []], [u'Point2f*', u'dstpt', u'0', ['/O']]],
    u'int']
ok: FUNC <int cv.Subdiv2D.edgeDst [ARG int edge=, ARG Point2f * dstpt=0]>

--- Incoming ---
[u'class cv.LineSegmentDetector', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.LineSegmentDetector : Algorithm, name: LineSegmentDetector, base: Algorithm

--- Incoming ---
[   u'cv.LineSegmentDetector.detect',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'_image', '', []],
        ['Mat', u'_lines', '', ['/O']],
        ['Mat', u'width', u'Mat()', ['/O']],
        ['Mat', u'prec', u'Mat()', ['/O']],
        ['Mat', u'nfa', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.LineSegmentDetector.detect [ARG Mat _image=, ARG Mat _lines=, ARG Mat width=Mat(), ARG Mat prec=Mat(), ARG Mat nfa=Mat()]>

--- Incoming ---
[   u'cv.LineSegmentDetector.drawSegments',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'_image', '', ['/IO']], ['Mat', u'lines', '', []]],
    u'void']
ok: FUNC <void cv.LineSegmentDetector.drawSegments [ARG Mat _image=, ARG Mat lines=]>

--- Incoming ---
[   u'cv.LineSegmentDetector.compareSegments',
    u'int',
    ['/V', '/PV'],
    [   [u'Size', u'size', u'', ['/C', '/Ref']],
        ['Mat', u'lines1', '', []],
        ['Mat', u'lines2', '', []],
        ['Mat', u'_image', u'Mat()', ['/IO']]],
    u'int']
ok: FUNC <int cv.LineSegmentDetector.compareSegments [ARG Size size=, ARG Mat lines1=, ARG Mat lines2=, ARG Mat _image=Mat()]>

--- Incoming ---
[   u'cv.createLineSegmentDetector',
    u'Ptr_LineSegmentDetector',
    [],
    [   [u'int', u'_refine', u'LSD_REFINE_STD', []],
        [u'double', u'_scale', u'0.8', []],
        [u'double', u'_sigma_scale', u'0.6', []],
        [u'double', u'_quant', u'2.0', []],
        [u'double', u'_ang_th', u'22.5', []],
        [u'double', u'_log_eps', u'0', []],
        [u'double', u'_density_th', u'0.7', []],
        [u'int', u'_n_bins', u'1024', []]],
    u'Ptr<LineSegmentDetector>']
ok: FUNC <Ptr_LineSegmentDetector cv..createLineSegmentDetector [ARG int _refine=LSD_REFINE_STD, ARG double _scale=0.8, ARG double _sigma_scale=0.6, ARG double _quant=2.0, ARG double _ang_th=22.5, ARG double _log_eps=0, ARG double _density_th=0.7, ARG int _n_bins=1024]>

--- Incoming ---
[   u'cv.getGaussianKernel',
    u'Mat',
    [],
    [   [u'int', u'ksize', u'', []],
        [u'double', u'sigma', u'', []],
        [u'int', u'ktype', u'CV_64F', []]],
    u'Mat']
ok: FUNC <Mat cv..getGaussianKernel [ARG int ksize=, ARG double sigma=, ARG int ktype=CV_64F]>

--- Incoming ---
[   u'cv.getDerivKernels',
    u'void',
    [],
    [   ['Mat', u'kx', '', ['/O']],
        ['Mat', u'ky', '', ['/O']],
        [u'int', u'dx', u'', []],
        [u'int', u'dy', u'', []],
        [u'int', u'ksize', u'', []],
        [u'bool', u'normalize', u'false', []],
        [u'int', u'ktype', u'CV_32F', []]],
    u'void']
ok: FUNC <void cv..getDerivKernels [ARG Mat kx=, ARG Mat ky=, ARG int dx=, ARG int dy=, ARG int ksize=, ARG bool normalize=false, ARG int ktype=CV_32F]>

--- Incoming ---
[   u'cv.getGaborKernel',
    u'Mat',
    [],
    [   [u'Size', u'ksize', u'', []],
        [u'double', u'sigma', u'', []],
        [u'double', u'theta', u'', []],
        [u'double', u'lambd', u'', []],
        [u'double', u'gamma', u'', []],
        [u'double', u'psi', u'CV_PI*0.5', []],
        [u'int', u'ktype', u'CV_64F', []]],
    u'Mat']
ok: FUNC <Mat cv..getGaborKernel [ARG Size ksize=, ARG double sigma=, ARG double theta=, ARG double lambd=, ARG double gamma=, ARG double psi=CV_PI*0.5, ARG int ktype=CV_64F]>

--- Incoming ---
[   u'cv.getStructuringElement',
    u'Mat',
    [],
    [   [u'int', u'shape', u'', []],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []]],
    u'Mat']
ok: FUNC <Mat cv..getStructuringElement [ARG int shape=, ARG Size ksize=, ARG Point anchor=Point(-1,-1)]>

--- Incoming ---
[   u'cv.medianBlur',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ksize', u'', []]],
    u'void']
ok: FUNC <void cv..medianBlur [ARG Mat src=, ARG Mat dst=, ARG int ksize=]>

--- Incoming ---
[   u'cv.GaussianBlur',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'ksize', u'', []],
        [u'double', u'sigmaX', u'', []],
        [u'double', u'sigmaY', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..GaussianBlur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG double sigmaX=, ARG double sigmaY=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.bilateralFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'd', u'', []],
        [u'double', u'sigmaColor', u'', []],
        [u'double', u'sigmaSpace', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..bilateralFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.boxFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'bool', u'normalize', u'true', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..boxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.sqrBoxFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1, -1)', []],
        [u'bool', u'normalize', u'true', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..sqrBoxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1, -1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.blur',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'ksize', u'', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..blur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.filter2D',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..filter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.sepFilter2D',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        ['Mat', u'kernelX', '', []],
        ['Mat', u'kernelY', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..sepFilter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernelX=, ARG Mat kernelY=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Sobel',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'int', u'dx', u'', []],
        [u'int', u'dy', u'', []],
        [u'int', u'ksize', u'3', []],
        [u'double', u'scale', u'1', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..Sobel [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG int ksize=3, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.spatialGradient',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dx', '', ['/O']],
        ['Mat', u'dy', '', ['/O']],
        [u'int', u'ksize', u'3', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..spatialGradient [ARG Mat src=, ARG Mat dx=, ARG Mat dy=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Scharr',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'int', u'dx', u'', []],
        [u'int', u'dy', u'', []],
        [u'double', u'scale', u'1', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..Scharr [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Laplacian',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ddepth', u'', []],
        [u'int', u'ksize', u'1', []],
        [u'double', u'scale', u'1', []],
        [u'double', u'delta', u'0', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..Laplacian [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int ksize=1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.Canny',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'edges', '', ['/O']],
        [u'double', u'threshold1', u'', []],
        [u'double', u'threshold2', u'', []],
        [u'int', u'apertureSize', u'3', []],
        [u'bool', u'L2gradient', u'false', []]],
    u'void']
ok: FUNC <void cv..Canny [ARG Mat image=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG int apertureSize=3, ARG bool L2gradient=false]>

--- Incoming ---
[   u'cv.Canny',
    u'void',
    [],
    [   ['Mat', u'dx', '', []],
        ['Mat', u'dy', '', []],
        ['Mat', u'edges', '', ['/O']],
        [u'double', u'threshold1', u'', []],
        [u'double', u'threshold2', u'', []],
        [u'bool', u'L2gradient', u'false', []]],
    u'void']
ok: FUNC <void cv..Canny [ARG Mat dx=, ARG Mat dy=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG bool L2gradient=false]>

--- Incoming ---
[   u'cv.cornerMinEigenVal',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'blockSize', u'', []],
        [u'int', u'ksize', u'3', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..cornerMinEigenVal [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.cornerHarris',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'blockSize', u'', []],
        [u'int', u'ksize', u'', []],
        [u'double', u'k', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..cornerHarris [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG double k=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.cornerEigenValsAndVecs',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'blockSize', u'', []],
        [u'int', u'ksize', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..cornerEigenValsAndVecs [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.preCornerDetect',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'ksize', u'', []],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..preCornerDetect [ARG Mat src=, ARG Mat dst=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.cornerSubPix',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'corners', '', ['/IO']],
        [u'Size', u'winSize', u'', []],
        [u'Size', u'zeroZone', u'', []],
        [u'TermCriteria', u'criteria', u'', []]],
    u'void']
ok: FUNC <void cv..cornerSubPix [ARG Mat image=, ARG Mat corners=, ARG Size winSize=, ARG Size zeroZone=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.goodFeaturesToTrack',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'corners', '', ['/O']],
        [u'int', u'maxCorners', u'', []],
        [u'double', u'qualityLevel', u'', []],
        [u'double', u'minDistance', u'', []],
        ['Mat', u'mask', u'Mat()', []],
        [u'int', u'blockSize', u'3', []],
        [u'bool', u'useHarrisDetector', u'false', []],
        [u'double', u'k', u'0.04', []]],
    u'void']
ok: FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=Mat(), ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   u'cv.goodFeaturesToTrack',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'corners', '', ['/O']],
        [u'int', u'maxCorners', u'', []],
        [u'double', u'qualityLevel', u'', []],
        [u'double', u'minDistance', u'', []],
        ['Mat', u'mask', '', []],
        [u'int', u'blockSize', u'', []],
        [u'int', u'gradientSize', u'', []],
        [u'bool', u'useHarrisDetector', u'false', []],
        [u'double', u'k', u'0.04', []]],
    u'void']
ok: FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=, ARG int blockSize=, ARG int gradientSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   u'cv.HoughLines',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'lines', '', ['/O']],
        [u'double', u'rho', u'', []],
        [u'double', u'theta', u'', []],
        [u'int', u'threshold', u'', []],
        [u'double', u'srn', u'0', []],
        [u'double', u'stn', u'0', []],
        [u'double', u'min_theta', u'0', []],
        [u'double', u'max_theta', u'CV_PI', []]],
    u'void']
ok: FUNC <void cv..HoughLines [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double srn=0, ARG double stn=0, ARG double min_theta=0, ARG double max_theta=CV_PI]>

--- Incoming ---
[   u'cv.HoughLinesP',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'lines', '', ['/O']],
        [u'double', u'rho', u'', []],
        [u'double', u'theta', u'', []],
        [u'int', u'threshold', u'', []],
        [u'double', u'minLineLength', u'0', []],
        [u'double', u'maxLineGap', u'0', []]],
    u'void']
ok: FUNC <void cv..HoughLinesP [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double minLineLength=0, ARG double maxLineGap=0]>

--- Incoming ---
[   u'cv.HoughLinesPointSet',
    u'void',
    [],
    [   ['Mat', u'_point', '', []],
        ['Mat', u'_lines', '', ['/O']],
        [u'int', u'lines_max', u'', []],
        [u'int', u'threshold', u'', []],
        [u'double', u'min_rho', u'', []],
        [u'double', u'max_rho', u'', []],
        [u'double', u'rho_step', u'', []],
        [u'double', u'min_theta', u'', []],
        [u'double', u'max_theta', u'', []],
        [u'double', u'theta_step', u'', []]],
    u'void']
ok: FUNC <void cv..HoughLinesPointSet [ARG Mat _point=, ARG Mat _lines=, ARG int lines_max=, ARG int threshold=, ARG double min_rho=, ARG double max_rho=, ARG double rho_step=, ARG double min_theta=, ARG double max_theta=, ARG double theta_step=]>

--- Incoming ---
[   u'cv.HoughCircles',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'circles', '', ['/O']],
        [u'int', u'method', u'', []],
        [u'double', u'dp', u'', []],
        [u'double', u'minDist', u'', []],
        [u'double', u'param1', u'100', []],
        [u'double', u'param2', u'100', []],
        [u'int', u'minRadius', u'0', []],
        [u'int', u'maxRadius', u'0', []]],
    u'void']
ok: FUNC <void cv..HoughCircles [ARG Mat image=, ARG Mat circles=, ARG int method=, ARG double dp=, ARG double minDist=, ARG double param1=100, ARG double param2=100, ARG int minRadius=0, ARG int maxRadius=0]>

--- Incoming ---
[   u'cv.erode',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'iterations', u'1', []],
        [u'int', u'borderType', u'BORDER_CONSTANT', []],
        [   u'Scalar',
            u'borderValue',
            u'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..erode [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   u'cv.dilate',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'iterations', u'1', []],
        [u'int', u'borderType', u'BORDER_CONSTANT', []],
        [   u'Scalar',
            u'borderValue',
            u'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..dilate [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   u'cv.morphologyEx',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'op', u'', []],
        ['Mat', u'kernel', '', []],
        [u'Point', u'anchor', u'Point(-1,-1)', []],
        [u'int', u'iterations', u'1', []],
        [u'int', u'borderType', u'BORDER_CONSTANT', []],
        [   u'Scalar',
            u'borderValue',
            u'morphologyDefaultBorderValue()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..morphologyEx [ARG Mat src=, ARG Mat dst=, ARG int op=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>

--- Incoming ---
[   u'cv.resize',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'dsize', u'', []],
        [u'double', u'fx', u'0', []],
        [u'double', u'fy', u'0', []],
        [u'int', u'interpolation', u'INTER_LINEAR', []]],
    u'void']
ok: FUNC <void cv..resize [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG double fx=0, ARG double fy=0, ARG int interpolation=INTER_LINEAR]>

--- Incoming ---
[   u'cv.warpAffine',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'M', '', []],
        [u'Size', u'dsize', u'', []],
        [u'int', u'flags', u'INTER_LINEAR', []],
        [u'int', u'borderMode', u'BORDER_CONSTANT', []],
        [u'Scalar', u'borderValue', u'Scalar()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..warpAffine [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   u'cv.warpPerspective',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'M', '', []],
        [u'Size', u'dsize', u'', []],
        [u'int', u'flags', u'INTER_LINEAR', []],
        [u'int', u'borderMode', u'BORDER_CONSTANT', []],
        [u'Scalar', u'borderValue', u'Scalar()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..warpPerspective [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   u'cv.remap',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'map1', '', []],
        ['Mat', u'map2', '', []],
        [u'int', u'interpolation', u'', []],
        [u'int', u'borderMode', u'BORDER_CONSTANT', []],
        [u'Scalar', u'borderValue', u'Scalar()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv..remap [ARG Mat src=, ARG Mat dst=, ARG Mat map1=, ARG Mat map2=, ARG int interpolation=, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>

--- Incoming ---
[   u'cv.convertMaps',
    u'void',
    [],
    [   ['Mat', u'map1', '', []],
        ['Mat', u'map2', '', []],
        ['Mat', u'dstmap1', '', ['/O']],
        ['Mat', u'dstmap2', '', ['/O']],
        [u'int', u'dstmap1type', u'', []],
        [u'bool', u'nninterpolation', u'false', []]],
    u'void']
ok: FUNC <void cv..convertMaps [ARG Mat map1=, ARG Mat map2=, ARG Mat dstmap1=, ARG Mat dstmap2=, ARG int dstmap1type=, ARG bool nninterpolation=false]>

--- Incoming ---
[   u'cv.getRotationMatrix2D',
    u'Mat',
    [],
    [   [u'Point2f', u'center', u'', []],
        [u'double', u'angle', u'', []],
        [u'double', u'scale', u'', []]],
    u'Mat']
ok: FUNC <Mat cv..getRotationMatrix2D [ARG Point2f center=, ARG double angle=, ARG double scale=]>

--- Incoming ---
[   u'cv.invertAffineTransform',
    u'void',
    [],
    [['Mat', u'M', '', []], ['Mat', u'iM', '', ['/O']]],
    u'void']
ok: FUNC <void cv..invertAffineTransform [ARG Mat M=, ARG Mat iM=]>

--- Incoming ---
[   u'cv.getPerspectiveTransform',
    u'Mat',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', []],
        [u'int', u'solveMethod', u'DECOMP_LU', []]],
    u'Mat']
ok: FUNC <Mat cv..getPerspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG int solveMethod=DECOMP_LU]>

--- Incoming ---
[   u'cv.getAffineTransform',
    u'Mat',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', []]],
    u'Mat']
ok: FUNC <Mat cv..getAffineTransform [ARG vector_Point2f src=, ARG vector_Point2f dst=]>

--- Incoming ---
[   u'cv.getRectSubPix',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patchSize', u'', []],
        [u'Point2f', u'center', u'', []],
        ['Mat', u'patch', '', ['/O']],
        [u'int', u'patchType', u'-1', []]],
    u'void']
ok: FUNC <void cv..getRectSubPix [ARG Mat image=, ARG Size patchSize=, ARG Point2f center=, ARG Mat patch=, ARG int patchType=-1]>

--- Incoming ---
[   u'cv.logPolar',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Point2f', u'center', u'', []],
        [u'double', u'M', u'', []],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..logPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double M=, ARG int flags=]>

--- Incoming ---
[   u'cv.linearPolar',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Point2f', u'center', u'', []],
        [u'double', u'maxRadius', u'', []],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..linearPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>

--- Incoming ---
[   u'cv.warpPolar',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'dsize', u'', []],
        [u'Point2f', u'center', u'', []],
        [u'double', u'maxRadius', u'', []],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..warpPolar [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>

--- Incoming ---
[   u'cv.integral',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'sum', '', ['/O']],
        [u'int', u'sdepth', u'-1', []]],
    u'void']
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG int sdepth=-1]>

--- Incoming ---
[   u'cv.integral',
    u'void',
    [u'=integral2'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'sum', '', ['/O']],
        ['Mat', u'sqsum', '', ['/O']],
        [u'int', u'sdepth', u'-1', []],
        [u'int', u'sqdepth', u'-1', []]],
    u'void']
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG int sdepth=-1, ARG int sqdepth=-1]>

--- Incoming ---
[   u'cv.integral',
    u'void',
    [u'=integral3'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'sum', '', ['/O']],
        ['Mat', u'sqsum', '', ['/O']],
        ['Mat', u'tilted', '', ['/O']],
        [u'int', u'sdepth', u'-1', []],
        [u'int', u'sqdepth', u'-1', []]],
    u'void']
ok: FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG Mat tilted=, ARG int sdepth=-1, ARG int sqdepth=-1]>

--- Incoming ---
[   u'cv.accumulate',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..accumulate [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.accumulateSquare',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..accumulateSquare [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.accumulateProduct',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/IO']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..accumulateProduct [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.accumulateWeighted',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/IO']],
        [u'double', u'alpha', u'', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..accumulateWeighted [ARG Mat src=, ARG Mat dst=, ARG double alpha=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.phaseCorrelate',
    u'Point2d',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'window', u'Mat()', []],
        [u'double*', u'response', u'0', ['/O']]],
    u'Point2d']
ok: FUNC <Point2d cv..phaseCorrelate [ARG Mat src1=, ARG Mat src2=, ARG Mat window=Mat(), ARG double * response=0]>

--- Incoming ---
[   u'cv.createHanningWindow',
    u'void',
    [],
    [   ['Mat', u'dst', '', ['/O']],
        [u'Size', u'winSize', u'', []],
        [u'int', u'type', u'', []]],
    u'void']
ok: FUNC <void cv..createHanningWindow [ARG Mat dst=, ARG Size winSize=, ARG int type=]>

--- Incoming ---
[   u'cv.threshold',
    u'double',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'thresh', u'', []],
        [u'double', u'maxval', u'', []],
        [u'int', u'type', u'', []]],
    u'double']
ok: FUNC <double cv..threshold [ARG Mat src=, ARG Mat dst=, ARG double thresh=, ARG double maxval=, ARG int type=]>

--- Incoming ---
[   u'cv.adaptiveThreshold',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'maxValue', u'', []],
        [u'int', u'adaptiveMethod', u'', []],
        [u'int', u'thresholdType', u'', []],
        [u'int', u'blockSize', u'', []],
        [u'double', u'C', u'', []]],
    u'void']
ok: FUNC <void cv..adaptiveThreshold [ARG Mat src=, ARG Mat dst=, ARG double maxValue=, ARG int adaptiveMethod=, ARG int thresholdType=, ARG int blockSize=, ARG double C=]>

--- Incoming ---
[   u'cv.pyrDown',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'dstsize', u'Size()', ['/C', '/Ref']],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..pyrDown [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.pyrUp',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Size', u'dstsize', u'Size()', ['/C', '/Ref']],
        [u'int', u'borderType', u'BORDER_DEFAULT', []]],
    u'void']
ok: FUNC <void cv..pyrUp [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>

--- Incoming ---
[   u'cv.calcHist',
    u'void',
    [],
    [   ['vector_Mat', u'images', '', []],
        [u'vector_int', u'channels', u'', ['/C', '/Ref']],
        ['Mat', u'mask', '', []],
        ['Mat', u'hist', '', ['/O']],
        [u'vector_int', u'histSize', u'', ['/C', '/Ref']],
        [u'vector_float', u'ranges', u'', ['/C', '/Ref']],
        [u'bool', u'accumulate', u'false', []]],
    u'void']
ok: FUNC <void cv..calcHist [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat mask=, ARG Mat hist=, ARG vector_int histSize=, ARG vector_float ranges=, ARG bool accumulate=false]>

--- Incoming ---
[   u'cv.calcBackProject',
    u'void',
    [],
    [   ['vector_Mat', u'images', '', []],
        [u'vector_int', u'channels', u'', ['/C', '/Ref']],
        ['Mat', u'hist', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'vector_float', u'ranges', u'', ['/C', '/Ref']],
        [u'double', u'scale', u'', []]],
    u'void']
ok: FUNC <void cv..calcBackProject [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat hist=, ARG Mat dst=, ARG vector_float ranges=, ARG double scale=]>

--- Incoming ---
[   u'cv.compareHist',
    u'double',
    [],
    [   ['Mat', u'H1', '', []],
        ['Mat', u'H2', '', []],
        [u'int', u'method', u'', []]],
    u'double']
ok: FUNC <double cv..compareHist [ARG Mat H1=, ARG Mat H2=, ARG int method=]>

--- Incoming ---
[   u'cv.equalizeHist',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..equalizeHist [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.createCLAHE',
    u'Ptr_CLAHE',
    [],
    [   [u'double', u'clipLimit', u'40.0', []],
        [u'Size', u'tileGridSize', u'Size(8, 8)', []]],
    u'Ptr<CLAHE>']
ok: FUNC <Ptr_CLAHE cv..createCLAHE [ARG double clipLimit=40.0, ARG Size tileGridSize=Size(8, 8)]>

--- Incoming ---
[   u'cv.wrapperEMD',
    u'float',
    [u'=EMD'],
    [   ['Mat', u'signature1', '', []],
        ['Mat', u'signature2', '', []],
        [u'int', u'distType', u'', []],
        ['Mat', u'cost', u'Mat()', []],
        [u'Ptr_float', u'lowerBound', u'Ptr<float>()', ['/IO']],
        ['Mat', u'flow', u'Mat()', ['/O']]],
    u'float']
ok: FUNC <float cv..wrapperEMD [ARG Mat signature1=, ARG Mat signature2=, ARG int distType=, ARG Mat cost=Mat(), ARG Ptr_float lowerBound=Ptr<float>(), ARG Mat flow=Mat()]>

--- Incoming ---
[   u'cv.watershed',
    u'void',
    [],
    [['Mat', u'image', '', []], ['Mat', u'markers', '', ['/IO']]],
    u'void']
ok: FUNC <void cv..watershed [ARG Mat image=, ARG Mat markers=]>

--- Incoming ---
[   u'cv.pyrMeanShiftFiltering',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'sp', u'', []],
        [u'double', u'sr', u'', []],
        [u'int', u'maxLevel', u'1', []],
        [   u'TermCriteria',
            u'termcrit',
            u'TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)',
            []]],
    u'void']
ok: FUNC <void cv..pyrMeanShiftFiltering [ARG Mat src=, ARG Mat dst=, ARG double sp=, ARG double sr=, ARG int maxLevel=1, ARG TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)]>

--- Incoming ---
[   u'cv.grabCut',
    u'void',
    [],
    [   ['Mat', u'img', '', []],
        ['Mat', u'mask', '', ['/IO']],
        [u'Rect', u'rect', u'', []],
        ['Mat', u'bgdModel', '', ['/IO']],
        ['Mat', u'fgdModel', '', ['/IO']],
        [u'int', u'iterCount', u'', []],
        [u'int', u'mode', u'GC_EVAL', []]],
    u'void']
ok: FUNC <void cv..grabCut [ARG Mat img=, ARG Mat mask=, ARG Rect rect=, ARG Mat bgdModel=, ARG Mat fgdModel=, ARG int iterCount=, ARG int mode=GC_EVAL]>

--- Incoming ---
[   u'cv.distanceTransform',
    u'void',
    [u'=distanceTransformWithLabels'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'labels', '', ['/O']],
        [u'int', u'distanceType', u'', []],
        [u'int', u'maskSize', u'', []],
        [u'int', u'labelType', u'DIST_LABEL_CCOMP', []]],
    u'void']
ok: FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG Mat labels=, ARG int distanceType=, ARG int maskSize=, ARG int labelType=DIST_LABEL_CCOMP]>

--- Incoming ---
[   u'cv.distanceTransform',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'distanceType', u'', []],
        [u'int', u'maskSize', u'', []],
        [u'int', u'dstType', u'CV_32F', []]],
    u'void']
ok: FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG int distanceType=, ARG int maskSize=, ARG int dstType=CV_32F]>

--- Incoming ---
[   u'cv.floodFill',
    u'int',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['Mat', u'mask', '', ['/IO']],
        [u'Point', u'seedPoint', u'', []],
        [u'Scalar', u'newVal', u'', []],
        [u'Rect*', u'rect', u'0', ['/O']],
        [u'Scalar', u'loDiff', u'Scalar()', []],
        [u'Scalar', u'upDiff', u'Scalar()', []],
        [u'int', u'flags', u'4', []]],
    u'int']
ok: FUNC <int cv..floodFill [ARG Mat image=, ARG Mat mask=, ARG Point seedPoint=, ARG Scalar newVal=, ARG Rect * rect=0, ARG Scalar loDiff=Scalar(), ARG Scalar upDiff=Scalar(), ARG int flags=4]>

--- Incoming ---
[   u'cv.cvtColor',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'code', u'', []],
        [u'int', u'dstCn', u'0', []]],
    u'void']
ok: FUNC <void cv..cvtColor [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>

--- Incoming ---
[   u'cv.cvtColorTwoPlane',
    u'void',
    [],
    [   ['Mat', u'src1', '', []],
        ['Mat', u'src2', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'code', u'', []]],
    u'void']
ok: FUNC <void cv..cvtColorTwoPlane [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int code=]>

--- Incoming ---
[   u'cv.demosaicing',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'code', u'', []],
        [u'int', u'dstCn', u'0', []]],
    u'void']
ok: FUNC <void cv..demosaicing [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>

--- Incoming ---
[   u'cv.moments',
    u'Moments',
    [],
    [['Mat', u'array', '', []], [u'bool', u'binaryImage', u'false', []]],
    u'Moments']
ok: FUNC <Moments cv..moments [ARG Mat array=, ARG bool binaryImage=false]>

--- Incoming ---
[   u'cv.HuMoments',
    u'void',
    [],
    [[u'Moments', u'm', u'', ['/C', '/Ref']], ['Mat', u'hu', '', ['/O']]],
    u'void']
ok: FUNC <void cv..HuMoments [ARG Moments m=, ARG Mat hu=]>

--- Incoming ---
[   u'enum cv.TemplateMatchModes',
    '',
    [],
    [   [u'const cv.TM_SQDIFF', u'0', [], [], None, ''],
        [u'const cv.TM_SQDIFF_NORMED', u'1', [], [], None, ''],
        [u'const cv.TM_CCORR', u'2', [], [], None, ''],
        [u'const cv.TM_CCORR_NORMED', u'3', [], [], None, ''],
        [u'const cv.TM_CCOEFF', u'4', [], [], None, ''],
        [u'const cv.TM_CCOEFF_NORMED', u'5', [], [], None, '']],
    None]
ok: CONST TM_SQDIFF=0
ok: CONST TM_SQDIFF_NORMED=1
ok: CONST TM_CCORR=2
ok: CONST TM_CCORR_NORMED=3
ok: CONST TM_CCOEFF=4
ok: CONST TM_CCOEFF_NORMED=5

--- Incoming ---
[   u'cv.matchTemplate',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'templ', '', []],
        ['Mat', u'result', '', ['/O']],
        [u'int', u'method', u'', []],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..matchTemplate [ARG Mat image=, ARG Mat templ=, ARG Mat result=, ARG int method=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.connectedComponents',
    u'int',
    [u'=connectedComponentsWithAlgorithm'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        [u'int', u'connectivity', u'', []],
        [u'int', u'ltype', u'', []],
        [u'int', u'ccltype', u'', []]],
    u'int']
ok: FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>

--- Incoming ---
[   u'cv.connectedComponents',
    u'int',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        [u'int', u'connectivity', u'8', []],
        [u'int', u'ltype', u'CV_32S', []]],
    u'int']
ok: FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=8, ARG int ltype=CV_32S]>

--- Incoming ---
[   u'cv.connectedComponentsWithStats',
    u'int',
    [u'=connectedComponentsWithStatsWithAlgorithm'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        ['Mat', u'stats', '', ['/O']],
        ['Mat', u'centroids', '', ['/O']],
        [u'int', u'connectivity', u'', []],
        [u'int', u'ltype', u'', []],
        [u'int', u'ccltype', u'', []]],
    u'int']
ok: FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>

--- Incoming ---
[   u'cv.connectedComponentsWithStats',
    u'int',
    [],
    [   ['Mat', u'image', '', []],
        ['Mat', u'labels', '', ['/O']],
        ['Mat', u'stats', '', ['/O']],
        ['Mat', u'centroids', '', ['/O']],
        [u'int', u'connectivity', u'8', []],
        [u'int', u'ltype', u'CV_32S', []]],
    u'int']
ok: FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=8, ARG int ltype=CV_32S]>

--- Incoming ---
[   u'cv.findContours',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        ['vector_Mat', u'contours', '', ['/O']],
        ['Mat', u'hierarchy', '', ['/O']],
        [u'int', u'mode', u'', []],
        [u'int', u'method', u'', []],
        [u'Point', u'offset', u'Point()', []]],
    u'void']
ok: FUNC <void cv..findContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG Mat hierarchy=, ARG int mode=, ARG int method=, ARG Point offset=Point()]>

--- Incoming ---
[   u'cv.approxPolyDP',
    u'void',
    [],
    [   ['Mat', u'curve', '', []],
        ['Mat', u'approxCurve', '', ['/O']],
        [u'double', u'epsilon', u'', []],
        [u'bool', u'closed', u'', []]],
    u'void']
ok: FUNC <void cv..approxPolyDP [ARG vector_Point2f curve=, ARG vector_Point2f approxCurve=, ARG double epsilon=, ARG bool closed=]>

--- Incoming ---
[   u'cv.arcLength',
    u'double',
    [],
    [['Mat', u'curve', '', []], [u'bool', u'closed', u'', []]],
    u'double']
ok: FUNC <double cv..arcLength [ARG vector_Point2f curve=, ARG bool closed=]>

--- Incoming ---
[u'cv.boundingRect', u'Rect', [], [['Mat', u'array', '', []]], u'Rect']
ok: FUNC <Rect cv..boundingRect [ARG Mat array=]>

--- Incoming ---
[   u'cv.contourArea',
    u'double',
    [],
    [['Mat', u'contour', '', []], [u'bool', u'oriented', u'false', []]],
    u'double']
ok: FUNC <double cv..contourArea [ARG Mat contour=, ARG bool oriented=false]>

--- Incoming ---
[   u'cv.minAreaRect',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect']
ok: FUNC <RotatedRect cv..minAreaRect [ARG vector_Point2f points=]>

--- Incoming ---
[   u'cv.boxPoints',
    u'void',
    [],
    [[u'RotatedRect', u'box', u'', []], ['Mat', u'points', '', ['/O']]],
    u'void']
ok: FUNC <void cv..boxPoints [ARG RotatedRect box=, ARG Mat points=]>

--- Incoming ---
[   u'cv.minEnclosingCircle',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        [u'Point2f', u'center', u'', ['/O', '/Ref']],
        [u'float', u'radius', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv..minEnclosingCircle [ARG vector_Point2f points=, ARG Point2f center=, ARG float radius=]>

--- Incoming ---
[   u'cv.minEnclosingTriangle',
    u'double',
    [],
    [['Mat', u'points', '', []], ['Mat', u'triangle', '', ['/O', '/O']]],
    u'double']
ok: FUNC <double cv..minEnclosingTriangle [ARG Mat points=, ARG Mat triangle=]>

--- Incoming ---
[   u'cv.matchShapes',
    u'double',
    [],
    [   ['Mat', u'contour1', '', []],
        ['Mat', u'contour2', '', []],
        [u'int', u'method', u'', []],
        [u'double', u'parameter', u'', []]],
    u'double']
ok: FUNC <double cv..matchShapes [ARG Mat contour1=, ARG Mat contour2=, ARG int method=, ARG double parameter=]>

--- Incoming ---
[   u'cv.convexHull',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        ['Mat', u'hull', '', ['/O']],
        [u'bool', u'clockwise', u'false', []],
        [u'bool', u'returnPoints', u'true', []]],
    u'void']
ok: FUNC <void cv..convexHull [ARG vector_Point points=, ARG vector_int hull=, ARG bool clockwise=false, ARG  returnPoints=true]>

--- Incoming ---
[   u'cv.convexityDefects',
    u'void',
    [],
    [   ['Mat', u'contour', '', []],
        ['Mat', u'convexhull', '', []],
        ['Mat', u'convexityDefects', '', ['/O']]],
    u'void']
ok: FUNC <void cv..convexityDefects [ARG vector_Point contour=, ARG vector_int convexhull=, ARG vector_Vec4i convexityDefects=]>

--- Incoming ---
[u'cv.isContourConvex', u'bool', [], [['Mat', u'contour', '', []]], u'bool']
ok: FUNC <bool cv..isContourConvex [ARG vector_Point contour=]>

--- Incoming ---
[   u'cv.intersectConvexConvex',
    u'float',
    [],
    [   ['Mat', u'_p1', '', []],
        ['Mat', u'_p2', '', []],
        ['Mat', u'_p12', '', ['/O']],
        [u'bool', u'handleNested', u'true', []]],
    u'float']
ok: FUNC <float cv..intersectConvexConvex [ARG Mat _p1=, ARG Mat _p2=, ARG Mat _p12=, ARG bool handleNested=true]>

--- Incoming ---
[   u'cv.fitEllipse',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect']
ok: FUNC <RotatedRect cv..fitEllipse [ARG vector_Point2f points=]>

--- Incoming ---
[   u'cv.fitEllipseAMS',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect']
ok: FUNC <RotatedRect cv..fitEllipseAMS [ARG Mat points=]>

--- Incoming ---
[   u'cv.fitEllipseDirect',
    u'RotatedRect',
    [],
    [['Mat', u'points', '', []]],
    u'RotatedRect']
ok: FUNC <RotatedRect cv..fitEllipseDirect [ARG Mat points=]>

--- Incoming ---
[   u'cv.fitLine',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        ['Mat', u'line', '', ['/O']],
        [u'int', u'distType', u'', []],
        [u'double', u'param', u'', []],
        [u'double', u'reps', u'', []],
        [u'double', u'aeps', u'', []]],
    u'void']
ok: FUNC <void cv..fitLine [ARG Mat points=, ARG Mat line=, ARG int distType=, ARG double param=, ARG double reps=, ARG double aeps=]>

--- Incoming ---
[   u'cv.pointPolygonTest',
    u'double',
    [],
    [   ['Mat', u'contour', '', []],
        [u'Point2f', u'pt', u'', []],
        [u'bool', u'measureDist', u'', []]],
    u'double']
ok: FUNC <double cv..pointPolygonTest [ARG vector_Point2f contour=, ARG Point2f pt=, ARG bool measureDist=]>

--- Incoming ---
[   u'cv.rotatedRectangleIntersection',
    u'int',
    [],
    [   [u'RotatedRect', u'rect1', u'', ['/C', '/Ref']],
        [u'RotatedRect', u'rect2', u'', ['/C', '/Ref']],
        ['Mat', u'intersectingRegion', '', ['/O']]],
    u'int']
ok: FUNC <int cv..rotatedRectangleIntersection [ARG RotatedRect rect1=, ARG RotatedRect rect2=, ARG Mat intersectingRegion=]>

--- Incoming ---
[   u'cv.createGeneralizedHoughBallard',
    u'Ptr_GeneralizedHoughBallard',
    [],
    [],
    u'Ptr<GeneralizedHoughBallard>']
ok: FUNC <Ptr_GeneralizedHoughBallard cv..createGeneralizedHoughBallard []>

--- Incoming ---
[   u'cv.createGeneralizedHoughGuil',
    u'Ptr_GeneralizedHoughGuil',
    [],
    [],
    u'Ptr<GeneralizedHoughGuil>']
ok: FUNC <Ptr_GeneralizedHoughGuil cv..createGeneralizedHoughGuil []>

--- Incoming ---
[   u'enum cv.ColormapTypes',
    '',
    [],
    [   [u'const cv.COLORMAP_AUTUMN', u'0', [], [], None, ''],
        [u'const cv.COLORMAP_BONE', u'1', [], [], None, ''],
        [u'const cv.COLORMAP_JET', u'2', [], [], None, ''],
        [u'const cv.COLORMAP_WINTER', u'3', [], [], None, ''],
        [u'const cv.COLORMAP_RAINBOW', u'4', [], [], None, ''],
        [u'const cv.COLORMAP_OCEAN', u'5', [], [], None, ''],
        [u'const cv.COLORMAP_SUMMER', u'6', [], [], None, ''],
        [u'const cv.COLORMAP_SPRING', u'7', [], [], None, ''],
        [u'const cv.COLORMAP_COOL', u'8', [], [], None, ''],
        [u'const cv.COLORMAP_HSV', u'9', [], [], None, ''],
        [u'const cv.COLORMAP_PINK', u'10', [], [], None, ''],
        [u'const cv.COLORMAP_HOT', u'11', [], [], None, ''],
        [u'const cv.COLORMAP_PARULA', u'12', [], [], None, ''],
        [u'const cv.COLORMAP_MAGMA', u'13', [], [], None, ''],
        [u'const cv.COLORMAP_INFERNO', u'14', [], [], None, ''],
        [u'const cv.COLORMAP_PLASMA', u'15', [], [], None, ''],
        [u'const cv.COLORMAP_VIRIDIS', u'16', [], [], None, ''],
        [u'const cv.COLORMAP_CIVIDIS', u'17', [], [], None, ''],
        [u'const cv.COLORMAP_TWILIGHT', u'18', [], [], None, ''],
        [u'const cv.COLORMAP_TWILIGHT_SHIFTED', u'19', [], [], None, ''],
        [u'const cv.COLORMAP_TURBO', u'20', [], [], None, '']],
    None]
ok: CONST COLORMAP_AUTUMN=0
ok: CONST COLORMAP_BONE=1
ok: CONST COLORMAP_JET=2
ok: CONST COLORMAP_WINTER=3
ok: CONST COLORMAP_RAINBOW=4
ok: CONST COLORMAP_OCEAN=5
ok: CONST COLORMAP_SUMMER=6
ok: CONST COLORMAP_SPRING=7
ok: CONST COLORMAP_COOL=8
ok: CONST COLORMAP_HSV=9
ok: CONST COLORMAP_PINK=10
ok: CONST COLORMAP_HOT=11
ok: CONST COLORMAP_PARULA=12
ok: CONST COLORMAP_MAGMA=13
ok: CONST COLORMAP_INFERNO=14
ok: CONST COLORMAP_PLASMA=15
ok: CONST COLORMAP_VIRIDIS=16
ok: CONST COLORMAP_CIVIDIS=17
ok: CONST COLORMAP_TWILIGHT=18
ok: CONST COLORMAP_TWILIGHT_SHIFTED=19
ok: CONST COLORMAP_TURBO=20

--- Incoming ---
[   u'cv.applyColorMap',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'colormap', u'', []]],
    u'void']
ok: FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG int colormap=]>

--- Incoming ---
[   u'cv.applyColorMap',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'userColor', '', []]],
    u'void']
ok: FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG Mat userColor=]>

--- Incoming ---
[   u'cv.line',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'pt1', u'', []],
        [u'Point', u'pt2', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..line [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.arrowedLine',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'pt1', u'', []],
        [u'Point', u'pt2', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'line_type', u'8', []],
        [u'int', u'shift', u'0', []],
        [u'double', u'tipLength', u'0.1', []]],
    u'void']
ok: FUNC <void cv..arrowedLine [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int line_type=8, ARG int shift=0, ARG double tipLength=0.1]>

--- Incoming ---
[   u'cv.rectangle',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'pt1', u'', []],
        [u'Point', u'pt2', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..rectangle [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.rectangle',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Rect', u'rec', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..rectangle [ARG Mat img=, ARG Rect rec=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.circle',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'center', u'', []],
        [u'int', u'radius', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..circle [ARG Mat img=, ARG Point center=, ARG int radius=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.ellipse',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'center', u'', []],
        [u'Size', u'axes', u'', []],
        [u'double', u'angle', u'', []],
        [u'double', u'startAngle', u'', []],
        [u'double', u'endAngle', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..ellipse [ARG Mat img=, ARG Point center=, ARG Size axes=, ARG double angle=, ARG double startAngle=, ARG double endAngle=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.ellipse',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'RotatedRect', u'box', u'', ['/C', '/Ref']],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []]],
    u'void']
ok: FUNC <void cv..ellipse [ARG Mat img=, ARG RotatedRect box=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8]>

--- Incoming ---
[   u'cv.drawMarker',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'Point', u'position', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'markerType', u'MARKER_CROSS', []],
        [u'int', u'markerSize', u'20', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'line_type', u'8', []]],
    u'void']
ok: FUNC <void cv..drawMarker [ARG Mat img=, ARG Point position=, ARG Scalar color=, ARG int markerType=MARKER_CROSS, ARG int markerSize=20, ARG int thickness=1, ARG int line_type=8]>

--- Incoming ---
[   u'cv.fillConvexPoly',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        ['Mat', u'points', '', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..fillConvexPoly [ARG Mat img=, ARG vector_Point points=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.fillPoly',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        ['vector_Mat', u'pts', '', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []],
        [u'Point', u'offset', u'Point()', []]],
    u'void']
ok: FUNC <void cv..fillPoly [ARG Mat img=, ARG vector_vector_Point pts=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0, ARG Point offset=Point()]>

--- Incoming ---
[   u'cv.polylines',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        ['vector_Mat', u'pts', '', []],
        [u'bool', u'isClosed', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'int', u'shift', u'0', []]],
    u'void']
ok: FUNC <void cv..polylines [ARG Mat img=, ARG vector_vector_Point pts=, ARG bool isClosed=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>

--- Incoming ---
[   u'cv.drawContours',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['vector_Mat', u'contours', '', []],
        [u'int', u'contourIdx', u'', []],
        [u'Scalar', u'color', u'', ['/C', '/Ref']],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        ['Mat', u'hierarchy', u'Mat()', []],
        [u'int', u'maxLevel', u'INT_MAX', []],
        [u'Point', u'offset', u'Point()', []]],
    u'void']
ok: FUNC <void cv..drawContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG int contourIdx=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG Mat hierarchy=Mat(), ARG int maxLevel=INT_MAX, ARG Point offset=Point()]>

--- Incoming ---
[   u'cv.clipLine',
    u'bool',
    [],
    [   [u'Rect', u'imgRect', u'', []],
        [u'Point', u'pt1', u'', ['/O', '/IO', '/Ref']],
        [u'Point', u'pt2', u'', ['/O', '/IO', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..clipLine [ARG Rect imgRect=, ARG Point pt1=, ARG Point pt2=]>

--- Incoming ---
[   u'cv.ellipse2Poly',
    u'void',
    [],
    [   [u'Point', u'center', u'', []],
        [u'Size', u'axes', u'', []],
        [u'int', u'angle', u'', []],
        [u'int', u'arcStart', u'', []],
        [u'int', u'arcEnd', u'', []],
        [u'int', u'delta', u'', []],
        [u'vector_Point', u'pts', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv..ellipse2Poly [ARG Point center=, ARG Size axes=, ARG int angle=, ARG int arcStart=, ARG int arcEnd=, ARG int delta=, ARG vector_Point pts=]>

--- Incoming ---
[   u'cv.putText',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'String', u'text', u'', ['/C', '/Ref']],
        [u'Point', u'org', u'', []],
        [u'int', u'fontFace', u'', []],
        [u'double', u'fontScale', u'', []],
        [u'Scalar', u'color', u'', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'LINE_8', []],
        [u'bool', u'bottomLeftOrigin', u'false', []]],
    u'void']
ok: FUNC <void cv..putText [ARG Mat img=, ARG String text=, ARG Point org=, ARG int fontFace=, ARG double fontScale=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG bool bottomLeftOrigin=false]>

--- Incoming ---
[   u'cv.getTextSize',
    u'Size',
    [],
    [   [u'String', u'text', u'', ['/C', '/Ref']],
        [u'int', u'fontFace', u'', []],
        [u'double', u'fontScale', u'', []],
        [u'int', u'thickness', u'', []],
        [u'int*', u'baseLine', u'', ['/O']]],
    u'Size']
manual: FUNC <Size cv..getTextSize [ARG String text=, ARG int fontFace=, ARG double fontScale=, ARG int thickness=, ARG int * baseLine=]>

--- Incoming ---
[   u'cv.getFontScaleFromHeight',
    u'double',
    [],
    [   [u'int', u'fontFace', u'', ['/C']],
        [u'int', u'pixelHeight', u'', ['/C']],
        [u'int', u'thickness', u'1', ['/C']]],
    u'double']
ok: FUNC <double cv..getFontScaleFromHeight [ARG int fontFace=, ARG int pixelHeight=, ARG int thickness=1]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/imgproc.hpp =====
Namespaces: set(['', u'cv'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/imgproc.hpp


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/hal/hal.hpp =====
Namespaces: set(['', u'cv.hal', u'cv'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/hal/hal.hpp


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/detail/gcgraph.hpp =====
Namespaces: set(['', u'cv.detail', u'cv.hal', u'cv'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgproc/include/opencv2/imgproc/detail/gcgraph.hpp


===== Generating... =====
CLASS ::.Imgproc : 
[CONST IPL_BORDER_CONSTANT=0(manual), CONST IPL_BORDER_REPLICATE=1(manual), CONST IPL_BORDER_REFLECT=2(manual), CONST IPL_BORDER_WRAP=3(manual), CONST IPL_BORDER_REFLECT_101=4(manual), CONST IPL_BORDER_TRANSPARENT=5(manual), CONST CV_INTER_NN=0, CONST CV_INTER_LINEAR=1, CONST CV_INTER_CUBIC=2, CONST CV_INTER_AREA=3, CONST CV_INTER_LANCZOS4=4, CONST CV_MOP_ERODE=0, CONST CV_MOP_DILATE=1, CONST CV_MOP_OPEN=2, CONST CV_MOP_CLOSE=3, CONST CV_MOP_GRADIENT=4, CONST CV_MOP_TOPHAT=5, CONST CV_MOP_BLACKHAT=6, CONST CV_RETR_EXTERNAL=0, CONST CV_RETR_LIST=1, CONST CV_RETR_CCOMP=2, CONST CV_RETR_TREE=3, CONST CV_RETR_FLOODFILL=4, CONST CV_CHAIN_APPROX_NONE=1, CONST CV_CHAIN_APPROX_SIMPLE=2, CONST CV_CHAIN_APPROX_TC89_L1=3, CONST CV_CHAIN_APPROX_TC89_KCOS=4, CONST CV_THRESH_BINARY=0, CONST CV_THRESH_BINARY_INV=1, CONST CV_THRESH_TRUNC=2, CONST CV_THRESH_TOZERO=3, CONST CV_THRESH_TOZERO_INV=4, CONST CV_THRESH_MASK=7, CONST CV_THRESH_OTSU=8, CONST CV_THRESH_TRIANGLE=16]
[CONST FONT_HERSHEY_SIMPLEX=0, CONST FONT_HERSHEY_PLAIN=1, CONST FONT_HERSHEY_DUPLEX=2, CONST FONT_HERSHEY_COMPLEX=3, CONST FONT_HERSHEY_TRIPLEX=4, CONST FONT_HERSHEY_COMPLEX_SMALL=5, CONST FONT_HERSHEY_SCRIPT_SIMPLEX=6, CONST FONT_HERSHEY_SCRIPT_COMPLEX=7, CONST FONT_ITALIC=16]
[CONST INTER_BITS=5, CONST INTER_BITS2=INTER_BITS * 2, CONST INTER_TAB_SIZE=1 << INTER_BITS, CONST INTER_TAB_SIZE2=INTER_TAB_SIZE * INTER_TAB_SIZE]
[CONST MORPH_ERODE=0, CONST MORPH_DILATE=1, CONST MORPH_OPEN=2, CONST MORPH_CLOSE=3, CONST MORPH_GRADIENT=4, CONST MORPH_TOPHAT=5, CONST MORPH_BLACKHAT=6, CONST MORPH_HITMISS=7]
[CONST FLOODFILL_FIXED_RANGE=1 << 16, CONST FLOODFILL_MASK_ONLY=1 << 17]
[CONST HOUGH_STANDARD=0, CONST HOUGH_PROBABILISTIC=1, CONST HOUGH_MULTI_SCALE=2, CONST HOUGH_GRADIENT=3, CONST HOUGH_GRADIENT_ALT=4]
[CONST CCL_WU=0, CONST CCL_DEFAULT=-1, CONST CCL_GRANA=1]
[CONST RETR_EXTERNAL=0, CONST RETR_LIST=1, CONST RETR_CCOMP=2, CONST RETR_TREE=3, CONST RETR_FLOODFILL=4]
[CONST GC_BGD=0, CONST GC_FGD=1, CONST GC_PR_BGD=2, CONST GC_PR_FGD=3]
[CONST COLORMAP_AUTUMN=0, CONST COLORMAP_BONE=1, CONST COLORMAP_JET=2, CONST COLORMAP_WINTER=3, CONST COLORMAP_RAINBOW=4, CONST COLORMAP_OCEAN=5, CONST COLORMAP_SUMMER=6, CONST COLORMAP_SPRING=7, CONST COLORMAP_COOL=8, CONST COLORMAP_HSV=9, CONST COLORMAP_PINK=10, CONST COLORMAP_HOT=11, CONST COLORMAP_PARULA=12, CONST COLORMAP_MAGMA=13, CONST COLORMAP_INFERNO=14, CONST COLORMAP_PLASMA=15, CONST COLORMAP_VIRIDIS=16, CONST COLORMAP_CIVIDIS=17, CONST COLORMAP_TWILIGHT=18, CONST COLORMAP_TWILIGHT_SHIFTED=19, CONST COLORMAP_TURBO=20]
[CONST HISTCMP_CORREL=0, CONST HISTCMP_CHISQR=1, CONST HISTCMP_INTERSECT=2, CONST HISTCMP_BHATTACHARYYA=3, CONST HISTCMP_HELLINGER=HISTCMP_BHATTACHARYYA, CONST HISTCMP_CHISQR_ALT=4, CONST HISTCMP_KL_DIV=5]
[CONST FILLED=-1, CONST LINE_4=4, CONST LINE_8=8, CONST LINE_AA=16]
[CONST INTER_NEAREST=0, CONST INTER_LINEAR=1, CONST INTER_CUBIC=2, CONST INTER_AREA=3, CONST INTER_LANCZOS4=4, CONST INTER_LINEAR_EXACT=5, CONST INTER_MAX=7, CONST WARP_FILL_OUTLIERS=8, CONST WARP_INVERSE_MAP=16]
[CONST FILTER_SCHARR=-1]
[CONST CHAIN_APPROX_NONE=1, CONST CHAIN_APPROX_SIMPLE=2, CONST CHAIN_APPROX_TC89_L1=3, CONST CHAIN_APPROX_TC89_KCOS=4]
[CONST CV_GAUSSIAN_5x5=7, CONST CV_SCHARR=-1, CONST CV_MAX_SOBEL_KSIZE=7, CONST CV_RGBA2mRGBA=125, CONST CV_mRGBA2RGBA=126, CONST CV_WARP_FILL_OUTLIERS=8, CONST CV_WARP_INVERSE_MAP=16, CONST CV_CHAIN_CODE=0, CONST CV_LINK_RUNS=5, CONST CV_POLY_APPROX_DP=0, CONST CV_CONTOURS_MATCH_I1=1, CONST CV_CONTOURS_MATCH_I2=2, CONST CV_CONTOURS_MATCH_I3=3, CONST CV_CLOCKWISE=1, CONST CV_COUNTER_CLOCKWISE=2, CONST CV_COMP_CORREL=0, CONST CV_COMP_CHISQR=1, CONST CV_COMP_INTERSECT=2, CONST CV_COMP_BHATTACHARYYA=3, CONST CV_COMP_HELLINGER=CV_COMP_BHATTACHARYYA, CONST CV_COMP_CHISQR_ALT=4, CONST CV_COMP_KL_DIV=5, CONST CV_DIST_MASK_3=3, CONST CV_DIST_MASK_5=5, CONST CV_DIST_MASK_PRECISE=0, CONST CV_DIST_LABEL_CCOMP=0, CONST CV_DIST_LABEL_PIXEL=1, CONST CV_DIST_USER=-1, CONST CV_DIST_L1=1, CONST CV_DIST_L2=2, CONST CV_DIST_C=3, CONST CV_DIST_L12=4, CONST CV_DIST_FAIR=5, CONST CV_DIST_WELSCH=6, CONST CV_DIST_HUBER=7, CONST CV_CANNY_L2_GRADIENT=(1 << 31), CONST CV_HOUGH_STANDARD=0, CONST CV_HOUGH_PROBABILISTIC=1, CONST CV_HOUGH_MULTI_SCALE=2, CONST CV_HOUGH_GRADIENT=3]
[CONST CONTOURS_MATCH_I1=1, CONST CONTOURS_MATCH_I2=2, CONST CONTOURS_MATCH_I3=3]
[CONST WARP_POLAR_LINEAR=0, CONST WARP_POLAR_LOG=256]
[CONST COLOR_BGR2BGRA=0, CONST COLOR_RGB2RGBA=COLOR_BGR2BGRA, CONST COLOR_BGRA2BGR=1, CONST COLOR_RGBA2RGB=COLOR_BGRA2BGR, CONST COLOR_BGR2RGBA=2, CONST COLOR_RGB2BGRA=COLOR_BGR2RGBA, CONST COLOR_RGBA2BGR=3, CONST COLOR_BGRA2RGB=COLOR_RGBA2BGR, CONST COLOR_BGR2RGB=4, CONST COLOR_RGB2BGR=COLOR_BGR2RGB, CONST COLOR_BGRA2RGBA=5, CONST COLOR_RGBA2BGRA=COLOR_BGRA2RGBA, CONST COLOR_BGR2GRAY=6, CONST COLOR_RGB2GRAY=7, CONST COLOR_GRAY2BGR=8, CONST COLOR_GRAY2RGB=COLOR_GRAY2BGR, CONST COLOR_GRAY2BGRA=9, CONST COLOR_GRAY2RGBA=COLOR_GRAY2BGRA, CONST COLOR_BGRA2GRAY=10, CONST COLOR_RGBA2GRAY=11, CONST COLOR_BGR2BGR565=12, CONST COLOR_RGB2BGR565=13, CONST COLOR_BGR5652BGR=14, CONST COLOR_BGR5652RGB=15, CONST COLOR_BGRA2BGR565=16, CONST COLOR_RGBA2BGR565=17, CONST COLOR_BGR5652BGRA=18, CONST COLOR_BGR5652RGBA=19, CONST COLOR_GRAY2BGR565=20, CONST COLOR_BGR5652GRAY=21, CONST COLOR_BGR2BGR555=22, CONST COLOR_RGB2BGR555=23, CONST COLOR_BGR5552BGR=24, CONST COLOR_BGR5552RGB=25, CONST COLOR_BGRA2BGR555=26, CONST COLOR_RGBA2BGR555=27, CONST COLOR_BGR5552BGRA=28, CONST COLOR_BGR5552RGBA=29, CONST COLOR_GRAY2BGR555=30, CONST COLOR_BGR5552GRAY=31, CONST COLOR_BGR2XYZ=32, CONST COLOR_RGB2XYZ=33, CONST COLOR_XYZ2BGR=34, CONST COLOR_XYZ2RGB=35, CONST COLOR_BGR2YCrCb=36, CONST COLOR_RGB2YCrCb=37, CONST COLOR_YCrCb2BGR=38, CONST COLOR_YCrCb2RGB=39, CONST COLOR_BGR2HSV=40, CONST COLOR_RGB2HSV=41, CONST COLOR_BGR2Lab=44, CONST COLOR_RGB2Lab=45, CONST COLOR_BGR2Luv=50, CONST COLOR_RGB2Luv=51, CONST COLOR_BGR2HLS=52, CONST COLOR_RGB2HLS=53, CONST COLOR_HSV2BGR=54, CONST COLOR_HSV2RGB=55, CONST COLOR_Lab2BGR=56, CONST COLOR_Lab2RGB=57, CONST COLOR_Luv2BGR=58, CONST COLOR_Luv2RGB=59, CONST COLOR_HLS2BGR=60, CONST COLOR_HLS2RGB=61, CONST COLOR_BGR2HSV_FULL=66, CONST COLOR_RGB2HSV_FULL=67, CONST COLOR_BGR2HLS_FULL=68, CONST COLOR_RGB2HLS_FULL=69, CONST COLOR_HSV2BGR_FULL=70, CONST COLOR_HSV2RGB_FULL=71, CONST COLOR_HLS2BGR_FULL=72, CONST COLOR_HLS2RGB_FULL=73, CONST COLOR_LBGR2Lab=74, CONST COLOR_LRGB2Lab=75, CONST COLOR_LBGR2Luv=76, CONST COLOR_LRGB2Luv=77, CONST COLOR_Lab2LBGR=78, CONST COLOR_Lab2LRGB=79, CONST COLOR_Luv2LBGR=80, CONST COLOR_Luv2LRGB=81, CONST COLOR_BGR2YUV=82, CONST COLOR_RGB2YUV=83, CONST COLOR_YUV2BGR=84, CONST COLOR_YUV2RGB=85, CONST COLOR_YUV2RGB_NV12=90, CONST COLOR_YUV2BGR_NV12=91, CONST COLOR_YUV2RGB_NV21=92, CONST COLOR_YUV2BGR_NV21=93, CONST COLOR_YUV420sp2RGB=COLOR_YUV2RGB_NV21, CONST COLOR_YUV420sp2BGR=COLOR_YUV2BGR_NV21, CONST COLOR_YUV2RGBA_NV12=94, CONST COLOR_YUV2BGRA_NV12=95, CONST COLOR_YUV2RGBA_NV21=96, CONST COLOR_YUV2BGRA_NV21=97, CONST COLOR_YUV420sp2RGBA=COLOR_YUV2RGBA_NV21, CONST COLOR_YUV420sp2BGRA=COLOR_YUV2BGRA_NV21, CONST COLOR_YUV2RGB_YV12=98, CONST COLOR_YUV2BGR_YV12=99, CONST COLOR_YUV2RGB_IYUV=100, CONST COLOR_YUV2BGR_IYUV=101, CONST COLOR_YUV2RGB_I420=COLOR_YUV2RGB_IYUV, CONST COLOR_YUV2BGR_I420=COLOR_YUV2BGR_IYUV, CONST COLOR_YUV420p2RGB=COLOR_YUV2RGB_YV12, CONST COLOR_YUV420p2BGR=COLOR_YUV2BGR_YV12, CONST COLOR_YUV2RGBA_YV12=102, CONST COLOR_YUV2BGRA_YV12=103, CONST COLOR_YUV2RGBA_IYUV=104, CONST COLOR_YUV2BGRA_IYUV=105, CONST COLOR_YUV2RGBA_I420=COLOR_YUV2RGBA_IYUV, CONST COLOR_YUV2BGRA_I420=COLOR_YUV2BGRA_IYUV, CONST COLOR_YUV420p2RGBA=COLOR_YUV2RGBA_YV12, CONST COLOR_YUV420p2BGRA=COLOR_YUV2BGRA_YV12, CONST COLOR_YUV2GRAY_420=106, CONST COLOR_YUV2GRAY_NV21=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_NV12=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_YV12=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_IYUV=COLOR_YUV2GRAY_420, CONST COLOR_YUV2GRAY_I420=COLOR_YUV2GRAY_420, CONST COLOR_YUV420sp2GRAY=COLOR_YUV2GRAY_420, CONST COLOR_YUV420p2GRAY=COLOR_YUV2GRAY_420, CONST COLOR_YUV2RGB_UYVY=107, CONST COLOR_YUV2BGR_UYVY=108, CONST COLOR_YUV2RGB_Y422=COLOR_YUV2RGB_UYVY, CONST COLOR_YUV2BGR_Y422=COLOR_YUV2BGR_UYVY, CONST COLOR_YUV2RGB_UYNV=COLOR_YUV2RGB_UYVY, CONST COLOR_YUV2BGR_UYNV=COLOR_YUV2BGR_UYVY, CONST COLOR_YUV2RGBA_UYVY=111, CONST COLOR_YUV2BGRA_UYVY=112, CONST COLOR_YUV2RGBA_Y422=COLOR_YUV2RGBA_UYVY, CONST COLOR_YUV2BGRA_Y422=COLOR_YUV2BGRA_UYVY, CONST COLOR_YUV2RGBA_UYNV=COLOR_YUV2RGBA_UYVY, CONST COLOR_YUV2BGRA_UYNV=COLOR_YUV2BGRA_UYVY, CONST COLOR_YUV2RGB_YUY2=115, CONST COLOR_YUV2BGR_YUY2=116, CONST COLOR_YUV2RGB_YVYU=117, CONST COLOR_YUV2BGR_YVYU=118, CONST COLOR_YUV2RGB_YUYV=COLOR_YUV2RGB_YUY2, CONST COLOR_YUV2BGR_YUYV=COLOR_YUV2BGR_YUY2, CONST COLOR_YUV2RGB_YUNV=COLOR_YUV2RGB_YUY2, CONST COLOR_YUV2BGR_YUNV=COLOR_YUV2BGR_YUY2, CONST COLOR_YUV2RGBA_YUY2=119, CONST COLOR_YUV2BGRA_YUY2=120, CONST COLOR_YUV2RGBA_YVYU=121, CONST COLOR_YUV2BGRA_YVYU=122, CONST COLOR_YUV2RGBA_YUYV=COLOR_YUV2RGBA_YUY2, CONST COLOR_YUV2BGRA_YUYV=COLOR_YUV2BGRA_YUY2, CONST COLOR_YUV2RGBA_YUNV=COLOR_YUV2RGBA_YUY2, CONST COLOR_YUV2BGRA_YUNV=COLOR_YUV2BGRA_YUY2, CONST COLOR_YUV2GRAY_UYVY=123, CONST COLOR_YUV2GRAY_YUY2=124, CONST COLOR_YUV2GRAY_Y422=COLOR_YUV2GRAY_UYVY, CONST COLOR_YUV2GRAY_UYNV=COLOR_YUV2GRAY_UYVY, CONST COLOR_YUV2GRAY_YVYU=COLOR_YUV2GRAY_YUY2, CONST COLOR_YUV2GRAY_YUYV=COLOR_YUV2GRAY_YUY2, CONST COLOR_YUV2GRAY_YUNV=COLOR_YUV2GRAY_YUY2, CONST COLOR_RGBA2mRGBA=125, CONST COLOR_mRGBA2RGBA=126, CONST COLOR_RGB2YUV_I420=127, CONST COLOR_BGR2YUV_I420=128, CONST COLOR_RGB2YUV_IYUV=COLOR_RGB2YUV_I420, CONST COLOR_BGR2YUV_IYUV=COLOR_BGR2YUV_I420, CONST COLOR_RGBA2YUV_I420=129, CONST COLOR_BGRA2YUV_I420=130, CONST COLOR_RGBA2YUV_IYUV=COLOR_RGBA2YUV_I420, CONST COLOR_BGRA2YUV_IYUV=COLOR_BGRA2YUV_I420, CONST COLOR_RGB2YUV_YV12=131, CONST COLOR_BGR2YUV_YV12=132, CONST COLOR_RGBA2YUV_YV12=133, CONST COLOR_BGRA2YUV_YV12=134, CONST COLOR_BayerBG2BGR=46, CONST COLOR_BayerGB2BGR=47, CONST COLOR_BayerRG2BGR=48, CONST COLOR_BayerGR2BGR=49, CONST COLOR_BayerBG2RGB=COLOR_BayerRG2BGR, CONST COLOR_BayerGB2RGB=COLOR_BayerGR2BGR, CONST COLOR_BayerRG2RGB=COLOR_BayerBG2BGR, CONST COLOR_BayerGR2RGB=COLOR_BayerGB2BGR, CONST COLOR_BayerBG2GRAY=86, CONST COLOR_BayerGB2GRAY=87, CONST COLOR_BayerRG2GRAY=88, CONST COLOR_BayerGR2GRAY=89, CONST COLOR_BayerBG2BGR_VNG=62, CONST COLOR_BayerGB2BGR_VNG=63, CONST COLOR_BayerRG2BGR_VNG=64, CONST COLOR_BayerGR2BGR_VNG=65, CONST COLOR_BayerBG2RGB_VNG=COLOR_BayerRG2BGR_VNG, CONST COLOR_BayerGB2RGB_VNG=COLOR_BayerGR2BGR_VNG, CONST COLOR_BayerRG2RGB_VNG=COLOR_BayerBG2BGR_VNG, CONST COLOR_BayerGR2RGB_VNG=COLOR_BayerGB2BGR_VNG, CONST COLOR_BayerBG2BGR_EA=135, CONST COLOR_BayerGB2BGR_EA=136, CONST COLOR_BayerRG2BGR_EA=137, CONST COLOR_BayerGR2BGR_EA=138, CONST COLOR_BayerBG2RGB_EA=COLOR_BayerRG2BGR_EA, CONST COLOR_BayerGB2RGB_EA=COLOR_BayerGR2BGR_EA, CONST COLOR_BayerRG2RGB_EA=COLOR_BayerBG2BGR_EA, CONST COLOR_BayerGR2RGB_EA=COLOR_BayerGB2BGR_EA, CONST COLOR_BayerBG2BGRA=139, CONST COLOR_BayerGB2BGRA=140, CONST COLOR_BayerRG2BGRA=141, CONST COLOR_BayerGR2BGRA=142, CONST COLOR_BayerBG2RGBA=COLOR_BayerRG2BGRA, CONST COLOR_BayerGB2RGBA=COLOR_BayerGR2BGRA, CONST COLOR_BayerRG2RGBA=COLOR_BayerBG2BGRA, CONST COLOR_BayerGR2RGBA=COLOR_BayerGB2BGRA, CONST COLOR_COLORCVT_MAX=143]
[CONST LSD_REFINE_NONE=0, CONST LSD_REFINE_STD=1, CONST LSD_REFINE_ADV=2]
[CONST THRESH_BINARY=0, CONST THRESH_BINARY_INV=1, CONST THRESH_TRUNC=2, CONST THRESH_TOZERO=3, CONST THRESH_TOZERO_INV=4, CONST THRESH_MASK=7, CONST THRESH_OTSU=8, CONST THRESH_TRIANGLE=16]
[CONST ADAPTIVE_THRESH_MEAN_C=0, CONST ADAPTIVE_THRESH_GAUSSIAN_C=1]
[CONST CV_SHAPE_RECT=0, CONST CV_SHAPE_CROSS=1, CONST CV_SHAPE_ELLIPSE=2, CONST CV_SHAPE_CUSTOM=100]
[CONST INTERSECT_NONE=0, CONST INTERSECT_PARTIAL=1, CONST INTERSECT_FULL=2]
[CONST GC_INIT_WITH_RECT=0, CONST GC_INIT_WITH_MASK=1, CONST GC_EVAL=2, CONST GC_EVAL_FREEZE_MODEL=3]
[CONST MORPH_RECT=0, CONST MORPH_CROSS=1, CONST MORPH_ELLIPSE=2]
[CONST DIST_LABEL_CCOMP=0, CONST DIST_LABEL_PIXEL=1]
[CONST DIST_USER=-1, CONST DIST_L1=1, CONST DIST_L2=2, CONST DIST_C=3, CONST DIST_L12=4, CONST DIST_FAIR=5, CONST DIST_WELSCH=6, CONST DIST_HUBER=7]
[CONST TM_SQDIFF=0, CONST TM_SQDIFF_NORMED=1, CONST TM_CCORR=2, CONST TM_CCORR_NORMED=3, CONST TM_CCOEFF=4, CONST TM_CCOEFF_NORMED=5]
[CONST DIST_MASK_3=3, CONST DIST_MASK_5=5, CONST DIST_MASK_PRECISE=0]
[CONST CC_STAT_LEFT=0, CONST CC_STAT_TOP=1, CONST CC_STAT_WIDTH=2, CONST CC_STAT_HEIGHT=3, CONST CC_STAT_AREA=4, CONST CC_STAT_MAX=5]
[CONST CV_BLUR_NO_SCALE=0, CONST CV_BLUR=1, CONST CV_GAUSSIAN=2, CONST CV_MEDIAN=3, CONST CV_BILATERAL=4]
[CONST MARKER_CROSS=0, CONST MARKER_TILTED_CROSS=1, CONST MARKER_STAR=2, CONST MARKER_DIAMOND=3, CONST MARKER_SQUARE=4, CONST MARKER_TRIANGLE_UP=5, CONST MARKER_TRIANGLE_DOWN=6]
FUNC <Mat cv..getAffineTransform [ARG vector_Point2f src=, ARG vector_Point2f dst=]>
java: Mat getAffineTransform(MatOfPoint2f src, MatOfPoint2f dst)
FUNC <Mat cv..getGaborKernel [ARG Size ksize=, ARG double sigma=, ARG double theta=, ARG double lambd=, ARG double gamma=, ARG double psi=CV_PI*0.5, ARG int ktype=CV_64F]>
java: Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma, double psi, int ktype)
java: Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma, double psi)
java: Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma)
FUNC <Mat cv..getGaussianKernel [ARG int ksize=, ARG double sigma=, ARG int ktype=CV_64F]>
java: Mat getGaussianKernel(int ksize, double sigma, int ktype)
java: Mat getGaussianKernel(int ksize, double sigma)
FUNC <Mat cv..getPerspectiveTransform [ARG Mat src=, ARG Mat dst=, ARG int solveMethod=DECOMP_LU]>
java: Mat getPerspectiveTransform(Mat src, Mat dst, int solveMethod)
java: Mat getPerspectiveTransform(Mat src, Mat dst)
FUNC <Mat cv..getRotationMatrix2D [ARG Point2f center=, ARG double angle=, ARG double scale=]>
java: Mat getRotationMatrix2D(Point center, double angle, double scale)
FUNC <Mat cv..getStructuringElement [ARG int shape=, ARG Size ksize=, ARG Point anchor=Point(-1,-1)]>
java: Mat getStructuringElement(int shape, Size ksize, Point anchor)
java: Mat getStructuringElement(int shape, Size ksize)
FUNC <Moments cv..moments [ARG Mat array=, ARG bool binaryImage=false]>
java: Moments moments(Mat array, boolean binaryImage)
java: Moments moments(Mat array)
FUNC <Point2d cv..phaseCorrelate [ARG Mat src1=, ARG Mat src2=, ARG Mat window=Mat(), ARG double * response=0]>
java: Point phaseCorrelate(Mat src1, Mat src2, Mat window, double[] response)
java: Point phaseCorrelate(Mat src1, Mat src2, Mat window)
java: Point phaseCorrelate(Mat src1, Mat src2)
FUNC <Ptr_CLAHE cv..createCLAHE [ARG double clipLimit=40.0, ARG Size tileGridSize=Size(8, 8)]>
java: CLAHE createCLAHE(double clipLimit, Size tileGridSize)
java: CLAHE createCLAHE(double clipLimit)
java: CLAHE createCLAHE()
FUNC <Ptr_GeneralizedHoughBallard cv..createGeneralizedHoughBallard []>
java: GeneralizedHoughBallard createGeneralizedHoughBallard()
FUNC <Ptr_GeneralizedHoughGuil cv..createGeneralizedHoughGuil []>
java: GeneralizedHoughGuil createGeneralizedHoughGuil()
FUNC <Ptr_LineSegmentDetector cv..createLineSegmentDetector [ARG int _refine=LSD_REFINE_STD, ARG double _scale=0.8, ARG double _sigma_scale=0.6, ARG double _quant=2.0, ARG double _ang_th=22.5, ARG double _log_eps=0, ARG double _density_th=0.7, ARG int _n_bins=1024]>
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th, double _log_eps, double _density_th, int _n_bins)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th, double _log_eps, double _density_th)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th, double _log_eps)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale, double _quant, double _ang_th)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale, double _quant)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale, double _sigma_scale)
java: LineSegmentDetector createLineSegmentDetector(int _refine, double _scale)
java: LineSegmentDetector createLineSegmentDetector(int _refine)
java: LineSegmentDetector createLineSegmentDetector()
FUNC <Rect cv..boundingRect [ARG Mat array=]>
java: Rect boundingRect(Mat array)
FUNC <RotatedRect cv..fitEllipse [ARG vector_Point2f points=]>
java: RotatedRect fitEllipse(MatOfPoint2f points)
FUNC <RotatedRect cv..fitEllipseAMS [ARG Mat points=]>
java: RotatedRect fitEllipseAMS(Mat points)
FUNC <RotatedRect cv..fitEllipseDirect [ARG Mat points=]>
java: RotatedRect fitEllipseDirect(Mat points)
FUNC <RotatedRect cv..minAreaRect [ARG vector_Point2f points=]>
java: RotatedRect minAreaRect(MatOfPoint2f points)
FUNC <bool cv..clipLine [ARG Rect imgRect=, ARG Point pt1=, ARG Point pt2=]>
java: boolean clipLine(Rect imgRect, Point pt1, Point pt2)
FUNC <bool cv..isContourConvex [ARG vector_Point contour=]>
java: boolean isContourConvex(MatOfPoint contour)
FUNC <double cv..arcLength [ARG vector_Point2f curve=, ARG bool closed=]>
java: double arcLength(MatOfPoint2f curve, boolean closed)
FUNC <double cv..compareHist [ARG Mat H1=, ARG Mat H2=, ARG int method=]>
java: double compareHist(Mat H1, Mat H2, int method)
FUNC <double cv..contourArea [ARG Mat contour=, ARG bool oriented=false]>
java: double contourArea(Mat contour, boolean oriented)
java: double contourArea(Mat contour)
FUNC <double cv..getFontScaleFromHeight [ARG int fontFace=, ARG int pixelHeight=, ARG int thickness=1]>
java: double getFontScaleFromHeight(int fontFace, int pixelHeight, int thickness)
java: double getFontScaleFromHeight(int fontFace, int pixelHeight)
FUNC <double cv..matchShapes [ARG Mat contour1=, ARG Mat contour2=, ARG int method=, ARG double parameter=]>
java: double matchShapes(Mat contour1, Mat contour2, int method, double parameter)
FUNC <double cv..minEnclosingTriangle [ARG Mat points=, ARG Mat triangle=]>
java: double minEnclosingTriangle(Mat points, Mat triangle)
FUNC <double cv..pointPolygonTest [ARG vector_Point2f contour=, ARG Point2f pt=, ARG bool measureDist=]>
java: double pointPolygonTest(MatOfPoint2f contour, Point pt, boolean measureDist)
FUNC <double cv..threshold [ARG Mat src=, ARG Mat dst=, ARG double thresh=, ARG double maxval=, ARG int type=]>
java: double threshold(Mat src, Mat dst, double thresh, double maxval, int type)
FUNC <float cv..intersectConvexConvex [ARG Mat _p1=, ARG Mat _p2=, ARG Mat _p12=, ARG bool handleNested=true]>
java: float intersectConvexConvex(Mat _p1, Mat _p2, Mat _p12, boolean handleNested)
java: float intersectConvexConvex(Mat _p1, Mat _p2, Mat _p12)
FUNC <float cv..wrapperEMD [ARG Mat signature1=, ARG Mat signature2=, ARG int distType=, ARG Mat cost=Mat(), ARG Ptr_float lowerBound=Ptr<float>(), ARG Mat flow=Mat()]>
java: float EMD(Mat signature1, Mat signature2, int distType, Mat cost, Mat flow)
java: float EMD(Mat signature1, Mat signature2, int distType, Mat cost)
java: float EMD(Mat signature1, Mat signature2, int distType, Mat cost)
java: float EMD(Mat signature1, Mat signature2, int distType)
FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>
java: int connectedComponentsWithAlgorithm(Mat image, Mat labels, int connectivity, int ltype, int ccltype)
FUNC <int cv..connectedComponents [ARG Mat image=, ARG Mat labels=, ARG int connectivity=8, ARG int ltype=CV_32S]>
java: int connectedComponents(Mat image, Mat labels, int connectivity, int ltype)
java: int connectedComponents(Mat image, Mat labels, int connectivity)
java: int connectedComponents(Mat image, Mat labels)
FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=, ARG int ltype=, ARG int ccltype=]>
java: int connectedComponentsWithStatsWithAlgorithm(Mat image, Mat labels, Mat stats, Mat centroids, int connectivity, int ltype, int ccltype)
FUNC <int cv..connectedComponentsWithStats [ARG Mat image=, ARG Mat labels=, ARG Mat stats=, ARG Mat centroids=, ARG int connectivity=8, ARG int ltype=CV_32S]>
java: int connectedComponentsWithStats(Mat image, Mat labels, Mat stats, Mat centroids, int connectivity, int ltype)
java: int connectedComponentsWithStats(Mat image, Mat labels, Mat stats, Mat centroids, int connectivity)
java: int connectedComponentsWithStats(Mat image, Mat labels, Mat stats, Mat centroids)
FUNC <int cv..floodFill [ARG Mat image=, ARG Mat mask=, ARG Point seedPoint=, ARG Scalar newVal=, ARG Rect * rect=0, ARG Scalar loDiff=Scalar(), ARG Scalar upDiff=Scalar(), ARG int flags=4]>
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect, Scalar loDiff, Scalar upDiff, int flags)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect, Scalar loDiff, Scalar upDiff)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect, Scalar loDiff)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal, Rect rect)
java: int floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal)
FUNC <int cv..rotatedRectangleIntersection [ARG RotatedRect rect1=, ARG RotatedRect rect2=, ARG Mat intersectingRegion=]>
java: int rotatedRectangleIntersection(RotatedRect rect1, RotatedRect rect2, Mat intersectingRegion)
FUNC <void cv..Canny [ARG Mat dx=, ARG Mat dy=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG bool L2gradient=false]>
java: void Canny(Mat dx, Mat dy, Mat edges, double threshold1, double threshold2, boolean L2gradient)
java: void Canny(Mat dx, Mat dy, Mat edges, double threshold1, double threshold2)
FUNC <void cv..Canny [ARG Mat image=, ARG Mat edges=, ARG double threshold1=, ARG double threshold2=, ARG int apertureSize=3, ARG bool L2gradient=false]>
java: void Canny(Mat image, Mat edges, double threshold1, double threshold2, int apertureSize, boolean L2gradient)
java: void Canny(Mat image, Mat edges, double threshold1, double threshold2, int apertureSize)
java: void Canny(Mat image, Mat edges, double threshold1, double threshold2)
FUNC <void cv..GaussianBlur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG double sigmaX=, ARG double sigmaY=0, ARG int borderType=BORDER_DEFAULT]>
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX, double sigmaY, int borderType)
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX, double sigmaY)
java: void GaussianBlur(Mat src, Mat dst, Size ksize, double sigmaX)
FUNC <void cv..HoughCircles [ARG Mat image=, ARG Mat circles=, ARG int method=, ARG double dp=, ARG double minDist=, ARG double param1=100, ARG double param2=100, ARG int minRadius=0, ARG int maxRadius=0]>
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1, double param2, int minRadius, int maxRadius)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1, double param2, int minRadius)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1, double param2)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist, double param1)
java: void HoughCircles(Mat image, Mat circles, int method, double dp, double minDist)
FUNC <void cv..HoughLines [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double srn=0, ARG double stn=0, ARG double min_theta=0, ARG double max_theta=CV_PI]>
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn, double min_theta, double max_theta)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn, double min_theta)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn, double stn)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold, double srn)
java: void HoughLines(Mat image, Mat lines, double rho, double theta, int threshold)
FUNC <void cv..HoughLinesP [ARG Mat image=, ARG Mat lines=, ARG double rho=, ARG double theta=, ARG int threshold=, ARG double minLineLength=0, ARG double maxLineGap=0]>
java: void HoughLinesP(Mat image, Mat lines, double rho, double theta, int threshold, double minLineLength, double maxLineGap)
java: void HoughLinesP(Mat image, Mat lines, double rho, double theta, int threshold, double minLineLength)
java: void HoughLinesP(Mat image, Mat lines, double rho, double theta, int threshold)
FUNC <void cv..HoughLinesPointSet [ARG Mat _point=, ARG Mat _lines=, ARG int lines_max=, ARG int threshold=, ARG double min_rho=, ARG double max_rho=, ARG double rho_step=, ARG double min_theta=, ARG double max_theta=, ARG double theta_step=]>
java: void HoughLinesPointSet(Mat _point, Mat _lines, int lines_max, int threshold, double min_rho, double max_rho, double rho_step, double min_theta, double max_theta, double theta_step)
FUNC <void cv..HuMoments [ARG Moments m=, ARG Mat hu=]>
java: void HuMoments(Moments m, Mat hu)
FUNC <void cv..Laplacian [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int ksize=1, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize, double scale, double delta, int borderType)
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize, double scale, double delta)
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize, double scale)
java: void Laplacian(Mat src, Mat dst, int ddepth, int ksize)
java: void Laplacian(Mat src, Mat dst, int ddepth)
FUNC <void cv..Scharr [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy, double scale, double delta)
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy, double scale)
java: void Scharr(Mat src, Mat dst, int ddepth, int dx, int dy)
FUNC <void cv..Sobel [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG int dx=, ARG int dy=, ARG int ksize=3, ARG double scale=1, ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize, double scale, double delta)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize, double scale)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy, int ksize)
java: void Sobel(Mat src, Mat dst, int ddepth, int dx, int dy)
FUNC <void cv..accumulate [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulate(Mat src, Mat dst, Mat mask)
java: void accumulate(Mat src, Mat dst)
FUNC <void cv..accumulateProduct [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulateProduct(Mat src1, Mat src2, Mat dst, Mat mask)
java: void accumulateProduct(Mat src1, Mat src2, Mat dst)
FUNC <void cv..accumulateSquare [ARG Mat src=, ARG Mat dst=, ARG Mat mask=Mat()]>
java: void accumulateSquare(Mat src, Mat dst, Mat mask)
java: void accumulateSquare(Mat src, Mat dst)
FUNC <void cv..accumulateWeighted [ARG Mat src=, ARG Mat dst=, ARG double alpha=, ARG Mat mask=Mat()]>
java: void accumulateWeighted(Mat src, Mat dst, double alpha, Mat mask)
java: void accumulateWeighted(Mat src, Mat dst, double alpha)
FUNC <void cv..adaptiveThreshold [ARG Mat src=, ARG Mat dst=, ARG double maxValue=, ARG int adaptiveMethod=, ARG int thresholdType=, ARG int blockSize=, ARG double C=]>
java: void adaptiveThreshold(Mat src, Mat dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)
FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG Mat userColor=]>
java: void applyColorMap(Mat src, Mat dst, Mat userColor)
FUNC <void cv..applyColorMap [ARG Mat src=, ARG Mat dst=, ARG int colormap=]>
java: void applyColorMap(Mat src, Mat dst, int colormap)
FUNC <void cv..approxPolyDP [ARG vector_Point2f curve=, ARG vector_Point2f approxCurve=, ARG double epsilon=, ARG bool closed=]>
java: void approxPolyDP(MatOfPoint2f curve, MatOfPoint2f approxCurve, double epsilon, boolean closed)
FUNC <void cv..arrowedLine [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int line_type=8, ARG int shift=0, ARG double tipLength=0.1]>
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int line_type, int shift, double tipLength)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int line_type, int shift)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int line_type)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color, int thickness)
java: void arrowedLine(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..bilateralFilter [ARG Mat src=, ARG Mat dst=, ARG int d=, ARG double sigmaColor=, ARG double sigmaSpace=, ARG int borderType=BORDER_DEFAULT]>
java: void bilateralFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace, int borderType)
java: void bilateralFilter(Mat src, Mat dst, int d, double sigmaColor, double sigmaSpace)
FUNC <void cv..blur [ARG Mat src=, ARG Mat dst=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG int borderType=BORDER_DEFAULT]>
java: void blur(Mat src, Mat dst, Size ksize, Point anchor, int borderType)
java: void blur(Mat src, Mat dst, Size ksize, Point anchor)
java: void blur(Mat src, Mat dst, Size ksize)
FUNC <void cv..boxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1,-1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize, int borderType)
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize)
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor)
java: void boxFilter(Mat src, Mat dst, int ddepth, Size ksize)
FUNC <void cv..boxPoints [ARG RotatedRect box=, ARG Mat points=]>
java: void boxPoints(RotatedRect box, Mat points)
FUNC <void cv..calcBackProject [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat hist=, ARG Mat dst=, ARG vector_float ranges=, ARG double scale=]>
java: void calcBackProject(List<Mat> images, MatOfInt channels, Mat hist, Mat dst, MatOfFloat ranges, double scale)
FUNC <void cv..calcHist [ARG vector_Mat images=, ARG vector_int channels=, ARG Mat mask=, ARG Mat hist=, ARG vector_int histSize=, ARG vector_float ranges=, ARG bool accumulate=false]>
java: void calcHist(List<Mat> images, MatOfInt channels, Mat mask, Mat hist, MatOfInt histSize, MatOfFloat ranges, boolean accumulate)
java: void calcHist(List<Mat> images, MatOfInt channels, Mat mask, Mat hist, MatOfInt histSize, MatOfFloat ranges)
FUNC <void cv..circle [ARG Mat img=, ARG Point center=, ARG int radius=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void circle(Mat img, Point center, int radius, Scalar color, int thickness, int lineType, int shift)
java: void circle(Mat img, Point center, int radius, Scalar color, int thickness, int lineType)
java: void circle(Mat img, Point center, int radius, Scalar color, int thickness)
java: void circle(Mat img, Point center, int radius, Scalar color)
FUNC <void cv..convertMaps [ARG Mat map1=, ARG Mat map2=, ARG Mat dstmap1=, ARG Mat dstmap2=, ARG int dstmap1type=, ARG bool nninterpolation=false]>
java: void convertMaps(Mat map1, Mat map2, Mat dstmap1, Mat dstmap2, int dstmap1type, boolean nninterpolation)
java: void convertMaps(Mat map1, Mat map2, Mat dstmap1, Mat dstmap2, int dstmap1type)
FUNC <void cv..convexHull [ARG vector_Point points=, ARG vector_int hull=, ARG bool clockwise=false, ARG  returnPoints=true]>
java: void convexHull(MatOfPoint points, MatOfInt hull, boolean clockwise)
java: void convexHull(MatOfPoint points, MatOfInt hull, boolean clockwise)
java: void convexHull(MatOfPoint points, MatOfInt hull)
FUNC <void cv..convexityDefects [ARG vector_Point contour=, ARG vector_int convexhull=, ARG vector_Vec4i convexityDefects=]>
java: void convexityDefects(MatOfPoint contour, MatOfInt convexhull, MatOfInt4 convexityDefects)
FUNC <void cv..cornerEigenValsAndVecs [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>
java: void cornerEigenValsAndVecs(Mat src, Mat dst, int blockSize, int ksize, int borderType)
java: void cornerEigenValsAndVecs(Mat src, Mat dst, int blockSize, int ksize)
FUNC <void cv..cornerHarris [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=, ARG double k=, ARG int borderType=BORDER_DEFAULT]>
java: void cornerHarris(Mat src, Mat dst, int blockSize, int ksize, double k, int borderType)
java: void cornerHarris(Mat src, Mat dst, int blockSize, int ksize, double k)
FUNC <void cv..cornerMinEigenVal [ARG Mat src=, ARG Mat dst=, ARG int blockSize=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize, int ksize, int borderType)
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize, int ksize)
java: void cornerMinEigenVal(Mat src, Mat dst, int blockSize)
FUNC <void cv..cornerSubPix [ARG Mat image=, ARG Mat corners=, ARG Size winSize=, ARG Size zeroZone=, ARG TermCriteria criteria=]>
java: void cornerSubPix(Mat image, Mat corners, Size winSize, Size zeroZone, TermCriteria criteria)
FUNC <void cv..createHanningWindow [ARG Mat dst=, ARG Size winSize=, ARG int type=]>
java: void createHanningWindow(Mat dst, Size winSize, int type)
FUNC <void cv..cvtColor [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>
java: void cvtColor(Mat src, Mat dst, int code, int dstCn)
java: void cvtColor(Mat src, Mat dst, int code)
FUNC <void cv..cvtColorTwoPlane [ARG Mat src1=, ARG Mat src2=, ARG Mat dst=, ARG int code=]>
java: void cvtColorTwoPlane(Mat src1, Mat src2, Mat dst, int code)
FUNC <void cv..demosaicing [ARG Mat src=, ARG Mat dst=, ARG int code=, ARG int dstCn=0]>
java: void demosaicing(Mat src, Mat dst, int code, int dstCn)
java: void demosaicing(Mat src, Mat dst, int code)
FUNC <void cv..dilate [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType)
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor, int iterations)
java: void dilate(Mat src, Mat dst, Mat kernel, Point anchor)
java: void dilate(Mat src, Mat dst, Mat kernel)
FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG Mat labels=, ARG int distanceType=, ARG int maskSize=, ARG int labelType=DIST_LABEL_CCOMP]>
java: void distanceTransformWithLabels(Mat src, Mat dst, Mat labels, int distanceType, int maskSize, int labelType)
java: void distanceTransformWithLabels(Mat src, Mat dst, Mat labels, int distanceType, int maskSize)
FUNC <void cv..distanceTransform [ARG Mat src=, ARG Mat dst=, ARG int distanceType=, ARG int maskSize=, ARG int dstType=CV_32F]>
java: void distanceTransform(Mat src, Mat dst, int distanceType, int maskSize, int dstType)
java: void distanceTransform(Mat src, Mat dst, int distanceType, int maskSize)
FUNC <void cv..drawContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG int contourIdx=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG Mat hierarchy=Mat(), ARG int maxLevel=INT_MAX, ARG Point offset=Point()]>
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType, Mat hierarchy, int maxLevel, Point offset)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType, Mat hierarchy, int maxLevel)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType, Mat hierarchy)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness, int lineType)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color, int thickness)
java: void drawContours(Mat image, List<MatOfPoint> contours, int contourIdx, Scalar color)
FUNC <void cv..drawMarker [ARG Mat img=, ARG Point position=, ARG Scalar color=, ARG int markerType=MARKER_CROSS, ARG int markerSize=20, ARG int thickness=1, ARG int line_type=8]>
java: void drawMarker(Mat img, Point position, Scalar color, int markerType, int markerSize, int thickness, int line_type)
java: void drawMarker(Mat img, Point position, Scalar color, int markerType, int markerSize, int thickness)
java: void drawMarker(Mat img, Point position, Scalar color, int markerType, int markerSize)
java: void drawMarker(Mat img, Point position, Scalar color, int markerType)
java: void drawMarker(Mat img, Point position, Scalar color)
FUNC <void cv..ellipse [ARG Mat img=, ARG Point center=, ARG Size axes=, ARG double angle=, ARG double startAngle=, ARG double endAngle=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness, int lineType, int shift)
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness, int lineType)
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness)
java: void ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color)
FUNC <void cv..ellipse [ARG Mat img=, ARG RotatedRect box=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8]>
java: void ellipse(Mat img, RotatedRect box, Scalar color, int thickness, int lineType)
java: void ellipse(Mat img, RotatedRect box, Scalar color, int thickness)
java: void ellipse(Mat img, RotatedRect box, Scalar color)
FUNC <void cv..ellipse2Poly [ARG Point center=, ARG Size axes=, ARG int angle=, ARG int arcStart=, ARG int arcEnd=, ARG int delta=, ARG vector_Point pts=]>
java: void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, MatOfPoint pts)
FUNC <void cv..equalizeHist [ARG Mat src=, ARG Mat dst=]>
java: void equalizeHist(Mat src, Mat dst)
FUNC <void cv..erode [ARG Mat src=, ARG Mat dst=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor, int iterations, int borderType)
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor, int iterations)
java: void erode(Mat src, Mat dst, Mat kernel, Point anchor)
java: void erode(Mat src, Mat dst, Mat kernel)
FUNC <void cv..fillConvexPoly [ARG Mat img=, ARG vector_Point points=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0]>
java: void fillConvexPoly(Mat img, MatOfPoint points, Scalar color, int lineType, int shift)
java: void fillConvexPoly(Mat img, MatOfPoint points, Scalar color, int lineType)
java: void fillConvexPoly(Mat img, MatOfPoint points, Scalar color)
FUNC <void cv..fillPoly [ARG Mat img=, ARG vector_vector_Point pts=, ARG Scalar color=, ARG int lineType=LINE_8, ARG int shift=0, ARG Point offset=Point()]>
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color, int lineType, int shift, Point offset)
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color, int lineType, int shift)
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color, int lineType)
java: void fillPoly(Mat img, List<MatOfPoint> pts, Scalar color)
FUNC <void cv..filter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel, Point anchor, double delta, int borderType)
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel, Point anchor, double delta)
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel, Point anchor)
java: void filter2D(Mat src, Mat dst, int ddepth, Mat kernel)
FUNC <void cv..findContours [ARG Mat image=, ARG vector_vector_Point contours=, ARG Mat hierarchy=, ARG int mode=, ARG int method=, ARG Point offset=Point()]>
java: void findContours(Mat image, List<MatOfPoint> contours, Mat hierarchy, int mode, int method, Point offset)
java: void findContours(Mat image, List<MatOfPoint> contours, Mat hierarchy, int mode, int method)
FUNC <void cv..fitLine [ARG Mat points=, ARG Mat line=, ARG int distType=, ARG double param=, ARG double reps=, ARG double aeps=]>
java: void fitLine(Mat points, Mat line, int distType, double param, double reps, double aeps)
FUNC <void cv..getDerivKernels [ARG Mat kx=, ARG Mat ky=, ARG int dx=, ARG int dy=, ARG int ksize=, ARG bool normalize=false, ARG int ktype=CV_32F]>
java: void getDerivKernels(Mat kx, Mat ky, int dx, int dy, int ksize, boolean normalize, int ktype)
java: void getDerivKernels(Mat kx, Mat ky, int dx, int dy, int ksize, boolean normalize)
java: void getDerivKernels(Mat kx, Mat ky, int dx, int dy, int ksize)
FUNC <void cv..getRectSubPix [ARG Mat image=, ARG Size patchSize=, ARG Point2f center=, ARG Mat patch=, ARG int patchType=-1]>
java: void getRectSubPix(Mat image, Size patchSize, Point center, Mat patch, int patchType)
java: void getRectSubPix(Mat image, Size patchSize, Point center, Mat patch)
FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=, ARG int blockSize=, ARG int gradientSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, int gradientSize, boolean useHarrisDetector, double k)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, int gradientSize, boolean useHarrisDetector)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, int gradientSize)
FUNC <void cv..goodFeaturesToTrack [ARG Mat image=, ARG vector_Point corners=, ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG Mat mask=Mat(), ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, boolean useHarrisDetector, double k)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize, boolean useHarrisDetector)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask, int blockSize)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance, Mat mask)
java: void goodFeaturesToTrack(Mat image, MatOfPoint corners, int maxCorners, double qualityLevel, double minDistance)
FUNC <void cv..grabCut [ARG Mat img=, ARG Mat mask=, ARG Rect rect=, ARG Mat bgdModel=, ARG Mat fgdModel=, ARG int iterCount=, ARG int mode=GC_EVAL]>
java: void grabCut(Mat img, Mat mask, Rect rect, Mat bgdModel, Mat fgdModel, int iterCount, int mode)
java: void grabCut(Mat img, Mat mask, Rect rect, Mat bgdModel, Mat fgdModel, int iterCount)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG Mat tilted=, ARG int sdepth=-1, ARG int sqdepth=-1]>
java: void integral3(Mat src, Mat sum, Mat sqsum, Mat tilted, int sdepth, int sqdepth)
java: void integral3(Mat src, Mat sum, Mat sqsum, Mat tilted, int sdepth)
java: void integral3(Mat src, Mat sum, Mat sqsum, Mat tilted)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG Mat sqsum=, ARG int sdepth=-1, ARG int sqdepth=-1]>
java: void integral2(Mat src, Mat sum, Mat sqsum, int sdepth, int sqdepth)
java: void integral2(Mat src, Mat sum, Mat sqsum, int sdepth)
java: void integral2(Mat src, Mat sum, Mat sqsum)
FUNC <void cv..integral [ARG Mat src=, ARG Mat sum=, ARG int sdepth=-1]>
java: void integral(Mat src, Mat sum, int sdepth)
java: void integral(Mat src, Mat sum)
FUNC <void cv..invertAffineTransform [ARG Mat M=, ARG Mat iM=]>
java: void invertAffineTransform(Mat M, Mat iM)
FUNC <void cv..line [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void line(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType, int shift)
java: void line(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType)
java: void line(Mat img, Point pt1, Point pt2, Scalar color, int thickness)
java: void line(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..linearPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>
java: void linearPolar(Mat src, Mat dst, Point center, double maxRadius, int flags)
FUNC <void cv..logPolar [ARG Mat src=, ARG Mat dst=, ARG Point2f center=, ARG double M=, ARG int flags=]>
java: void logPolar(Mat src, Mat dst, Point center, double M, int flags)
FUNC <void cv..matchTemplate [ARG Mat image=, ARG Mat templ=, ARG Mat result=, ARG int method=, ARG Mat mask=Mat()]>
java: void matchTemplate(Mat image, Mat templ, Mat result, int method, Mat mask)
java: void matchTemplate(Mat image, Mat templ, Mat result, int method)
FUNC <void cv..medianBlur [ARG Mat src=, ARG Mat dst=, ARG int ksize=]>
java: void medianBlur(Mat src, Mat dst, int ksize)
FUNC <void cv..minEnclosingCircle [ARG vector_Point2f points=, ARG Point2f center=, ARG float radius=]>
java: void minEnclosingCircle(MatOfPoint2f points, Point center, float[] radius)
FUNC <void cv..morphologyEx [ARG Mat src=, ARG Mat dst=, ARG int op=, ARG Mat kernel=, ARG Point anchor=Point(-1,-1), ARG int iterations=1, ARG int borderType=BORDER_CONSTANT, ARG Scalar borderValue=morphologyDefaultBorderValue()]>
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor, int iterations, int borderType, Scalar borderValue)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor, int iterations, int borderType)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor, int iterations)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel, Point anchor)
java: void morphologyEx(Mat src, Mat dst, int op, Mat kernel)
FUNC <void cv..polylines [ARG Mat img=, ARG vector_vector_Point pts=, ARG bool isClosed=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color, int thickness, int lineType, int shift)
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color, int thickness, int lineType)
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color, int thickness)
java: void polylines(Mat img, List<MatOfPoint> pts, boolean isClosed, Scalar color)
FUNC <void cv..preCornerDetect [ARG Mat src=, ARG Mat dst=, ARG int ksize=, ARG int borderType=BORDER_DEFAULT]>
java: void preCornerDetect(Mat src, Mat dst, int ksize, int borderType)
java: void preCornerDetect(Mat src, Mat dst, int ksize)
FUNC <void cv..putText [ARG Mat img=, ARG String text=, ARG Point org=, ARG int fontFace=, ARG double fontScale=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG bool bottomLeftOrigin=false]>
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, boolean bottomLeftOrigin)
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType)
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color, int thickness)
java: void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color)
FUNC <void cv..pyrDown [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>
java: void pyrDown(Mat src, Mat dst, Size dstsize, int borderType)
java: void pyrDown(Mat src, Mat dst, Size dstsize)
java: void pyrDown(Mat src, Mat dst)
FUNC <void cv..pyrMeanShiftFiltering [ARG Mat src=, ARG Mat dst=, ARG double sp=, ARG double sr=, ARG int maxLevel=1, ARG TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1)]>
java: void pyrMeanShiftFiltering(Mat src, Mat dst, double sp, double sr, int maxLevel, TermCriteria termcrit)
java: void pyrMeanShiftFiltering(Mat src, Mat dst, double sp, double sr, int maxLevel)
java: void pyrMeanShiftFiltering(Mat src, Mat dst, double sp, double sr)
FUNC <void cv..pyrUp [ARG Mat src=, ARG Mat dst=, ARG Size dstsize=Size(), ARG int borderType=BORDER_DEFAULT]>
java: void pyrUp(Mat src, Mat dst, Size dstsize, int borderType)
java: void pyrUp(Mat src, Mat dst, Size dstsize)
java: void pyrUp(Mat src, Mat dst)
FUNC <void cv..rectangle [ARG Mat img=, ARG Point pt1=, ARG Point pt2=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType, int shift)
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color, int thickness, int lineType)
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color, int thickness)
java: void rectangle(Mat img, Point pt1, Point pt2, Scalar color)
FUNC <void cv..rectangle [ARG Mat img=, ARG Rect rec=, ARG Scalar color=, ARG int thickness=1, ARG int lineType=LINE_8, ARG int shift=0]>
java: void rectangle(Mat img, Rect rec, Scalar color, int thickness, int lineType, int shift)
java: void rectangle(Mat img, Rect rec, Scalar color, int thickness, int lineType)
java: void rectangle(Mat img, Rect rec, Scalar color, int thickness)
java: void rectangle(Mat img, Rect rec, Scalar color)
FUNC <void cv..remap [ARG Mat src=, ARG Mat dst=, ARG Mat map1=, ARG Mat map2=, ARG int interpolation=, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void remap(Mat src, Mat dst, Mat map1, Mat map2, int interpolation, int borderMode, Scalar borderValue)
java: void remap(Mat src, Mat dst, Mat map1, Mat map2, int interpolation, int borderMode)
java: void remap(Mat src, Mat dst, Mat map1, Mat map2, int interpolation)
FUNC <void cv..resize [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG double fx=0, ARG double fy=0, ARG int interpolation=INTER_LINEAR]>
java: void resize(Mat src, Mat dst, Size dsize, double fx, double fy, int interpolation)
java: void resize(Mat src, Mat dst, Size dsize, double fx, double fy)
java: void resize(Mat src, Mat dst, Size dsize, double fx)
java: void resize(Mat src, Mat dst, Size dsize)
FUNC <void cv..sepFilter2D [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Mat kernelX=, ARG Mat kernelY=, ARG Point anchor=Point(-1,-1), ARG double delta=0, ARG int borderType=BORDER_DEFAULT]>
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor, double delta, int borderType)
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor, double delta)
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY, Point anchor)
java: void sepFilter2D(Mat src, Mat dst, int ddepth, Mat kernelX, Mat kernelY)
FUNC <void cv..spatialGradient [ARG Mat src=, ARG Mat dx=, ARG Mat dy=, ARG int ksize=3, ARG int borderType=BORDER_DEFAULT]>
java: void spatialGradient(Mat src, Mat dx, Mat dy, int ksize, int borderType)
java: void spatialGradient(Mat src, Mat dx, Mat dy, int ksize)
java: void spatialGradient(Mat src, Mat dx, Mat dy)
FUNC <void cv..sqrBoxFilter [ARG Mat src=, ARG Mat dst=, ARG int ddepth=, ARG Size ksize=, ARG Point anchor=Point(-1, -1), ARG bool normalize=true, ARG int borderType=BORDER_DEFAULT]>
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize, int borderType)
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor, boolean normalize)
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize, Point anchor)
java: void sqrBoxFilter(Mat src, Mat dst, int ddepth, Size ksize)
FUNC <void cv..warpAffine [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode, Scalar borderValue)
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode)
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize, int flags)
java: void warpAffine(Mat src, Mat dst, Mat M, Size dsize)
FUNC <void cv..warpPerspective [ARG Mat src=, ARG Mat dst=, ARG Mat M=, ARG Size dsize=, ARG int flags=INTER_LINEAR, ARG int borderMode=BORDER_CONSTANT, ARG Scalar borderValue=Scalar()]>
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode, Scalar borderValue)
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize, int flags, int borderMode)
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize, int flags)
java: void warpPerspective(Mat src, Mat dst, Mat M, Size dsize)
FUNC <void cv..warpPolar [ARG Mat src=, ARG Mat dst=, ARG Size dsize=, ARG Point2f center=, ARG double maxRadius=, ARG int flags=]>
java: void warpPolar(Mat src, Mat dst, Size dsize, Point center, double maxRadius, int flags)
FUNC <void cv..watershed [ARG Mat image=, ARG Mat markers=]>
java: void watershed(Mat image, Mat markers)
CLASS cv::.CLAHE : Algorithm
FUNC <Size cv.CLAHE.getTilesGridSize []>
java: Size getTilesGridSize()
FUNC <double cv.CLAHE.getClipLimit []>
java: double getClipLimit()
FUNC <void cv.CLAHE.apply [ARG Mat src=, ARG Mat dst=]>
java: void apply(Mat src, Mat dst)
FUNC <void cv.CLAHE.collectGarbage []>
java: void collectGarbage()
FUNC <void cv.CLAHE.setClipLimit [ARG double clipLimit=]>
java: void setClipLimit(double clipLimit)
FUNC <void cv.CLAHE.setTilesGridSize [ARG Size tileGridSize=]>
java: void setTilesGridSize(Size tileGridSize)
CLASS cv::.Subdiv2D : 
[CONST PTLOC_ERROR=-2, CONST PTLOC_OUTSIDE_RECT=-1, CONST PTLOC_INSIDE=0, CONST PTLOC_VERTEX=1, CONST PTLOC_ON_EDGE=2, CONST NEXT_AROUND_ORG=0x00, CONST NEXT_AROUND_DST=0x22, CONST PREV_AROUND_ORG=0x11, CONST PREV_AROUND_DST=0x33, CONST NEXT_AROUND_LEFT=0x13, CONST NEXT_AROUND_RIGHT=0x31, CONST PREV_AROUND_LEFT=0x20, CONST PREV_AROUND_RIGHT=0x02]
FUNC < cv.Subdiv2D.Subdiv2D [ARG Rect rect=]>
java:  Subdiv2D(Rect rect)
FUNC < cv.Subdiv2D.Subdiv2D []>
java:  Subdiv2D()
FUNC <Point2f cv.Subdiv2D.getVertex [ARG int vertex=, ARG int * firstEdge=0]>
java: Point getVertex(int vertex, int[] firstEdge)
java: Point getVertex(int vertex)
FUNC <int cv.Subdiv2D.edgeDst [ARG int edge=, ARG Point2f * dstpt=0]>
java: int edgeDst(int edge, Point dstpt)
java: int edgeDst(int edge)
FUNC <int cv.Subdiv2D.edgeOrg [ARG int edge=, ARG Point2f * orgpt=0]>
java: int edgeOrg(int edge, Point orgpt)
java: int edgeOrg(int edge)
FUNC <int cv.Subdiv2D.findNearest [ARG Point2f pt=, ARG Point2f * nearestPt=0]>
java: int findNearest(Point pt, Point nearestPt)
java: int findNearest(Point pt)
FUNC <int cv.Subdiv2D.getEdge [ARG int edge=, ARG int nextEdgeType=]>
java: int getEdge(int edge, int nextEdgeType)
FUNC <int cv.Subdiv2D.insert [ARG Point2f pt=]>
java: int insert(Point pt)
FUNC <int cv.Subdiv2D.locate [ARG Point2f pt=, ARG int edge=, ARG int vertex=]>
java: int locate(Point pt, int[] edge, int[] vertex)
FUNC <int cv.Subdiv2D.nextEdge [ARG int edge=]>
java: int nextEdge(int edge)
FUNC <int cv.Subdiv2D.rotateEdge [ARG int edge=, ARG int rotate=]>
java: int rotateEdge(int edge, int rotate)
FUNC <int cv.Subdiv2D.symEdge [ARG int edge=]>
java: int symEdge(int edge)
FUNC <void cv.Subdiv2D.getEdgeList [ARG vector_Vec4f edgeList=]>
java: void getEdgeList(MatOfFloat4 edgeList)
FUNC <void cv.Subdiv2D.getLeadingEdgeList [ARG vector_int leadingEdgeList=]>
java: void getLeadingEdgeList(MatOfInt leadingEdgeList)
FUNC <void cv.Subdiv2D.getTriangleList [ARG vector_Vec6f triangleList=]>
java: void getTriangleList(MatOfFloat6 triangleList)
FUNC <void cv.Subdiv2D.getVoronoiFacetList [ARG vector_int idx=, ARG vector_vector_Point2f facetList=, ARG vector_Point2f facetCenters=]>
java: void getVoronoiFacetList(MatOfInt idx, List<MatOfPoint2f> facetList, MatOfPoint2f facetCenters)
FUNC <void cv.Subdiv2D.initDelaunay [ARG Rect rect=]>
java: void initDelaunay(Rect rect)
FUNC <void cv.Subdiv2D.insert [ARG vector_Point2f ptvec=]>
java: void insert(MatOfPoint2f ptvec)
CLASS cv::.GeneralizedHoughBallard : GeneralizedHough
FUNC <int cv.GeneralizedHoughBallard.getLevels []>
java: int getLevels()
FUNC <int cv.GeneralizedHoughBallard.getVotesThreshold []>
java: int getVotesThreshold()
FUNC <void cv.GeneralizedHoughBallard.setLevels [ARG int levels=]>
java: void setLevels(int levels)
FUNC <void cv.GeneralizedHoughBallard.setVotesThreshold [ARG int votesThreshold=]>
java: void setVotesThreshold(int votesThreshold)
CLASS cv::.GeneralizedHough : Algorithm
FUNC <double cv.GeneralizedHough.getDp []>
java: double getDp()
FUNC <double cv.GeneralizedHough.getMinDist []>
java: double getMinDist()
FUNC <int cv.GeneralizedHough.getCannyHighThresh []>
java: int getCannyHighThresh()
FUNC <int cv.GeneralizedHough.getCannyLowThresh []>
java: int getCannyLowThresh()
FUNC <int cv.GeneralizedHough.getMaxBufferSize []>
java: int getMaxBufferSize()
FUNC <void cv.GeneralizedHough.detect [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Mat positions=, ARG Mat votes=Mat()]>
java: void detect(Mat edges, Mat dx, Mat dy, Mat positions, Mat votes)
java: void detect(Mat edges, Mat dx, Mat dy, Mat positions)
FUNC <void cv.GeneralizedHough.detect [ARG Mat image=, ARG Mat positions=, ARG Mat votes=Mat()]>
java: void detect(Mat image, Mat positions, Mat votes)
java: void detect(Mat image, Mat positions)
FUNC <void cv.GeneralizedHough.setCannyHighThresh [ARG int cannyHighThresh=]>
java: void setCannyHighThresh(int cannyHighThresh)
FUNC <void cv.GeneralizedHough.setCannyLowThresh [ARG int cannyLowThresh=]>
java: void setCannyLowThresh(int cannyLowThresh)
FUNC <void cv.GeneralizedHough.setDp [ARG double dp=]>
java: void setDp(double dp)
FUNC <void cv.GeneralizedHough.setMaxBufferSize [ARG int maxBufferSize=]>
java: void setMaxBufferSize(int maxBufferSize)
FUNC <void cv.GeneralizedHough.setMinDist [ARG double minDist=]>
java: void setMinDist(double minDist)
FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat edges=, ARG Mat dx=, ARG Mat dy=, ARG Point templCenter=Point(-1, -1)]>
java: void setTemplate(Mat edges, Mat dx, Mat dy, Point templCenter)
java: void setTemplate(Mat edges, Mat dx, Mat dy)
FUNC <void cv.GeneralizedHough.setTemplate [ARG Mat templ=, ARG Point templCenter=Point(-1, -1)]>
java: void setTemplate(Mat templ, Point templCenter)
java: void setTemplate(Mat templ)
CLASS cv::.GeneralizedHoughGuil : GeneralizedHough
FUNC <double cv.GeneralizedHoughGuil.getAngleEpsilon []>
java: double getAngleEpsilon()
FUNC <double cv.GeneralizedHoughGuil.getAngleStep []>
java: double getAngleStep()
FUNC <double cv.GeneralizedHoughGuil.getMaxAngle []>
java: double getMaxAngle()
FUNC <double cv.GeneralizedHoughGuil.getMaxScale []>
java: double getMaxScale()
FUNC <double cv.GeneralizedHoughGuil.getMinAngle []>
java: double getMinAngle()
FUNC <double cv.GeneralizedHoughGuil.getMinScale []>
java: double getMinScale()
FUNC <double cv.GeneralizedHoughGuil.getScaleStep []>
java: double getScaleStep()
FUNC <double cv.GeneralizedHoughGuil.getXi []>
java: double getXi()
FUNC <int cv.GeneralizedHoughGuil.getAngleThresh []>
java: int getAngleThresh()
FUNC <int cv.GeneralizedHoughGuil.getLevels []>
java: int getLevels()
FUNC <int cv.GeneralizedHoughGuil.getPosThresh []>
java: int getPosThresh()
FUNC <int cv.GeneralizedHoughGuil.getScaleThresh []>
java: int getScaleThresh()
FUNC <void cv.GeneralizedHoughGuil.setAngleEpsilon [ARG double angleEpsilon=]>
java: void setAngleEpsilon(double angleEpsilon)
FUNC <void cv.GeneralizedHoughGuil.setAngleStep [ARG double angleStep=]>
java: void setAngleStep(double angleStep)
FUNC <void cv.GeneralizedHoughGuil.setAngleThresh [ARG int angleThresh=]>
java: void setAngleThresh(int angleThresh)
FUNC <void cv.GeneralizedHoughGuil.setLevels [ARG int levels=]>
java: void setLevels(int levels)
FUNC <void cv.GeneralizedHoughGuil.setMaxAngle [ARG double maxAngle=]>
java: void setMaxAngle(double maxAngle)
FUNC <void cv.GeneralizedHoughGuil.setMaxScale [ARG double maxScale=]>
java: void setMaxScale(double maxScale)
FUNC <void cv.GeneralizedHoughGuil.setMinAngle [ARG double minAngle=]>
java: void setMinAngle(double minAngle)
FUNC <void cv.GeneralizedHoughGuil.setMinScale [ARG double minScale=]>
java: void setMinScale(double minScale)
FUNC <void cv.GeneralizedHoughGuil.setPosThresh [ARG int posThresh=]>
java: void setPosThresh(int posThresh)
FUNC <void cv.GeneralizedHoughGuil.setScaleStep [ARG double scaleStep=]>
java: void setScaleStep(double scaleStep)
FUNC <void cv.GeneralizedHoughGuil.setScaleThresh [ARG int scaleThresh=]>
java: void setScaleThresh(int scaleThresh)
FUNC <void cv.GeneralizedHoughGuil.setXi [ARG double xi=]>
java: void setXi(double xi)
CLASS cv::.LineSegmentDetector : Algorithm
FUNC <int cv.LineSegmentDetector.compareSegments [ARG Size size=, ARG Mat lines1=, ARG Mat lines2=, ARG Mat _image=Mat()]>
java: int compareSegments(Size size, Mat lines1, Mat lines2, Mat _image)
java: int compareSegments(Size size, Mat lines1, Mat lines2)
FUNC <void cv.LineSegmentDetector.detect [ARG Mat _image=, ARG Mat _lines=, ARG Mat width=Mat(), ARG Mat prec=Mat(), ARG Mat nfa=Mat()]>
java: void detect(Mat _image, Mat _lines, Mat width, Mat prec, Mat nfa)
java: void detect(Mat _image, Mat _lines, Mat width, Mat prec)
java: void detect(Mat _image, Mat _lines, Mat width)
java: void detect(Mat _image, Mat _lines)
FUNC <void cv.LineSegmentDetector.drawSegments [ARG Mat _image=, ARG Mat lines=]>
java: void drawSegments(Mat _image, Mat lines)

=== MODULE: ml (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/ml) ===


Files (2):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/ml/include/opencv2/ml.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/ml/include/opencv2/ml/ml.hpp']

Common headers (0):
[]
ok: class CLASS ::.Ml : , name: Ml, base: 


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/ml/include/opencv2/ml.hpp =====
Namespaces: set([u'cv', u'cv.ml'])

--- Incoming ---
[   u'enum cv.ml.VariableTypes',
    '',
    [],
    [   [u'const cv.ml.VAR_NUMERICAL', u'0', [], [], None, ''],
        [u'const cv.ml.VAR_ORDERED', u'0', [], [], None, ''],
        [u'const cv.ml.VAR_CATEGORICAL', u'1', [], [], None, '']],
    None]
ok: CONST VAR_NUMERICAL=0
ok: CONST VAR_ORDERED=0
ok: CONST VAR_CATEGORICAL=1

--- Incoming ---
[   u'enum cv.ml.ErrorTypes',
    '',
    [],
    [   [u'const cv.ml.TEST_ERROR', u'0', [], [], None, ''],
        [u'const cv.ml.TRAIN_ERROR', u'1', [], [], None, '']],
    None]
ok: CONST TEST_ERROR=0
ok: CONST TRAIN_ERROR=1

--- Incoming ---
[   u'enum cv.ml.SampleTypes',
    '',
    [],
    [   [u'const cv.ml.ROW_SAMPLE', u'0', [], [], None, ''],
        [u'const cv.ml.COL_SAMPLE', u'1', [], [], None, '']],
    None]
ok: CONST ROW_SAMPLE=0
ok: CONST COL_SAMPLE=1

--- Incoming ---
[   u'class cv.ml.ParamGrid',
    '',
    [],
    [   [u'double', u'minVal', '', ['/RW']],
        [u'double', u'maxVal', '', ['/RW']],
        [u'double', u'logStep', '', ['/RW']]],
    None]
ok: class CLASS cv.ml::.ParamGrid : , name: ParamGrid, base: 

--- Incoming ---
[   u'cv.ml.ParamGrid.create',
    u'Ptr_ParamGrid',
    ['/S'],
    [   [u'double', u'minVal', u'0.', []],
        [u'double', u'maxVal', u'0.', []],
        [u'double', u'logstep', u'1.', []]],
    u'Ptr<ParamGrid>']
ok: FUNC <Ptr_ParamGrid cv.ml.ParamGrid.create [ARG double minVal=0., ARG double maxVal=0., ARG double logstep=1.]>

--- Incoming ---
[u'class cv.ml.TrainData', '', [], [], None]
ok: class CLASS cv.ml::.TrainData : , name: TrainData, base: 

--- Incoming ---
[u'cv.ml.TrainData.getLayout', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getLayout []>

--- Incoming ---
[u'cv.ml.TrainData.getNTrainSamples', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNTrainSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getNTestSamples', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNTestSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getNSamples', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getNVars', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNVars []>

--- Incoming ---
[u'cv.ml.TrainData.getNAllVars', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getNAllVars []>

--- Incoming ---
[   u'cv.ml.TrainData.getSample',
    u'void',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'varIdx', '', []],
        [u'int', u'sidx', u'', []],
        [u'float*', u'buf', u'', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.getSample [ARG Mat varIdx=, ARG int sidx=, ARG float * buf=]>

--- Incoming ---
[u'cv.ml.TrainData.getSamples', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSamples []>

--- Incoming ---
[u'cv.ml.TrainData.getMissing', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getMissing []>

--- Incoming ---
[   u'cv.ml.TrainData.getTrainSamples',
    u'Mat',
    ['/C', '/V', '/PV'],
    [   [u'int', u'layout', u'ROW_SAMPLE', []],
        [u'bool', u'compressSamples', u'true', []],
        [u'bool', u'compressVars', u'true', []]],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSamples [ARG int layout=ROW_SAMPLE, ARG bool compressSamples=true, ARG bool compressVars=true]>

--- Incoming ---
[u'cv.ml.TrainData.getTrainResponses', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainResponses []>

--- Incoming ---
[   u'cv.ml.TrainData.getTrainNormCatResponses',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainNormCatResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getTestResponses', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestResponses []>

--- Incoming ---
[   u'cv.ml.TrainData.getTestNormCatResponses',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestNormCatResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getResponses', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getResponses []>

--- Incoming ---
[   u'cv.ml.TrainData.getNormCatResponses',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getNormCatResponses []>

--- Incoming ---
[u'cv.ml.TrainData.getSampleWeights', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSampleWeights []>

--- Incoming ---
[   u'cv.ml.TrainData.getTrainSampleWeights',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSampleWeights []>

--- Incoming ---
[   u'cv.ml.TrainData.getTestSampleWeights',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSampleWeights []>

--- Incoming ---
[u'cv.ml.TrainData.getVarIdx', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarIdx []>

--- Incoming ---
[u'cv.ml.TrainData.getVarType', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarType []>

--- Incoming ---
[u'cv.ml.TrainData.getVarSymbolFlags', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getVarSymbolFlags []>

--- Incoming ---
[u'cv.ml.TrainData.getResponseType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.TrainData.getResponseType []>

--- Incoming ---
[u'cv.ml.TrainData.getTrainSampleIdx', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTrainSampleIdx []>

--- Incoming ---
[u'cv.ml.TrainData.getTestSampleIdx', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSampleIdx []>

--- Incoming ---
[   u'cv.ml.TrainData.getValues',
    u'void',
    ['/C', '/V', '/PV'],
    [   [u'int', u'vi', u'', []],
        ['Mat', u'sidx', '', []],
        [u'float*', u'values', u'', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.getValues [ARG int vi=, ARG Mat sidx=, ARG float * values=]>

--- Incoming ---
[   u'cv.ml.TrainData.getDefaultSubstValues',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getDefaultSubstValues []>

--- Incoming ---
[   u'cv.ml.TrainData.getCatCount',
    u'int',
    ['/C', '/V', '/PV'],
    [[u'int', u'vi', u'', []]],
    u'int']
ok: FUNC <int cv.ml.TrainData.getCatCount [ARG int vi=]>

--- Incoming ---
[u'cv.ml.TrainData.getClassLabels', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getClassLabels []>

--- Incoming ---
[u'cv.ml.TrainData.getCatOfs', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getCatOfs []>

--- Incoming ---
[u'cv.ml.TrainData.getCatMap', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getCatMap []>

--- Incoming ---
[   u'cv.ml.TrainData.setTrainTestSplit',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'count', u'', []], [u'bool', u'shuffle', u'true', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.setTrainTestSplit [ARG int count=, ARG bool shuffle=true]>

--- Incoming ---
[   u'cv.ml.TrainData.setTrainTestSplitRatio',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'ratio', u'', []], [u'bool', u'shuffle', u'true', []]],
    u'void']
ok: FUNC <void cv.ml.TrainData.setTrainTestSplitRatio [ARG double ratio=, ARG bool shuffle=true]>

--- Incoming ---
[u'cv.ml.TrainData.shuffleTrainTest', u'void', ['/V', '/PV'], [], u'void']
ok: FUNC <void cv.ml.TrainData.shuffleTrainTest []>

--- Incoming ---
[u'cv.ml.TrainData.getTestSamples', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getTestSamples []>

--- Incoming ---
[   u'cv.ml.TrainData.getNames',
    u'void',
    ['/C', '/V', '/PV'],
    [[u'vector_String', u'names', u'', ['/Ref']]],
    u'void']
ok: FUNC <void cv.ml.TrainData.getNames [ARG vector_String names=]>

--- Incoming ---
[   u'cv.ml.TrainData.getSubVector',
    u'Mat',
    ['/S'],
    [   [u'Mat', u'vec', u'', ['/C', '/Ref']],
        [u'Mat', u'idx', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSubVector [ARG Mat vec=, ARG Mat idx=]>

--- Incoming ---
[   u'cv.ml.TrainData.getSubMatrix',
    u'Mat',
    ['/S'],
    [   [u'Mat', u'matrix', u'', ['/C', '/Ref']],
        [u'Mat', u'idx', u'', ['/C', '/Ref']],
        [u'int', u'layout', u'', []]],
    u'Mat']
ok: FUNC <Mat cv.ml.TrainData.getSubMatrix [ARG Mat matrix=, ARG Mat idx=, ARG int layout=]>

--- Incoming ---
[   u'cv.ml.TrainData.create',
    u'Ptr_TrainData',
    ['/S'],
    [   ['Mat', u'samples', '', []],
        [u'int', u'layout', u'', []],
        ['Mat', u'responses', '', []],
        ['Mat', u'varIdx', u'Mat()', []],
        ['Mat', u'sampleIdx', u'Mat()', []],
        ['Mat', u'sampleWeights', u'Mat()', []],
        ['Mat', u'varType', u'Mat()', []]],
    u'Ptr<TrainData>']
ok: FUNC <Ptr_TrainData cv.ml.TrainData.create [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG Mat varIdx=Mat(), ARG Mat sampleIdx=Mat(), ARG Mat sampleWeights=Mat(), ARG Mat varType=Mat()]>

--- Incoming ---
[u'class cv.ml.StatModel', ': cv::Algorithm', [], [], None]
ok: class CLASS cv.ml::.StatModel : Algorithm, name: StatModel, base: Algorithm

--- Incoming ---
[   u'enum cv.ml.StatModel.Flags',
    '',
    [],
    [   [u'const cv.ml.StatModel.UPDATE_MODEL', u'1', [], [], None, ''],
        [u'const cv.ml.StatModel.RAW_OUTPUT', u'1', [], [], None, ''],
        [u'const cv.ml.StatModel.COMPRESSED_INPUT', u'2', [], [], None, ''],
        [u'const cv.ml.StatModel.PREPROCESSED_INPUT', u'4', [], [], None, '']],
    None]
ok: CONST UPDATE_MODEL=1
ok: CONST RAW_OUTPUT=1
ok: CONST COMPRESSED_INPUT=2
ok: CONST PREPROCESSED_INPUT=4

--- Incoming ---
[u'cv.ml.StatModel.getVarCount', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.StatModel.getVarCount []>

--- Incoming ---
[u'cv.ml.StatModel.empty', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.ml.StatModel.empty []>

--- Incoming ---
[u'cv.ml.StatModel.isTrained', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.ml.StatModel.isTrained []>

--- Incoming ---
[u'cv.ml.StatModel.isClassifier', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.ml.StatModel.isClassifier []>

--- Incoming ---
[   u'cv.ml.StatModel.train',
    u'bool',
    ['/V'],
    [   [u'Ptr_TrainData', u'trainData', u'', ['/C', '/Ref']],
        [u'int', u'flags', u'0', []]],
    u'bool']
ok: FUNC <bool cv.ml.StatModel.train [ARG Ptr_TrainData trainData=, ARG int flags=0]>

--- Incoming ---
[   u'cv.ml.StatModel.train',
    u'bool',
    ['/V'],
    [   ['Mat', u'samples', '', []],
        [u'int', u'layout', u'', []],
        ['Mat', u'responses', '', []]],
    u'bool']
ok: FUNC <bool cv.ml.StatModel.train [ARG Mat samples=, ARG int layout=, ARG Mat responses=]>

--- Incoming ---
[   u'cv.ml.StatModel.calcError',
    u'float',
    ['/C', '/V'],
    [   [u'Ptr_TrainData', u'data', u'', ['/C', '/Ref']],
        [u'bool', u'test', u'', []],
        ['Mat', u'resp', '', ['/O']]],
    u'float']
ok: FUNC <float cv.ml.StatModel.calcError [ARG Ptr_TrainData data=, ARG bool test=, ARG Mat resp=]>

--- Incoming ---
[   u'cv.ml.StatModel.predict',
    u'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'results', u'Mat()', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'float']
ok: FUNC <float cv.ml.StatModel.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>

--- Incoming ---
[u'class cv.ml.NormalBayesClassifier', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.NormalBayesClassifier : StatModel, name: NormalBayesClassifier, base: StatModel

--- Incoming ---
[   u'cv.ml.NormalBayesClassifier.predictProb',
    u'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'inputs', '', []],
        ['Mat', u'outputs', '', ['/O']],
        ['Mat', u'outputProbs', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'float']
ok: FUNC <float cv.ml.NormalBayesClassifier.predictProb [ARG Mat inputs=, ARG Mat outputs=, ARG Mat outputProbs=, ARG int flags=0]>

--- Incoming ---
[   u'cv.ml.NormalBayesClassifier.create',
    u'Ptr_NormalBayesClassifier',
    ['/S'],
    [],
    u'Ptr<NormalBayesClassifier>']
ok: FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.create []>

--- Incoming ---
[   u'cv.ml.NormalBayesClassifier.load',
    u'Ptr_NormalBayesClassifier',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<NormalBayesClassifier>']
ok: FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.KNearest', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.KNearest : StatModel, name: KNearest, base: StatModel

--- Incoming ---
[u'cv.ml.KNearest.getDefaultK', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.KNearest.getDefaultK []>

--- Incoming ---
[   u'cv.ml.KNearest.setDefaultK',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.KNearest.setDefaultK [ARG int val=]>

--- Incoming ---
[u'cv.ml.KNearest.getIsClassifier', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.ml.KNearest.getIsClassifier []>

--- Incoming ---
[   u'cv.ml.KNearest.setIsClassifier',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.KNearest.setIsClassifier [ARG bool val=]>

--- Incoming ---
[u'cv.ml.KNearest.getEmax', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.KNearest.getEmax []>

--- Incoming ---
[   u'cv.ml.KNearest.setEmax',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.KNearest.setEmax [ARG int val=]>

--- Incoming ---
[u'cv.ml.KNearest.getAlgorithmType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.KNearest.getAlgorithmType []>

--- Incoming ---
[   u'cv.ml.KNearest.setAlgorithmType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.KNearest.setAlgorithmType [ARG int val=]>

--- Incoming ---
[   u'cv.ml.KNearest.findNearest',
    u'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        [u'int', u'k', u'', []],
        ['Mat', u'results', '', ['/O']],
        ['Mat', u'neighborResponses', u'Mat()', ['/O']],
        ['Mat', u'dist', u'Mat()', ['/O']]],
    u'float']
ok: FUNC <float cv.ml.KNearest.findNearest [ARG Mat samples=, ARG int k=, ARG Mat results=, ARG Mat neighborResponses=Mat(), ARG Mat dist=Mat()]>

--- Incoming ---
[   u'enum cv.ml.KNearest.Types',
    '',
    [],
    [   [u'const cv.ml.KNearest.BRUTE_FORCE', u'1', [], [], None, ''],
        [u'const cv.ml.KNearest.KDTREE', u'2', [], [], None, '']],
    None]
ok: CONST BRUTE_FORCE=1
ok: CONST KDTREE=2

--- Incoming ---
[u'cv.ml.KNearest.create', u'Ptr_KNearest', ['/S'], [], u'Ptr<KNearest>']
ok: FUNC <Ptr_KNearest cv.ml.KNearest.create []>

--- Incoming ---
[   u'cv.ml.KNearest.load',
    u'Ptr_KNearest',
    ['/S'],
    [[u'String', u'filepath', u'', ['/C', '/Ref']]],
    u'Ptr<KNearest>']
ok: FUNC <Ptr_KNearest cv.ml.KNearest.load [ARG String filepath=]>

--- Incoming ---
[u'class cv.ml.SVM', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.SVM : StatModel, name: SVM, base: StatModel

--- Incoming ---
[u'cv.ml.SVM.getType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.SVM.getType []>

--- Incoming ---
[   u'cv.ml.SVM.setType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setType [ARG int val=]>

--- Incoming ---
[u'cv.ml.SVM.getGamma', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getGamma []>

--- Incoming ---
[   u'cv.ml.SVM.setGamma',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setGamma [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getCoef0', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getCoef0 []>

--- Incoming ---
[   u'cv.ml.SVM.setCoef0',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setCoef0 [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getDegree', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getDegree []>

--- Incoming ---
[   u'cv.ml.SVM.setDegree',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setDegree [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getC', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getC []>

--- Incoming ---
[   u'cv.ml.SVM.setC',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setC [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getNu', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getNu []>

--- Incoming ---
[   u'cv.ml.SVM.setNu',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setNu [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getP', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.SVM.getP []>

--- Incoming ---
[   u'cv.ml.SVM.setP',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setP [ARG double val=]>

--- Incoming ---
[u'cv.ml.SVM.getClassWeights', u'Mat', ['/C', '/V', '/PV'], [], u'cv::Mat']
ok: FUNC <Mat cv.ml.SVM.getClassWeights []>

--- Incoming ---
[   u'cv.ml.SVM.setClassWeights',
    u'void',
    ['/V', '/PV'],
    [[u'Mat', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.SVM.setClassWeights [ARG Mat val=]>

--- Incoming ---
[   u'cv.ml.SVM.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'cv::TermCriteria']
ok: FUNC <TermCriteria cv.ml.SVM.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.SVM.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.SVM.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[u'cv.ml.SVM.getKernelType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.SVM.getKernelType []>

--- Incoming ---
[   u'cv.ml.SVM.setKernel',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'kernelType', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVM.setKernel [ARG int kernelType=]>

--- Incoming ---
[   u'enum cv.ml.SVM.Types',
    '',
    [],
    [   [u'const cv.ml.SVM.C_SVC', u'100', [], [], None, ''],
        [u'const cv.ml.SVM.NU_SVC', u'101', [], [], None, ''],
        [u'const cv.ml.SVM.ONE_CLASS', u'102', [], [], None, ''],
        [u'const cv.ml.SVM.EPS_SVR', u'103', [], [], None, ''],
        [u'const cv.ml.SVM.NU_SVR', u'104', [], [], None, '']],
    None]
ok: CONST C_SVC=100
ok: CONST NU_SVC=101
ok: CONST ONE_CLASS=102
ok: CONST EPS_SVR=103
ok: CONST NU_SVR=104

--- Incoming ---
[   u'enum cv.ml.SVM.KernelTypes',
    '',
    [],
    [   [u'const cv.ml.SVM.CUSTOM', u'-1', [], [], None, ''],
        [u'const cv.ml.SVM.LINEAR', u'0', [], [], None, ''],
        [u'const cv.ml.SVM.POLY', u'1', [], [], None, ''],
        [u'const cv.ml.SVM.RBF', u'2', [], [], None, ''],
        [u'const cv.ml.SVM.SIGMOID', u'3', [], [], None, ''],
        [u'const cv.ml.SVM.CHI2', u'4', [], [], None, ''],
        [u'const cv.ml.SVM.INTER', u'5', [], [], None, '']],
    None]
ok: CONST CUSTOM=-1
ok: CONST LINEAR=0
ok: CONST POLY=1
ok: CONST RBF=2
ok: CONST SIGMOID=3
ok: CONST CHI2=4
ok: CONST INTER=5

--- Incoming ---
[   u'enum cv.ml.SVM.ParamTypes',
    '',
    [],
    [   [u'const cv.ml.SVM.C', u'0', [], [], None, ''],
        [u'const cv.ml.SVM.GAMMA', u'1', [], [], None, ''],
        [u'const cv.ml.SVM.P', u'2', [], [], None, ''],
        [u'const cv.ml.SVM.NU', u'3', [], [], None, ''],
        [u'const cv.ml.SVM.COEF', u'4', [], [], None, ''],
        [u'const cv.ml.SVM.DEGREE', u'5', [], [], None, '']],
    None]
ok: CONST C=0
ok: CONST GAMMA=1
ok: CONST P=2
ok: CONST NU=3
ok: CONST COEF=4
ok: CONST DEGREE=5

--- Incoming ---
[   u'cv.ml.SVM.trainAuto',
    u'bool',
    ['/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        [u'int', u'layout', u'', []],
        ['Mat', u'responses', '', []],
        [u'int', u'kFold', u'10', []],
        [u'Ptr_ParamGrid', u'Cgrid', u'SVM::getDefaultGridPtr(SVM::C)', []],
        [   u'Ptr_ParamGrid',
            u'gammaGrid',
            u'SVM::getDefaultGridPtr(SVM::GAMMA)',
            []],
        [u'Ptr_ParamGrid', u'pGrid', u'SVM::getDefaultGridPtr(SVM::P)', []],
        [u'Ptr_ParamGrid', u'nuGrid', u'SVM::getDefaultGridPtr(SVM::NU)', []],
        [   u'Ptr_ParamGrid',
            u'coeffGrid',
            u'SVM::getDefaultGridPtr(SVM::COEF)',
            []],
        [   u'Ptr_ParamGrid',
            u'degreeGrid',
            u'SVM::getDefaultGridPtr(SVM::DEGREE)',
            []],
        [u'bool', u'balanced', u'false', []]],
    u'bool']
ok: FUNC <bool cv.ml.SVM.trainAuto [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG int kFold=10, ARG Ptr_ParamGrid Cgrid=SVM::getDefaultGridPtr(SVM::C), ARG Ptr_ParamGrid gammaGrid=SVM::getDefaultGridPtr(SVM::GAMMA), ARG Ptr_ParamGrid pGrid=SVM::getDefaultGridPtr(SVM::P), ARG Ptr_ParamGrid nuGrid=SVM::getDefaultGridPtr(SVM::NU), ARG Ptr_ParamGrid coeffGrid=SVM::getDefaultGridPtr(SVM::COEF), ARG Ptr_ParamGrid degreeGrid=SVM::getDefaultGridPtr(SVM::DEGREE), ARG bool balanced=false]>

--- Incoming ---
[u'cv.ml.SVM.getSupportVectors', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.SVM.getSupportVectors []>

--- Incoming ---
[   u'cv.ml.SVM.getUncompressedSupportVectors',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.SVM.getUncompressedSupportVectors []>

--- Incoming ---
[   u'cv.ml.SVM.getDecisionFunction',
    u'double',
    ['/C', '/V', '/PV'],
    [   [u'int', u'i', u'', []],
        ['Mat', u'alpha', '', ['/O']],
        ['Mat', u'svidx', '', ['/O']]],
    u'double']
ok: FUNC <double cv.ml.SVM.getDecisionFunction [ARG int i=, ARG Mat alpha=, ARG Mat svidx=]>

--- Incoming ---
[   u'cv.ml.SVM.getDefaultGridPtr',
    u'Ptr_ParamGrid',
    ['/S'],
    [[u'int', u'param_id', u'', []]],
    u'Ptr<ParamGrid>']
ok: FUNC <Ptr_ParamGrid cv.ml.SVM.getDefaultGridPtr [ARG int param_id=]>

--- Incoming ---
[u'cv.ml.SVM.create', u'Ptr_SVM', ['/S'], [], u'Ptr<SVM>']
ok: FUNC <Ptr_SVM cv.ml.SVM.create []>

--- Incoming ---
[   u'cv.ml.SVM.load',
    u'Ptr_SVM',
    ['/S'],
    [[u'String', u'filepath', u'', ['/C', '/Ref']]],
    u'Ptr<SVM>']
ok: FUNC <Ptr_SVM cv.ml.SVM.load [ARG String filepath=]>

--- Incoming ---
[u'class cv.ml.EM', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.EM : StatModel, name: EM, base: StatModel

--- Incoming ---
[   u'enum cv.ml.EM.Types',
    '',
    [],
    [   [u'const cv.ml.EM.COV_MAT_SPHERICAL', u'0', [], [], None, ''],
        [u'const cv.ml.EM.COV_MAT_DIAGONAL', u'1', [], [], None, ''],
        [u'const cv.ml.EM.COV_MAT_GENERIC', u'2', [], [], None, ''],
        [   u'const cv.ml.EM.COV_MAT_DEFAULT',
            u'COV_MAT_DIAGONAL',
            [],
            [],
            None,
            '']],
    None]
ok: CONST COV_MAT_SPHERICAL=0
ok: CONST COV_MAT_DIAGONAL=1
ok: CONST COV_MAT_GENERIC=2
ok: CONST COV_MAT_DEFAULT=COV_MAT_DIAGONAL

--- Incoming ---
[   u'enum cv.ml.EM.<unnamed>',
    '',
    [],
    [   [u'const cv.ml.EM.DEFAULT_NCLUSTERS', u'5', [], [], None, ''],
        [u'const cv.ml.EM.DEFAULT_MAX_ITERS', u'100', [], [], None, '']],
    None]
ok: CONST DEFAULT_NCLUSTERS=5
ok: CONST DEFAULT_MAX_ITERS=100

--- Incoming ---
[   u'enum cv.ml.EM.<unnamed>',
    '',
    [],
    [   [u'const cv.ml.EM.START_E_STEP', u'1', [], [], None, ''],
        [u'const cv.ml.EM.START_M_STEP', u'2', [], [], None, ''],
        [u'const cv.ml.EM.START_AUTO_STEP', u'0', [], [], None, '']],
    None]
ok: CONST START_E_STEP=1
ok: CONST START_M_STEP=2
ok: CONST START_AUTO_STEP=0

--- Incoming ---
[u'cv.ml.EM.getClustersNumber', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.EM.getClustersNumber []>

--- Incoming ---
[   u'cv.ml.EM.setClustersNumber',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.EM.setClustersNumber [ARG int val=]>

--- Incoming ---
[u'cv.ml.EM.getCovarianceMatrixType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.EM.getCovarianceMatrixType []>

--- Incoming ---
[   u'cv.ml.EM.setCovarianceMatrixType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.EM.setCovarianceMatrixType [ARG int val=]>

--- Incoming ---
[   u'cv.ml.EM.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.EM.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.EM.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.EM.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[u'cv.ml.EM.getWeights', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.EM.getWeights []>

--- Incoming ---
[u'cv.ml.EM.getMeans', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.EM.getMeans []>

--- Incoming ---
[   u'cv.ml.EM.getCovs',
    u'void',
    ['/C', '/V', '/PV'],
    [[u'vector_Mat', u'covs', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.EM.getCovs [ARG vector_Mat covs=]>

--- Incoming ---
[   u'cv.ml.EM.predict',
    u'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'results', u'Mat()', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'float']
ok: FUNC <float cv.ml.EM.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>

--- Incoming ---
[   u'cv.ml.EM.predict2',
    u'Vec2d',
    ['/C', '/V', '/PV'],
    [['Mat', u'sample', '', []], ['Mat', u'probs', '', ['/O']]],
    u'Vec2d']
ok: FUNC <Vec2d cv.ml.EM.predict2 [ARG Mat sample=, ARG Mat probs=]>

--- Incoming ---
[   u'cv.ml.EM.trainEM',
    u'bool',
    ['/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'logLikelihoods', u'Mat()', ['/O']],
        ['Mat', u'labels', u'Mat()', ['/O']],
        ['Mat', u'probs', u'Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv.ml.EM.trainEM [ARG Mat samples=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
[   u'cv.ml.EM.trainE',
    u'bool',
    ['/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'means0', '', []],
        ['Mat', u'covs0', u'Mat()', []],
        ['Mat', u'weights0', u'Mat()', []],
        ['Mat', u'logLikelihoods', u'Mat()', ['/O']],
        ['Mat', u'labels', u'Mat()', ['/O']],
        ['Mat', u'probs', u'Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv.ml.EM.trainE [ARG Mat samples=, ARG Mat means0=, ARG Mat covs0=Mat(), ARG Mat weights0=Mat(), ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
[   u'cv.ml.EM.trainM',
    u'bool',
    ['/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'probs0', '', []],
        ['Mat', u'logLikelihoods', u'Mat()', ['/O']],
        ['Mat', u'labels', u'Mat()', ['/O']],
        ['Mat', u'probs', u'Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv.ml.EM.trainM [ARG Mat samples=, ARG Mat probs0=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>

--- Incoming ---
[u'cv.ml.EM.create', u'Ptr_EM', ['/S'], [], u'Ptr<EM>']
ok: FUNC <Ptr_EM cv.ml.EM.create []>

--- Incoming ---
[   u'cv.ml.EM.load',
    u'Ptr_EM',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<EM>']
ok: FUNC <Ptr_EM cv.ml.EM.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.DTrees', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.DTrees : StatModel, name: DTrees, base: StatModel

--- Incoming ---
[   u'enum cv.ml.DTrees.Flags',
    '',
    [],
    [   [u'const cv.ml.DTrees.PREDICT_AUTO', u'0', [], [], None, ''],
        [u'const cv.ml.DTrees.PREDICT_SUM', u'(1<<8)', [], [], None, ''],
        [u'const cv.ml.DTrees.PREDICT_MAX_VOTE', u'(2<<8)', [], [], None, ''],
        [u'const cv.ml.DTrees.PREDICT_MASK', u'(3<<8)', [], [], None, '']],
    None]
ok: CONST PREDICT_AUTO=0
ok: CONST PREDICT_SUM=(1<<8)
ok: CONST PREDICT_MAX_VOTE=(2<<8)
ok: CONST PREDICT_MASK=(3<<8)

--- Incoming ---
[u'cv.ml.DTrees.getMaxCategories', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.DTrees.getMaxCategories []>

--- Incoming ---
[   u'cv.ml.DTrees.setMaxCategories',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setMaxCategories [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getMaxDepth', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.DTrees.getMaxDepth []>

--- Incoming ---
[   u'cv.ml.DTrees.setMaxDepth',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setMaxDepth [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getMinSampleCount', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.DTrees.getMinSampleCount []>

--- Incoming ---
[   u'cv.ml.DTrees.setMinSampleCount',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setMinSampleCount [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getCVFolds', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.DTrees.getCVFolds []>

--- Incoming ---
[   u'cv.ml.DTrees.setCVFolds',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setCVFolds [ARG int val=]>

--- Incoming ---
[u'cv.ml.DTrees.getUseSurrogates', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.ml.DTrees.getUseSurrogates []>

--- Incoming ---
[   u'cv.ml.DTrees.setUseSurrogates',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setUseSurrogates [ARG bool val=]>

--- Incoming ---
[u'cv.ml.DTrees.getUse1SERule', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.ml.DTrees.getUse1SERule []>

--- Incoming ---
[   u'cv.ml.DTrees.setUse1SERule',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setUse1SERule [ARG bool val=]>

--- Incoming ---
[   u'cv.ml.DTrees.getTruncatePrunedTree',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.ml.DTrees.getTruncatePrunedTree []>

--- Incoming ---
[   u'cv.ml.DTrees.setTruncatePrunedTree',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setTruncatePrunedTree [ARG bool val=]>

--- Incoming ---
[   u'cv.ml.DTrees.getRegressionAccuracy',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ml.DTrees.getRegressionAccuracy []>

--- Incoming ---
[   u'cv.ml.DTrees.setRegressionAccuracy',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setRegressionAccuracy [ARG float val=]>

--- Incoming ---
[u'cv.ml.DTrees.getPriors', u'Mat', ['/C', '/V', '/PV'], [], u'cv::Mat']
ok: FUNC <Mat cv.ml.DTrees.getPriors []>

--- Incoming ---
[   u'cv.ml.DTrees.setPriors',
    u'void',
    ['/V', '/PV'],
    [[u'Mat', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.DTrees.setPriors [ARG Mat val=]>

--- Incoming ---
[u'cv.ml.DTrees.create', u'Ptr_DTrees', ['/S'], [], u'Ptr<DTrees>']
ok: FUNC <Ptr_DTrees cv.ml.DTrees.create []>

--- Incoming ---
[   u'cv.ml.DTrees.load',
    u'Ptr_DTrees',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<DTrees>']
ok: FUNC <Ptr_DTrees cv.ml.DTrees.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.RTrees', u': cv::ml::DTrees', [], [], None]
ok: class CLASS cv.ml::.RTrees : DTrees, name: RTrees, base: DTrees

--- Incoming ---
[   u'cv.ml.RTrees.getCalculateVarImportance',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.ml.RTrees.getCalculateVarImportance []>

--- Incoming ---
[   u'cv.ml.RTrees.setCalculateVarImportance',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.RTrees.setCalculateVarImportance [ARG bool val=]>

--- Incoming ---
[u'cv.ml.RTrees.getActiveVarCount', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.RTrees.getActiveVarCount []>

--- Incoming ---
[   u'cv.ml.RTrees.setActiveVarCount',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.RTrees.setActiveVarCount [ARG int val=]>

--- Incoming ---
[   u'cv.ml.RTrees.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.RTrees.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.RTrees.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.RTrees.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[u'cv.ml.RTrees.getVarImportance', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.RTrees.getVarImportance []>

--- Incoming ---
[   u'cv.ml.RTrees.getVotes',
    u'void',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'results', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv.ml.RTrees.getVotes [ARG Mat samples=, ARG Mat results=, ARG int flags=]>

--- Incoming ---
[u'cv.ml.RTrees.create', u'Ptr_RTrees', ['/S'], [], u'Ptr<RTrees>']
ok: FUNC <Ptr_RTrees cv.ml.RTrees.create []>

--- Incoming ---
[   u'cv.ml.RTrees.load',
    u'Ptr_RTrees',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<RTrees>']
ok: FUNC <Ptr_RTrees cv.ml.RTrees.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.Boost', u': cv::ml::DTrees', [], [], None]
ok: class CLASS cv.ml::.Boost : DTrees, name: Boost, base: DTrees

--- Incoming ---
[u'cv.ml.Boost.getBoostType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.Boost.getBoostType []>

--- Incoming ---
[   u'cv.ml.Boost.setBoostType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.Boost.setBoostType [ARG int val=]>

--- Incoming ---
[u'cv.ml.Boost.getWeakCount', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.Boost.getWeakCount []>

--- Incoming ---
[   u'cv.ml.Boost.setWeakCount',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.Boost.setWeakCount [ARG int val=]>

--- Incoming ---
[   u'cv.ml.Boost.getWeightTrimRate',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.Boost.getWeightTrimRate []>

--- Incoming ---
[   u'cv.ml.Boost.setWeightTrimRate',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.Boost.setWeightTrimRate [ARG double val=]>

--- Incoming ---
[   u'enum cv.ml.Boost.Types',
    '',
    [],
    [   [u'const cv.ml.Boost.DISCRETE', u'0', [], [], None, ''],
        [u'const cv.ml.Boost.REAL', u'1', [], [], None, ''],
        [u'const cv.ml.Boost.LOGIT', u'2', [], [], None, ''],
        [u'const cv.ml.Boost.GENTLE', u'3', [], [], None, '']],
    None]
ok: CONST DISCRETE=0
ok: CONST REAL=1
ok: CONST LOGIT=2
ok: CONST GENTLE=3

--- Incoming ---
[u'cv.ml.Boost.create', u'Ptr_Boost', ['/S'], [], u'Ptr<Boost>']
ok: FUNC <Ptr_Boost cv.ml.Boost.create []>

--- Incoming ---
[   u'cv.ml.Boost.load',
    u'Ptr_Boost',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<Boost>']
ok: FUNC <Ptr_Boost cv.ml.Boost.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.ANN_MLP', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.ANN_MLP : StatModel, name: ANN_MLP, base: StatModel

--- Incoming ---
[   u'enum cv.ml.ANN_MLP.TrainingMethods',
    '',
    [],
    [   [u'const cv.ml.ANN_MLP.BACKPROP', u'0', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.RPROP', u'1', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.ANNEAL', u'2', [], [], None, '']],
    None]
ok: CONST BACKPROP=0
ok: CONST RPROP=1
ok: CONST ANNEAL=2

--- Incoming ---
[   u'cv.ml.ANN_MLP.setTrainMethod',
    u'void',
    ['/V', '/PV'],
    [   [u'int', u'method', u'', []],
        [u'double', u'param1', u'0', []],
        [u'double', u'param2', u'0', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setTrainMethod [ARG int method=, ARG double param1=0, ARG double param2=0]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getTrainMethod', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.ANN_MLP.getTrainMethod []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setActivationFunction',
    u'void',
    ['/V', '/PV'],
    [   [u'int', u'type', u'', []],
        [u'double', u'param1', u'0', []],
        [u'double', u'param2', u'0', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setActivationFunction [ARG int type=, ARG double param1=0, ARG double param2=0]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setLayerSizes',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'_layer_sizes', '', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setLayerSizes [ARG Mat _layer_sizes=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getLayerSizes', u'Mat', ['/C', '/V', '/PV'], [], u'cv::Mat']
ok: FUNC <Mat cv.ml.ANN_MLP.getLayerSizes []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.ANN_MLP.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getBackpropWeightScale',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getBackpropWeightScale []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setBackpropWeightScale',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setBackpropWeightScale [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getBackpropMomentumScale',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getBackpropMomentumScale []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setBackpropMomentumScale',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setBackpropMomentumScale [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getRpropDW0', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDW0 []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDW0',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDW0 [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getRpropDWPlus',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWPlus []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWPlus',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWPlus [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getRpropDWMinus',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMinus []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWMinus',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMinus [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getRpropDWMin', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMin []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWMin',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMin [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getRpropDWMax', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ml.ANN_MLP.getRpropDWMax []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setRpropDWMax',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setRpropDWMax [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getAnnealInitialT',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getAnnealInitialT []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setAnnealInitialT',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealInitialT [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getAnnealFinalT',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getAnnealFinalT []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setAnnealFinalT',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealFinalT [ARG double val=]>

--- Incoming ---
[   u'cv.ml.ANN_MLP.getAnnealCoolingRatio',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.ANN_MLP.getAnnealCoolingRatio []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setAnnealCoolingRatio',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealCoolingRatio [ARG double val=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.getAnnealItePerStep', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.ANN_MLP.getAnnealItePerStep []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.setAnnealItePerStep',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.ANN_MLP.setAnnealItePerStep [ARG int val=]>

--- Incoming ---
[   u'enum cv.ml.ANN_MLP.ActivationFunctions',
    '',
    [],
    [   [u'const cv.ml.ANN_MLP.IDENTITY', u'0', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.SIGMOID_SYM', u'1', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.GAUSSIAN', u'2', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.RELU', u'3', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.LEAKYRELU', u'4', [], [], None, '']],
    None]
ok: CONST IDENTITY=0
ok: CONST SIGMOID_SYM=1
ok: CONST GAUSSIAN=2
ok: CONST RELU=3
ok: CONST LEAKYRELU=4

--- Incoming ---
[   u'enum cv.ml.ANN_MLP.TrainFlags',
    '',
    [],
    [   [u'const cv.ml.ANN_MLP.UPDATE_WEIGHTS', u'1', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.NO_INPUT_SCALE', u'2', [], [], None, ''],
        [u'const cv.ml.ANN_MLP.NO_OUTPUT_SCALE', u'4', [], [], None, '']],
    None]
ok: CONST UPDATE_WEIGHTS=1
ok: CONST NO_INPUT_SCALE=2
ok: CONST NO_OUTPUT_SCALE=4

--- Incoming ---
[   u'cv.ml.ANN_MLP.getWeights',
    u'Mat',
    ['/C', '/V', '/PV'],
    [[u'int', u'layerIdx', u'', []]],
    u'Mat']
ok: FUNC <Mat cv.ml.ANN_MLP.getWeights [ARG int layerIdx=]>

--- Incoming ---
[u'cv.ml.ANN_MLP.create', u'Ptr_ANN_MLP', ['/S'], [], u'Ptr<ANN_MLP>']
ok: FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.create []>

--- Incoming ---
[   u'cv.ml.ANN_MLP.load',
    u'Ptr_ANN_MLP',
    ['/S'],
    [[u'String', u'filepath', u'', ['/C', '/Ref']]],
    u'Ptr<ANN_MLP>']
ok: FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.load [ARG String filepath=]>

--- Incoming ---
[u'class cv.ml.LogisticRegression', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.LogisticRegression : StatModel, name: LogisticRegression, base: StatModel

--- Incoming ---
[   u'cv.ml.LogisticRegression.getLearningRate',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.ml.LogisticRegression.getLearningRate []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setLearningRate',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setLearningRate [ARG double val=]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.getIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ml.LogisticRegression.getIterations []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setIterations [ARG int val=]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.getRegularization',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ml.LogisticRegression.getRegularization []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setRegularization',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setRegularization [ARG int val=]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.getTrainMethod',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ml.LogisticRegression.getTrainMethod []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setTrainMethod',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setTrainMethod [ARG int val=]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.getMiniBatchSize',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.ml.LogisticRegression.getMiniBatchSize []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setMiniBatchSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setMiniBatchSize [ARG int val=]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.LogisticRegression.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.ml.LogisticRegression.setTermCriteria [ARG TermCriteria val=]>

--- Incoming ---
[   u'enum cv.ml.LogisticRegression.RegKinds',
    '',
    [],
    [   [   u'const cv.ml.LogisticRegression.REG_DISABLE',
            u'-1',
            [],
            [],
            None,
            ''],
        [u'const cv.ml.LogisticRegression.REG_L1', u'0', [], [], None, ''],
        [u'const cv.ml.LogisticRegression.REG_L2', u'1', [], [], None, '']],
    None]
ok: CONST REG_DISABLE=-1
ok: CONST REG_L1=0
ok: CONST REG_L2=1

--- Incoming ---
[   u'enum cv.ml.LogisticRegression.Methods',
    '',
    [],
    [   [u'const cv.ml.LogisticRegression.BATCH', u'0', [], [], None, ''],
        [   u'const cv.ml.LogisticRegression.MINI_BATCH',
            u'1',
            [],
            [],
            None,
            '']],
    None]
ok: CONST BATCH=0
ok: CONST MINI_BATCH=1

--- Incoming ---
[   u'cv.ml.LogisticRegression.predict',
    u'float',
    ['/C', '/V', '/PV'],
    [   ['Mat', u'samples', '', []],
        ['Mat', u'results', u'Mat()', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'float']
ok: FUNC <float cv.ml.LogisticRegression.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>

--- Incoming ---
[   u'cv.ml.LogisticRegression.get_learnt_thetas',
    u'Mat',
    ['/C', '/V', '/PV'],
    [],
    u'Mat']
ok: FUNC <Mat cv.ml.LogisticRegression.get_learnt_thetas []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.create',
    u'Ptr_LogisticRegression',
    ['/S'],
    [],
    u'Ptr<LogisticRegression>']
ok: FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.create []>

--- Incoming ---
[   u'cv.ml.LogisticRegression.load',
    u'Ptr_LogisticRegression',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<LogisticRegression>']
ok: FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[u'class cv.ml.SVMSGD', u': cv::ml::StatModel', [], [], None]
ok: class CLASS cv.ml::.SVMSGD : StatModel, name: SVMSGD, base: StatModel

--- Incoming ---
[   u'enum cv.ml.SVMSGD.SvmsgdType',
    '',
    [],
    [   [u'const cv.ml.SVMSGD.SGD', '0', [], [], None, ''],
        [u'const cv.ml.SVMSGD.ASGD', '1', [], [], None, '']],
    None]
ok: CONST SGD=0
ok: CONST ASGD=1

--- Incoming ---
[   u'enum cv.ml.SVMSGD.MarginType',
    '',
    [],
    [   [u'const cv.ml.SVMSGD.SOFT_MARGIN', '0', [], [], None, ''],
        [u'const cv.ml.SVMSGD.HARD_MARGIN', '1', [], [], None, '']],
    None]
ok: CONST SOFT_MARGIN=0
ok: CONST HARD_MARGIN=1

--- Incoming ---
[u'cv.ml.SVMSGD.getWeights', u'Mat', ['/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.ml.SVMSGD.getWeights []>

--- Incoming ---
[u'cv.ml.SVMSGD.getShift', u'float', ['/V', '/PV'], [], u'float']
ok: FUNC <float cv.ml.SVMSGD.getShift []>

--- Incoming ---
[u'cv.ml.SVMSGD.create', u'Ptr_SVMSGD', ['/S'], [], u'Ptr<SVMSGD>']
ok: FUNC <Ptr_SVMSGD cv.ml.SVMSGD.create []>

--- Incoming ---
[   u'cv.ml.SVMSGD.load',
    u'Ptr_SVMSGD',
    ['/S'],
    [   [u'String', u'filepath', u'', ['/C', '/Ref']],
        [u'String', u'nodeName', u'String()', ['/C', '/Ref']]],
    u'Ptr<SVMSGD>']
ok: FUNC <Ptr_SVMSGD cv.ml.SVMSGD.load [ARG String filepath=, ARG String nodeName=String()]>

--- Incoming ---
[   u'cv.ml.SVMSGD.setOptimalParameters',
    u'void',
    ['/V', '/PV'],
    [   [u'int', u'svmsgdType', u'SVMSGD::ASGD', []],
        [u'int', u'marginType', u'SVMSGD::SOFT_MARGIN', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setOptimalParameters [ARG int svmsgdType=SVMSGD::ASGD, ARG int marginType=SVMSGD::SOFT_MARGIN]>

--- Incoming ---
[u'cv.ml.SVMSGD.getSvmsgdType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.SVMSGD.getSvmsgdType []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setSvmsgdType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'svmsgdType', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setSvmsgdType [ARG int svmsgdType=]>

--- Incoming ---
[u'cv.ml.SVMSGD.getMarginType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ml.SVMSGD.getMarginType []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setMarginType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'marginType', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setMarginType [ARG int marginType=]>

--- Incoming ---
[   u'cv.ml.SVMSGD.getMarginRegularization',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ml.SVMSGD.getMarginRegularization []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setMarginRegularization',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'marginRegularization', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setMarginRegularization [ARG float marginRegularization=]>

--- Incoming ---
[   u'cv.ml.SVMSGD.getInitialStepSize',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ml.SVMSGD.getInitialStepSize []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setInitialStepSize',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'InitialStepSize', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setInitialStepSize [ARG float InitialStepSize=]>

--- Incoming ---
[   u'cv.ml.SVMSGD.getStepDecreasingPower',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.ml.SVMSGD.getStepDecreasingPower []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setStepDecreasingPower',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'stepDecreasingPower', u'', []]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setStepDecreasingPower [ARG float stepDecreasingPower=]>

--- Incoming ---
[   u'cv.ml.SVMSGD.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.ml.SVMSGD.getTermCriteria []>

--- Incoming ---
[   u'cv.ml.SVMSGD.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'val', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.ml.SVMSGD.setTermCriteria [ARG TermCriteria val=]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/ml/include/opencv2/ml/ml.hpp =====
Namespaces: set([u'cv', u'cv.ml'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/ml/include/opencv2/ml/ml.hpp


===== Generating... =====
CLASS cv.ml::.EM : StatModel
[CONST COV_MAT_SPHERICAL=0, CONST COV_MAT_DIAGONAL=1, CONST COV_MAT_GENERIC=2, CONST COV_MAT_DEFAULT=COV_MAT_DIAGONAL]
[CONST DEFAULT_NCLUSTERS=5, CONST DEFAULT_MAX_ITERS=100, CONST START_E_STEP=1, CONST START_M_STEP=2, CONST START_AUTO_STEP=0]
FUNC <Mat cv.ml.EM.getMeans []>
java: Mat getMeans()
FUNC <Mat cv.ml.EM.getWeights []>
java: Mat getWeights()
FUNC <Ptr_EM cv.ml.EM.create []>
java: EM create()
FUNC <Ptr_EM cv.ml.EM.load [ARG String filepath=, ARG String nodeName=String()]>
java: EM load(String filepath, String nodeName)
java: EM load(String filepath)
FUNC <TermCriteria cv.ml.EM.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <Vec2d cv.ml.EM.predict2 [ARG Mat sample=, ARG Mat probs=]>
java: double[] predict2(Mat sample, Mat probs)
FUNC <bool cv.ml.EM.trainE [ARG Mat samples=, ARG Mat means0=, ARG Mat covs0=Mat(), ARG Mat weights0=Mat(), ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0, Mat logLikelihoods, Mat labels)
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0, Mat logLikelihoods)
java: boolean trainE(Mat samples, Mat means0, Mat covs0, Mat weights0)
java: boolean trainE(Mat samples, Mat means0, Mat covs0)
java: boolean trainE(Mat samples, Mat means0)
FUNC <bool cv.ml.EM.trainEM [ARG Mat samples=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainEM(Mat samples, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainEM(Mat samples, Mat logLikelihoods, Mat labels)
java: boolean trainEM(Mat samples, Mat logLikelihoods)
java: boolean trainEM(Mat samples)
FUNC <bool cv.ml.EM.trainM [ARG Mat samples=, ARG Mat probs0=, ARG Mat logLikelihoods=Mat(), ARG Mat labels=Mat(), ARG Mat probs=Mat()]>
java: boolean trainM(Mat samples, Mat probs0, Mat logLikelihoods, Mat labels, Mat probs)
java: boolean trainM(Mat samples, Mat probs0, Mat logLikelihoods, Mat labels)
java: boolean trainM(Mat samples, Mat probs0, Mat logLikelihoods)
java: boolean trainM(Mat samples, Mat probs0)
FUNC <float cv.ml.EM.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>
java: float predict(Mat samples, Mat results, int flags)
java: float predict(Mat samples, Mat results)
java: float predict(Mat samples)
FUNC <int cv.ml.EM.getClustersNumber []>
java: int getClustersNumber()
FUNC <int cv.ml.EM.getCovarianceMatrixType []>
java: int getCovarianceMatrixType()
FUNC <void cv.ml.EM.getCovs [ARG vector_Mat covs=]>
java: void getCovs(List<Mat> covs)
FUNC <void cv.ml.EM.setClustersNumber [ARG int val=]>
java: void setClustersNumber(int val)
FUNC <void cv.ml.EM.setCovarianceMatrixType [ARG int val=]>
java: void setCovarianceMatrixType(int val)
FUNC <void cv.ml.EM.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
CLASS cv.ml::.SVM : StatModel
[CONST CUSTOM=-1, CONST LINEAR=0, CONST POLY=1, CONST RBF=2, CONST SIGMOID=3, CONST CHI2=4, CONST INTER=5]
[CONST C_SVC=100, CONST NU_SVC=101, CONST ONE_CLASS=102, CONST EPS_SVR=103, CONST NU_SVR=104]
[CONST C=0, CONST GAMMA=1, CONST P=2, CONST NU=3, CONST COEF=4, CONST DEGREE=5]
FUNC <Mat cv.ml.SVM.getClassWeights []>
java: Mat getClassWeights()
FUNC <Mat cv.ml.SVM.getSupportVectors []>
java: Mat getSupportVectors()
FUNC <Mat cv.ml.SVM.getUncompressedSupportVectors []>
java: Mat getUncompressedSupportVectors()
FUNC <Ptr_ParamGrid cv.ml.SVM.getDefaultGridPtr [ARG int param_id=]>
java: ParamGrid getDefaultGridPtr(int param_id)
FUNC <Ptr_SVM cv.ml.SVM.create []>
java: SVM create()
FUNC <Ptr_SVM cv.ml.SVM.load [ARG String filepath=]>
java: SVM load(String filepath)
FUNC <TermCriteria cv.ml.SVM.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <bool cv.ml.SVM.trainAuto [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG int kFold=10, ARG Ptr_ParamGrid Cgrid=SVM::getDefaultGridPtr(SVM::C), ARG Ptr_ParamGrid gammaGrid=SVM::getDefaultGridPtr(SVM::GAMMA), ARG Ptr_ParamGrid pGrid=SVM::getDefaultGridPtr(SVM::P), ARG Ptr_ParamGrid nuGrid=SVM::getDefaultGridPtr(SVM::NU), ARG Ptr_ParamGrid coeffGrid=SVM::getDefaultGridPtr(SVM::COEF), ARG Ptr_ParamGrid degreeGrid=SVM::getDefaultGridPtr(SVM::DEGREE), ARG bool balanced=false]>
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid, ParamGrid coeffGrid, ParamGrid degreeGrid, boolean balanced)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid, ParamGrid coeffGrid, ParamGrid degreeGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid, ParamGrid coeffGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid, ParamGrid nuGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid, ParamGrid pGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid, ParamGrid gammaGrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold, ParamGrid Cgrid)
java: boolean trainAuto(Mat samples, int layout, Mat responses, int kFold)
java: boolean trainAuto(Mat samples, int layout, Mat responses)
FUNC <double cv.ml.SVM.getC []>
java: double getC()
FUNC <double cv.ml.SVM.getCoef0 []>
java: double getCoef0()
FUNC <double cv.ml.SVM.getDecisionFunction [ARG int i=, ARG Mat alpha=, ARG Mat svidx=]>
java: double getDecisionFunction(int i, Mat alpha, Mat svidx)
FUNC <double cv.ml.SVM.getDegree []>
java: double getDegree()
FUNC <double cv.ml.SVM.getGamma []>
java: double getGamma()
FUNC <double cv.ml.SVM.getNu []>
java: double getNu()
FUNC <double cv.ml.SVM.getP []>
java: double getP()
FUNC <int cv.ml.SVM.getKernelType []>
java: int getKernelType()
FUNC <int cv.ml.SVM.getType []>
java: int getType()
FUNC <void cv.ml.SVM.setC [ARG double val=]>
java: void setC(double val)
FUNC <void cv.ml.SVM.setClassWeights [ARG Mat val=]>
java: void setClassWeights(Mat val)
FUNC <void cv.ml.SVM.setCoef0 [ARG double val=]>
java: void setCoef0(double val)
FUNC <void cv.ml.SVM.setDegree [ARG double val=]>
java: void setDegree(double val)
FUNC <void cv.ml.SVM.setGamma [ARG double val=]>
java: void setGamma(double val)
FUNC <void cv.ml.SVM.setKernel [ARG int kernelType=]>
java: void setKernel(int kernelType)
FUNC <void cv.ml.SVM.setNu [ARG double val=]>
java: void setNu(double val)
FUNC <void cv.ml.SVM.setP [ARG double val=]>
java: void setP(double val)
FUNC <void cv.ml.SVM.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <void cv.ml.SVM.setType [ARG int val=]>
java: void setType(int val)
CLASS ::.Ml : 
[CONST ROW_SAMPLE=0, CONST COL_SAMPLE=1]
[CONST VAR_NUMERICAL=0, CONST VAR_ORDERED=0, CONST VAR_CATEGORICAL=1]
[CONST TEST_ERROR=0, CONST TRAIN_ERROR=1]
CLASS cv.ml::.NormalBayesClassifier : StatModel
FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.create []>
java: NormalBayesClassifier create()
FUNC <Ptr_NormalBayesClassifier cv.ml.NormalBayesClassifier.load [ARG String filepath=, ARG String nodeName=String()]>
java: NormalBayesClassifier load(String filepath, String nodeName)
java: NormalBayesClassifier load(String filepath)
FUNC <float cv.ml.NormalBayesClassifier.predictProb [ARG Mat inputs=, ARG Mat outputs=, ARG Mat outputProbs=, ARG int flags=0]>
java: float predictProb(Mat inputs, Mat outputs, Mat outputProbs, int flags)
java: float predictProb(Mat inputs, Mat outputs, Mat outputProbs)
CLASS cv.ml::.TrainData : 
FUNC <Mat cv.ml.TrainData.getCatMap []>
java: Mat getCatMap()
FUNC <Mat cv.ml.TrainData.getCatOfs []>
java: Mat getCatOfs()
FUNC <Mat cv.ml.TrainData.getClassLabels []>
java: Mat getClassLabels()
FUNC <Mat cv.ml.TrainData.getDefaultSubstValues []>
java: Mat getDefaultSubstValues()
FUNC <Mat cv.ml.TrainData.getMissing []>
java: Mat getMissing()
FUNC <Mat cv.ml.TrainData.getNormCatResponses []>
java: Mat getNormCatResponses()
FUNC <Mat cv.ml.TrainData.getResponses []>
java: Mat getResponses()
FUNC <Mat cv.ml.TrainData.getSampleWeights []>
java: Mat getSampleWeights()
FUNC <Mat cv.ml.TrainData.getSamples []>
java: Mat getSamples()
FUNC <Mat cv.ml.TrainData.getSubMatrix [ARG Mat matrix=, ARG Mat idx=, ARG int layout=]>
java: Mat getSubMatrix(Mat matrix, Mat idx, int layout)
FUNC <Mat cv.ml.TrainData.getSubVector [ARG Mat vec=, ARG Mat idx=]>
java: Mat getSubVector(Mat vec, Mat idx)
FUNC <Mat cv.ml.TrainData.getTestNormCatResponses []>
java: Mat getTestNormCatResponses()
FUNC <Mat cv.ml.TrainData.getTestResponses []>
java: Mat getTestResponses()
FUNC <Mat cv.ml.TrainData.getTestSampleIdx []>
java: Mat getTestSampleIdx()
FUNC <Mat cv.ml.TrainData.getTestSampleWeights []>
java: Mat getTestSampleWeights()
FUNC <Mat cv.ml.TrainData.getTestSamples []>
java: Mat getTestSamples()
FUNC <Mat cv.ml.TrainData.getTrainNormCatResponses []>
java: Mat getTrainNormCatResponses()
FUNC <Mat cv.ml.TrainData.getTrainResponses []>
java: Mat getTrainResponses()
FUNC <Mat cv.ml.TrainData.getTrainSampleIdx []>
java: Mat getTrainSampleIdx()
FUNC <Mat cv.ml.TrainData.getTrainSampleWeights []>
java: Mat getTrainSampleWeights()
FUNC <Mat cv.ml.TrainData.getTrainSamples [ARG int layout=ROW_SAMPLE, ARG bool compressSamples=true, ARG bool compressVars=true]>
java: Mat getTrainSamples(int layout, boolean compressSamples, boolean compressVars)
java: Mat getTrainSamples(int layout, boolean compressSamples)
java: Mat getTrainSamples(int layout)
java: Mat getTrainSamples()
FUNC <Mat cv.ml.TrainData.getVarIdx []>
java: Mat getVarIdx()
FUNC <Mat cv.ml.TrainData.getVarSymbolFlags []>
java: Mat getVarSymbolFlags()
FUNC <Mat cv.ml.TrainData.getVarType []>
java: Mat getVarType()
FUNC <Ptr_TrainData cv.ml.TrainData.create [ARG Mat samples=, ARG int layout=, ARG Mat responses=, ARG Mat varIdx=Mat(), ARG Mat sampleIdx=Mat(), ARG Mat sampleWeights=Mat(), ARG Mat varType=Mat()]>
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx, Mat sampleIdx, Mat sampleWeights, Mat varType)
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx, Mat sampleIdx, Mat sampleWeights)
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx, Mat sampleIdx)
java: TrainData create(Mat samples, int layout, Mat responses, Mat varIdx)
java: TrainData create(Mat samples, int layout, Mat responses)
FUNC <int cv.ml.TrainData.getCatCount [ARG int vi=]>
java: int getCatCount(int vi)
FUNC <int cv.ml.TrainData.getLayout []>
java: int getLayout()
FUNC <int cv.ml.TrainData.getNAllVars []>
java: int getNAllVars()
FUNC <int cv.ml.TrainData.getNSamples []>
java: int getNSamples()
FUNC <int cv.ml.TrainData.getNTestSamples []>
java: int getNTestSamples()
FUNC <int cv.ml.TrainData.getNTrainSamples []>
java: int getNTrainSamples()
FUNC <int cv.ml.TrainData.getNVars []>
java: int getNVars()
FUNC <int cv.ml.TrainData.getResponseType []>
java: int getResponseType()
FUNC <void cv.ml.TrainData.getNames [ARG vector_String names=]>
java: void getNames(List<String> names)
FUNC <void cv.ml.TrainData.getSample [ARG Mat varIdx=, ARG int sidx=, ARG float * buf=]>
java: void getSample(Mat varIdx, int sidx, float buf)
FUNC <void cv.ml.TrainData.getValues [ARG int vi=, ARG Mat sidx=, ARG float * values=]>
java: void getValues(int vi, Mat sidx, float values)
FUNC <void cv.ml.TrainData.setTrainTestSplit [ARG int count=, ARG bool shuffle=true]>
java: void setTrainTestSplit(int count, boolean shuffle)
java: void setTrainTestSplit(int count)
FUNC <void cv.ml.TrainData.setTrainTestSplitRatio [ARG double ratio=, ARG bool shuffle=true]>
java: void setTrainTestSplitRatio(double ratio, boolean shuffle)
java: void setTrainTestSplitRatio(double ratio)
FUNC <void cv.ml.TrainData.shuffleTrainTest []>
java: void shuffleTrainTest()
CLASS cv.ml::.Boost : DTrees
[CONST DISCRETE=0, CONST REAL=1, CONST LOGIT=2, CONST GENTLE=3]
FUNC <Ptr_Boost cv.ml.Boost.create []>
java: Boost create()
FUNC <Ptr_Boost cv.ml.Boost.load [ARG String filepath=, ARG String nodeName=String()]>
java: Boost load(String filepath, String nodeName)
java: Boost load(String filepath)
FUNC <double cv.ml.Boost.getWeightTrimRate []>
java: double getWeightTrimRate()
FUNC <int cv.ml.Boost.getBoostType []>
java: int getBoostType()
FUNC <int cv.ml.Boost.getWeakCount []>
java: int getWeakCount()
FUNC <void cv.ml.Boost.setBoostType [ARG int val=]>
java: void setBoostType(int val)
FUNC <void cv.ml.Boost.setWeakCount [ARG int val=]>
java: void setWeakCount(int val)
FUNC <void cv.ml.Boost.setWeightTrimRate [ARG double val=]>
java: void setWeightTrimRate(double val)
CLASS cv.ml::.LogisticRegression : StatModel
[CONST REG_DISABLE=-1, CONST REG_L1=0, CONST REG_L2=1]
[CONST BATCH=0, CONST MINI_BATCH=1]
FUNC <Mat cv.ml.LogisticRegression.get_learnt_thetas []>
java: Mat get_learnt_thetas()
FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.create []>
java: LogisticRegression create()
FUNC <Ptr_LogisticRegression cv.ml.LogisticRegression.load [ARG String filepath=, ARG String nodeName=String()]>
java: LogisticRegression load(String filepath, String nodeName)
java: LogisticRegression load(String filepath)
FUNC <TermCriteria cv.ml.LogisticRegression.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <double cv.ml.LogisticRegression.getLearningRate []>
java: double getLearningRate()
FUNC <float cv.ml.LogisticRegression.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>
java: float predict(Mat samples, Mat results, int flags)
java: float predict(Mat samples, Mat results)
java: float predict(Mat samples)
FUNC <int cv.ml.LogisticRegression.getIterations []>
java: int getIterations()
FUNC <int cv.ml.LogisticRegression.getMiniBatchSize []>
java: int getMiniBatchSize()
FUNC <int cv.ml.LogisticRegression.getRegularization []>
java: int getRegularization()
FUNC <int cv.ml.LogisticRegression.getTrainMethod []>
java: int getTrainMethod()
FUNC <void cv.ml.LogisticRegression.setIterations [ARG int val=]>
java: void setIterations(int val)
FUNC <void cv.ml.LogisticRegression.setLearningRate [ARG double val=]>
java: void setLearningRate(double val)
FUNC <void cv.ml.LogisticRegression.setMiniBatchSize [ARG int val=]>
java: void setMiniBatchSize(int val)
FUNC <void cv.ml.LogisticRegression.setRegularization [ARG int val=]>
java: void setRegularization(int val)
FUNC <void cv.ml.LogisticRegression.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <void cv.ml.LogisticRegression.setTrainMethod [ARG int val=]>
java: void setTrainMethod(int val)
CLASS cv.ml::.ParamGrid : 
FUNC <Ptr_ParamGrid cv.ml.ParamGrid.create [ARG double minVal=0., ARG double maxVal=0., ARG double logstep=1.]>
java: ParamGrid create(double minVal, double maxVal, double logstep)
java: ParamGrid create(double minVal, double maxVal)
java: ParamGrid create(double minVal)
java: ParamGrid create()
FUNC <double cv.ml.ParamGrid.get_minVal []>
java: double get_minVal()
FUNC <void cv.ml.ParamGrid.set_minVal [ARG double minVal=]>
java: void set_minVal(double minVal)
FUNC <double cv.ml.ParamGrid.get_maxVal []>
java: double get_maxVal()
FUNC <void cv.ml.ParamGrid.set_maxVal [ARG double maxVal=]>
java: void set_maxVal(double maxVal)
FUNC <double cv.ml.ParamGrid.get_logStep []>
java: double get_logStep()
FUNC <void cv.ml.ParamGrid.set_logStep [ARG double logStep=]>
java: void set_logStep(double logStep)
CLASS cv.ml::.KNearest : StatModel
[CONST BRUTE_FORCE=1, CONST KDTREE=2]
FUNC <Ptr_KNearest cv.ml.KNearest.create []>
java: KNearest create()
FUNC <Ptr_KNearest cv.ml.KNearest.load [ARG String filepath=]>
java: KNearest load(String filepath)
FUNC <bool cv.ml.KNearest.getIsClassifier []>
java: boolean getIsClassifier()
FUNC <float cv.ml.KNearest.findNearest [ARG Mat samples=, ARG int k=, ARG Mat results=, ARG Mat neighborResponses=Mat(), ARG Mat dist=Mat()]>
java: float findNearest(Mat samples, int k, Mat results, Mat neighborResponses, Mat dist)
java: float findNearest(Mat samples, int k, Mat results, Mat neighborResponses)
java: float findNearest(Mat samples, int k, Mat results)
FUNC <int cv.ml.KNearest.getAlgorithmType []>
java: int getAlgorithmType()
FUNC <int cv.ml.KNearest.getDefaultK []>
java: int getDefaultK()
FUNC <int cv.ml.KNearest.getEmax []>
java: int getEmax()
FUNC <void cv.ml.KNearest.setAlgorithmType [ARG int val=]>
java: void setAlgorithmType(int val)
FUNC <void cv.ml.KNearest.setDefaultK [ARG int val=]>
java: void setDefaultK(int val)
FUNC <void cv.ml.KNearest.setEmax [ARG int val=]>
java: void setEmax(int val)
FUNC <void cv.ml.KNearest.setIsClassifier [ARG bool val=]>
java: void setIsClassifier(boolean val)
CLASS cv.ml::.SVMSGD : StatModel
[CONST SGD=0, CONST ASGD=1]
[CONST SOFT_MARGIN=0, CONST HARD_MARGIN=1]
FUNC <Mat cv.ml.SVMSGD.getWeights []>
java: Mat getWeights()
FUNC <Ptr_SVMSGD cv.ml.SVMSGD.create []>
java: SVMSGD create()
FUNC <Ptr_SVMSGD cv.ml.SVMSGD.load [ARG String filepath=, ARG String nodeName=String()]>
java: SVMSGD load(String filepath, String nodeName)
java: SVMSGD load(String filepath)
FUNC <TermCriteria cv.ml.SVMSGD.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <float cv.ml.SVMSGD.getInitialStepSize []>
java: float getInitialStepSize()
FUNC <float cv.ml.SVMSGD.getMarginRegularization []>
java: float getMarginRegularization()
FUNC <float cv.ml.SVMSGD.getShift []>
java: float getShift()
FUNC <float cv.ml.SVMSGD.getStepDecreasingPower []>
java: float getStepDecreasingPower()
FUNC <int cv.ml.SVMSGD.getMarginType []>
java: int getMarginType()
FUNC <int cv.ml.SVMSGD.getSvmsgdType []>
java: int getSvmsgdType()
FUNC <void cv.ml.SVMSGD.setInitialStepSize [ARG float InitialStepSize=]>
java: void setInitialStepSize(float InitialStepSize)
FUNC <void cv.ml.SVMSGD.setMarginRegularization [ARG float marginRegularization=]>
java: void setMarginRegularization(float marginRegularization)
FUNC <void cv.ml.SVMSGD.setMarginType [ARG int marginType=]>
java: void setMarginType(int marginType)
FUNC <void cv.ml.SVMSGD.setOptimalParameters [ARG int svmsgdType=SVMSGD::ASGD, ARG int marginType=SVMSGD::SOFT_MARGIN]>
java: void setOptimalParameters(int svmsgdType, int marginType)
java: void setOptimalParameters(int svmsgdType)
java: void setOptimalParameters()
FUNC <void cv.ml.SVMSGD.setStepDecreasingPower [ARG float stepDecreasingPower=]>
java: void setStepDecreasingPower(float stepDecreasingPower)
FUNC <void cv.ml.SVMSGD.setSvmsgdType [ARG int svmsgdType=]>
java: void setSvmsgdType(int svmsgdType)
FUNC <void cv.ml.SVMSGD.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
CLASS cv.ml::.DTrees : StatModel
[CONST PREDICT_AUTO=0, CONST PREDICT_SUM=(1<<8), CONST PREDICT_MAX_VOTE=(2<<8), CONST PREDICT_MASK=(3<<8)]
FUNC <Mat cv.ml.DTrees.getPriors []>
java: Mat getPriors()
FUNC <Ptr_DTrees cv.ml.DTrees.create []>
java: DTrees create()
FUNC <Ptr_DTrees cv.ml.DTrees.load [ARG String filepath=, ARG String nodeName=String()]>
java: DTrees load(String filepath, String nodeName)
java: DTrees load(String filepath)
FUNC <bool cv.ml.DTrees.getTruncatePrunedTree []>
java: boolean getTruncatePrunedTree()
FUNC <bool cv.ml.DTrees.getUse1SERule []>
java: boolean getUse1SERule()
FUNC <bool cv.ml.DTrees.getUseSurrogates []>
java: boolean getUseSurrogates()
FUNC <float cv.ml.DTrees.getRegressionAccuracy []>
java: float getRegressionAccuracy()
FUNC <int cv.ml.DTrees.getCVFolds []>
java: int getCVFolds()
FUNC <int cv.ml.DTrees.getMaxCategories []>
java: int getMaxCategories()
FUNC <int cv.ml.DTrees.getMaxDepth []>
java: int getMaxDepth()
FUNC <int cv.ml.DTrees.getMinSampleCount []>
java: int getMinSampleCount()
FUNC <void cv.ml.DTrees.setCVFolds [ARG int val=]>
java: void setCVFolds(int val)
FUNC <void cv.ml.DTrees.setMaxCategories [ARG int val=]>
java: void setMaxCategories(int val)
FUNC <void cv.ml.DTrees.setMaxDepth [ARG int val=]>
java: void setMaxDepth(int val)
FUNC <void cv.ml.DTrees.setMinSampleCount [ARG int val=]>
java: void setMinSampleCount(int val)
FUNC <void cv.ml.DTrees.setPriors [ARG Mat val=]>
java: void setPriors(Mat val)
FUNC <void cv.ml.DTrees.setRegressionAccuracy [ARG float val=]>
java: void setRegressionAccuracy(float val)
FUNC <void cv.ml.DTrees.setTruncatePrunedTree [ARG bool val=]>
java: void setTruncatePrunedTree(boolean val)
FUNC <void cv.ml.DTrees.setUse1SERule [ARG bool val=]>
java: void setUse1SERule(boolean val)
FUNC <void cv.ml.DTrees.setUseSurrogates [ARG bool val=]>
java: void setUseSurrogates(boolean val)
CLASS cv.ml::.ANN_MLP : StatModel
[CONST BACKPROP=0, CONST RPROP=1, CONST ANNEAL=2]
[CONST UPDATE_WEIGHTS=1, CONST NO_INPUT_SCALE=2, CONST NO_OUTPUT_SCALE=4]
[CONST IDENTITY=0, CONST SIGMOID_SYM=1, CONST GAUSSIAN=2, CONST RELU=3, CONST LEAKYRELU=4]
FUNC <Mat cv.ml.ANN_MLP.getLayerSizes []>
java: Mat getLayerSizes()
FUNC <Mat cv.ml.ANN_MLP.getWeights [ARG int layerIdx=]>
java: Mat getWeights(int layerIdx)
FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.create []>
java: ANN_MLP create()
FUNC <Ptr_ANN_MLP cv.ml.ANN_MLP.load [ARG String filepath=]>
java: ANN_MLP load(String filepath)
FUNC <TermCriteria cv.ml.ANN_MLP.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <double cv.ml.ANN_MLP.getAnnealCoolingRatio []>
java: double getAnnealCoolingRatio()
FUNC <double cv.ml.ANN_MLP.getAnnealFinalT []>
java: double getAnnealFinalT()
FUNC <double cv.ml.ANN_MLP.getAnnealInitialT []>
java: double getAnnealInitialT()
FUNC <double cv.ml.ANN_MLP.getBackpropMomentumScale []>
java: double getBackpropMomentumScale()
FUNC <double cv.ml.ANN_MLP.getBackpropWeightScale []>
java: double getBackpropWeightScale()
FUNC <double cv.ml.ANN_MLP.getRpropDW0 []>
java: double getRpropDW0()
FUNC <double cv.ml.ANN_MLP.getRpropDWMax []>
java: double getRpropDWMax()
FUNC <double cv.ml.ANN_MLP.getRpropDWMin []>
java: double getRpropDWMin()
FUNC <double cv.ml.ANN_MLP.getRpropDWMinus []>
java: double getRpropDWMinus()
FUNC <double cv.ml.ANN_MLP.getRpropDWPlus []>
java: double getRpropDWPlus()
FUNC <int cv.ml.ANN_MLP.getAnnealItePerStep []>
java: int getAnnealItePerStep()
FUNC <int cv.ml.ANN_MLP.getTrainMethod []>
java: int getTrainMethod()
FUNC <void cv.ml.ANN_MLP.setActivationFunction [ARG int type=, ARG double param1=0, ARG double param2=0]>
java: void setActivationFunction(int type, double param1, double param2)
java: void setActivationFunction(int type, double param1)
java: void setActivationFunction(int type)
FUNC <void cv.ml.ANN_MLP.setAnnealCoolingRatio [ARG double val=]>
java: void setAnnealCoolingRatio(double val)
FUNC <void cv.ml.ANN_MLP.setAnnealFinalT [ARG double val=]>
java: void setAnnealFinalT(double val)
FUNC <void cv.ml.ANN_MLP.setAnnealInitialT [ARG double val=]>
java: void setAnnealInitialT(double val)
FUNC <void cv.ml.ANN_MLP.setAnnealItePerStep [ARG int val=]>
java: void setAnnealItePerStep(int val)
FUNC <void cv.ml.ANN_MLP.setBackpropMomentumScale [ARG double val=]>
java: void setBackpropMomentumScale(double val)
FUNC <void cv.ml.ANN_MLP.setBackpropWeightScale [ARG double val=]>
java: void setBackpropWeightScale(double val)
FUNC <void cv.ml.ANN_MLP.setLayerSizes [ARG Mat _layer_sizes=]>
java: void setLayerSizes(Mat _layer_sizes)
FUNC <void cv.ml.ANN_MLP.setRpropDW0 [ARG double val=]>
java: void setRpropDW0(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWMax [ARG double val=]>
java: void setRpropDWMax(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWMin [ARG double val=]>
java: void setRpropDWMin(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWMinus [ARG double val=]>
java: void setRpropDWMinus(double val)
FUNC <void cv.ml.ANN_MLP.setRpropDWPlus [ARG double val=]>
java: void setRpropDWPlus(double val)
FUNC <void cv.ml.ANN_MLP.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)
FUNC <void cv.ml.ANN_MLP.setTrainMethod [ARG int method=, ARG double param1=0, ARG double param2=0]>
java: void setTrainMethod(int method, double param1, double param2)
java: void setTrainMethod(int method, double param1)
java: void setTrainMethod(int method)
CLASS cv.ml::.StatModel : Algorithm
[CONST UPDATE_MODEL=1, CONST RAW_OUTPUT=1, CONST COMPRESSED_INPUT=2, CONST PREPROCESSED_INPUT=4]
FUNC <bool cv.ml.StatModel.empty []>
java: boolean empty()
FUNC <bool cv.ml.StatModel.isClassifier []>
java: boolean isClassifier()
FUNC <bool cv.ml.StatModel.isTrained []>
java: boolean isTrained()
FUNC <bool cv.ml.StatModel.train [ARG Mat samples=, ARG int layout=, ARG Mat responses=]>
java: boolean train(Mat samples, int layout, Mat responses)
FUNC <bool cv.ml.StatModel.train [ARG Ptr_TrainData trainData=, ARG int flags=0]>
java: boolean train(TrainData trainData, int flags)
java: boolean train(TrainData trainData)
FUNC <float cv.ml.StatModel.calcError [ARG Ptr_TrainData data=, ARG bool test=, ARG Mat resp=]>
java: float calcError(TrainData data, boolean test, Mat resp)
FUNC <float cv.ml.StatModel.predict [ARG Mat samples=, ARG Mat results=Mat(), ARG int flags=0]>
java: float predict(Mat samples, Mat results, int flags)
java: float predict(Mat samples, Mat results)
java: float predict(Mat samples)
FUNC <int cv.ml.StatModel.getVarCount []>
java: int getVarCount()
CLASS cv.ml::.RTrees : DTrees
FUNC <Mat cv.ml.RTrees.getVarImportance []>
java: Mat getVarImportance()
FUNC <Ptr_RTrees cv.ml.RTrees.create []>
java: RTrees create()
FUNC <Ptr_RTrees cv.ml.RTrees.load [ARG String filepath=, ARG String nodeName=String()]>
java: RTrees load(String filepath, String nodeName)
java: RTrees load(String filepath)
FUNC <TermCriteria cv.ml.RTrees.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <bool cv.ml.RTrees.getCalculateVarImportance []>
java: boolean getCalculateVarImportance()
FUNC <int cv.ml.RTrees.getActiveVarCount []>
java: int getActiveVarCount()
FUNC <void cv.ml.RTrees.getVotes [ARG Mat samples=, ARG Mat results=, ARG int flags=]>
java: void getVotes(Mat samples, Mat results, int flags)
FUNC <void cv.ml.RTrees.setActiveVarCount [ARG int val=]>
java: void setActiveVarCount(int val)
FUNC <void cv.ml.RTrees.setCalculateVarImportance [ARG bool val=]>
java: void setCalculateVarImportance(boolean val)
FUNC <void cv.ml.RTrees.setTermCriteria [ARG TermCriteria val=]>
java: void setTermCriteria(TermCriteria val)

=== MODULE: photo (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/photo) ===


Files (3):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/photo/include/opencv2/photo.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/photo/include/opencv2/photo/cuda.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/photo/include/opencv2/photo/photo.hpp']

Common headers (0):
[]
ok: class CLASS ::.Photo : , name: Photo, base: 


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/photo/include/opencv2/photo.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.INPAINT_NS', u'0', [], [], None, ''],
        [u'const cv.INPAINT_TELEA', u'1', [], [], None, '']],
    None]
ok: CONST INPAINT_NS=0
ok: CONST INPAINT_TELEA=1

--- Incoming ---
[   u'cv.inpaint',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'inpaintMask', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'double', u'inpaintRadius', u'', []],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..inpaint [ARG Mat src=, ARG Mat inpaintMask=, ARG Mat dst=, ARG double inpaintRadius=, ARG int flags=]>

--- Incoming ---
[   u'cv.fastNlMeansDenoising',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'h', u'3', []],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   u'cv.fastNlMeansDenoising',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'vector_float', u'h', u'', ['/C', '/Ref']],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []],
        [u'int', u'normType', u'NORM_L2', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>

--- Incoming ---
[   u'cv.fastNlMeansDenoisingColored',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'h', u'3', []],
        [u'float', u'hColor', u'3', []],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoisingColored [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   u'cv.fastNlMeansDenoisingMulti',
    u'void',
    [],
    [   ['vector_Mat', u'srcImgs', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'imgToDenoiseIndex', u'', []],
        [u'int', u'temporalWindowSize', u'', []],
        [u'float', u'h', u'3', []],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   u'cv.fastNlMeansDenoisingMulti',
    u'void',
    [],
    [   ['vector_Mat', u'srcImgs', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'imgToDenoiseIndex', u'', []],
        [u'int', u'temporalWindowSize', u'', []],
        [u'vector_float', u'h', u'', ['/C', '/Ref']],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []],
        [u'int', u'normType', u'NORM_L2', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>

--- Incoming ---
[   u'cv.fastNlMeansDenoisingColoredMulti',
    u'void',
    [],
    [   ['vector_Mat', u'srcImgs', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'imgToDenoiseIndex', u'', []],
        [u'int', u'temporalWindowSize', u'', []],
        [u'float', u'h', u'3', []],
        [u'float', u'hColor', u'3', []],
        [u'int', u'templateWindowSize', u'7', []],
        [u'int', u'searchWindowSize', u'21', []]],
    u'void']
ok: FUNC <void cv..fastNlMeansDenoisingColoredMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>

--- Incoming ---
[   u'cv.denoise_TVL1',
    u'void',
    [],
    [   [u'vector_Mat', u'observations', u'', ['/C', '/Ref']],
        [u'Mat', u'result', u'', ['/Ref']],
        [u'double', u'lambda', u'1.0', []],
        [u'int', u'niters', u'30', []]],
    u'void']
ok: FUNC <void cv..denoise_TVL1 [ARG vector_Mat observations=, ARG Mat result=, ARG double lambda=1.0, ARG int niters=30]>

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [[u'const cv.LDR_SIZE', u'256', [], [], None, '']],
    None]
ok: CONST LDR_SIZE=256

--- Incoming ---
[u'class cv.Tonemap', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.Tonemap : Algorithm, name: Tonemap, base: Algorithm

--- Incoming ---
[   u'cv.Tonemap.process',
    u'void',
    ['/V', '/PV'],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.Tonemap.process [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[u'cv.Tonemap.getGamma', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.Tonemap.getGamma []>

--- Incoming ---
[   u'cv.Tonemap.setGamma',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'gamma', u'', []]],
    u'void']
ok: FUNC <void cv.Tonemap.setGamma [ARG float gamma=]>

--- Incoming ---
[   u'cv.createTonemap',
    u'Ptr_Tonemap',
    [],
    [[u'float', u'gamma', u'1.0f', []]],
    u'Ptr<Tonemap>']
ok: FUNC <Ptr_Tonemap cv..createTonemap [ARG float gamma=1.0f]>

--- Incoming ---
[u'class cv.TonemapDrago', u': cv::Tonemap', [], [], None]
ok: class CLASS cv::.TonemapDrago : Tonemap, name: TonemapDrago, base: Tonemap

--- Incoming ---
[u'cv.TonemapDrago.getSaturation', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.TonemapDrago.getSaturation []>

--- Incoming ---
[   u'cv.TonemapDrago.setSaturation',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'saturation', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapDrago.setSaturation [ARG float saturation=]>

--- Incoming ---
[u'cv.TonemapDrago.getBias', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.TonemapDrago.getBias []>

--- Incoming ---
[   u'cv.TonemapDrago.setBias',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'bias', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapDrago.setBias [ARG float bias=]>

--- Incoming ---
[   u'cv.createTonemapDrago',
    u'Ptr_TonemapDrago',
    [],
    [   [u'float', u'gamma', u'1.0f', []],
        [u'float', u'saturation', u'1.0f', []],
        [u'float', u'bias', u'0.85f', []]],
    u'Ptr<TonemapDrago>']
ok: FUNC <Ptr_TonemapDrago cv..createTonemapDrago [ARG float gamma=1.0f, ARG float saturation=1.0f, ARG float bias=0.85f]>

--- Incoming ---
[u'class cv.TonemapReinhard', u': cv::Tonemap', [], [], None]
ok: class CLASS cv::.TonemapReinhard : Tonemap, name: TonemapReinhard, base: Tonemap

--- Incoming ---
[   u'cv.TonemapReinhard.getIntensity',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.TonemapReinhard.getIntensity []>

--- Incoming ---
[   u'cv.TonemapReinhard.setIntensity',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'intensity', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapReinhard.setIntensity [ARG float intensity=]>

--- Incoming ---
[   u'cv.TonemapReinhard.getLightAdaptation',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.TonemapReinhard.getLightAdaptation []>

--- Incoming ---
[   u'cv.TonemapReinhard.setLightAdaptation',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'light_adapt', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapReinhard.setLightAdaptation [ARG float light_adapt=]>

--- Incoming ---
[   u'cv.TonemapReinhard.getColorAdaptation',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.TonemapReinhard.getColorAdaptation []>

--- Incoming ---
[   u'cv.TonemapReinhard.setColorAdaptation',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'color_adapt', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapReinhard.setColorAdaptation [ARG float color_adapt=]>

--- Incoming ---
[   u'cv.createTonemapReinhard',
    u'Ptr_TonemapReinhard',
    [],
    [   [u'float', u'gamma', u'1.0f', []],
        [u'float', u'intensity', u'0.0f', []],
        [u'float', u'light_adapt', u'1.0f', []],
        [u'float', u'color_adapt', u'0.0f', []]],
    u'Ptr<TonemapReinhard>']
ok: FUNC <Ptr_TonemapReinhard cv..createTonemapReinhard [ARG float gamma=1.0f, ARG float intensity=0.0f, ARG float light_adapt=1.0f, ARG float color_adapt=0.0f]>

--- Incoming ---
[u'class cv.TonemapMantiuk', u': cv::Tonemap', [], [], None]
ok: class CLASS cv::.TonemapMantiuk : Tonemap, name: TonemapMantiuk, base: Tonemap

--- Incoming ---
[u'cv.TonemapMantiuk.getScale', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.TonemapMantiuk.getScale []>

--- Incoming ---
[   u'cv.TonemapMantiuk.setScale',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'scale', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapMantiuk.setScale [ARG float scale=]>

--- Incoming ---
[   u'cv.TonemapMantiuk.getSaturation',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.TonemapMantiuk.getSaturation []>

--- Incoming ---
[   u'cv.TonemapMantiuk.setSaturation',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'saturation', u'', []]],
    u'void']
ok: FUNC <void cv.TonemapMantiuk.setSaturation [ARG float saturation=]>

--- Incoming ---
[   u'cv.createTonemapMantiuk',
    u'Ptr_TonemapMantiuk',
    [],
    [   [u'float', u'gamma', u'1.0f', []],
        [u'float', u'scale', u'0.7f', []],
        [u'float', u'saturation', u'1.0f', []]],
    u'Ptr<TonemapMantiuk>']
ok: FUNC <Ptr_TonemapMantiuk cv..createTonemapMantiuk [ARG float gamma=1.0f, ARG float scale=0.7f, ARG float saturation=1.0f]>

--- Incoming ---
[u'class cv.AlignExposures', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.AlignExposures : Algorithm, name: AlignExposures, base: Algorithm

--- Incoming ---
[   u'cv.AlignExposures.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        [u'vector_Mat', u'dst', u'', ['/Ref']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.AlignExposures.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[u'class cv.AlignMTB', u': cv::AlignExposures', [], [], None]
ok: class CLASS cv::.AlignMTB : AlignExposures, name: AlignMTB, base: AlignExposures

--- Incoming ---
[   u'cv.AlignMTB.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        [u'vector_Mat', u'dst', u'', ['/Ref']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   u'cv.AlignMTB.process',
    u'void',
    ['/V', '/PV'],
    [['vector_Mat', u'src', '', []], [u'vector_Mat', u'dst', u'', ['/Ref']]],
    u'void']
ok: FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=]>

--- Incoming ---
[   u'cv.AlignMTB.calculateShift',
    u'Point',
    ['/V', '/PV'],
    [['Mat', u'img0', '', []], ['Mat', u'img1', '', []]],
    u'Point']
ok: FUNC <Point cv.AlignMTB.calculateShift [ARG Mat img0=, ARG Mat img1=]>

--- Incoming ---
[   u'cv.AlignMTB.shiftMat',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'Point', u'shift', u'', ['/C']]],
    u'void']
ok: FUNC <void cv.AlignMTB.shiftMat [ARG Mat src=, ARG Mat dst=, ARG Point shift=]>

--- Incoming ---
[   u'cv.AlignMTB.computeBitmaps',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'img', '', []],
        ['Mat', u'tb', '', ['/O']],
        ['Mat', u'eb', '', ['/O']]],
    u'void']
ok: FUNC <void cv.AlignMTB.computeBitmaps [ARG Mat img=, ARG Mat tb=, ARG Mat eb=]>

--- Incoming ---
[u'cv.AlignMTB.getMaxBits', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AlignMTB.getMaxBits []>

--- Incoming ---
[   u'cv.AlignMTB.setMaxBits',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'max_bits', u'', []]],
    u'void']
ok: FUNC <void cv.AlignMTB.setMaxBits [ARG int max_bits=]>

--- Incoming ---
[u'cv.AlignMTB.getExcludeRange', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AlignMTB.getExcludeRange []>

--- Incoming ---
[   u'cv.AlignMTB.setExcludeRange',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'exclude_range', u'', []]],
    u'void']
ok: FUNC <void cv.AlignMTB.setExcludeRange [ARG int exclude_range=]>

--- Incoming ---
[u'cv.AlignMTB.getCut', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.AlignMTB.getCut []>

--- Incoming ---
[   u'cv.AlignMTB.setCut',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.AlignMTB.setCut [ARG bool value=]>

--- Incoming ---
[   u'cv.createAlignMTB',
    u'Ptr_AlignMTB',
    [],
    [   [u'int', u'max_bits', u'6', []],
        [u'int', u'exclude_range', u'4', []],
        [u'bool', u'cut', u'true', []]],
    u'Ptr<AlignMTB>']
ok: FUNC <Ptr_AlignMTB cv..createAlignMTB [ARG int max_bits=6, ARG int exclude_range=4, ARG bool cut=true]>

--- Incoming ---
[u'class cv.CalibrateCRF', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.CalibrateCRF : Algorithm, name: CalibrateCRF, base: Algorithm

--- Incoming ---
[   u'cv.CalibrateCRF.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []]],
    u'void']
ok: FUNC <void cv.CalibrateCRF.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>

--- Incoming ---
[u'class cv.CalibrateDebevec', u': cv::CalibrateCRF', [], [], None]
ok: class CLASS cv::.CalibrateDebevec : CalibrateCRF, name: CalibrateDebevec, base: CalibrateCRF

--- Incoming ---
[u'cv.CalibrateDebevec.getLambda', u'float', ['/C', '/V', '/PV'], [], u'float']
ok: FUNC <float cv.CalibrateDebevec.getLambda []>

--- Incoming ---
[   u'cv.CalibrateDebevec.setLambda',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'lambda', u'', []]],
    u'void']
ok: FUNC <void cv.CalibrateDebevec.setLambda [ARG float lambda=]>

--- Incoming ---
[u'cv.CalibrateDebevec.getSamples', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.CalibrateDebevec.getSamples []>

--- Incoming ---
[   u'cv.CalibrateDebevec.setSamples',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'samples', u'', []]],
    u'void']
ok: FUNC <void cv.CalibrateDebevec.setSamples [ARG int samples=]>

--- Incoming ---
[u'cv.CalibrateDebevec.getRandom', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.CalibrateDebevec.getRandom []>

--- Incoming ---
[   u'cv.CalibrateDebevec.setRandom',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'random', u'', []]],
    u'void']
ok: FUNC <void cv.CalibrateDebevec.setRandom [ARG bool random=]>

--- Incoming ---
[   u'cv.createCalibrateDebevec',
    u'Ptr_CalibrateDebevec',
    [],
    [   [u'int', u'samples', u'70', []],
        [u'float', u'lambda', u'10.0f', []],
        [u'bool', u'random', u'false', []]],
    u'Ptr<CalibrateDebevec>']
ok: FUNC <Ptr_CalibrateDebevec cv..createCalibrateDebevec [ARG int samples=70, ARG float lambda=10.0f, ARG bool random=false]>

--- Incoming ---
[u'class cv.CalibrateRobertson', u': cv::CalibrateCRF', [], [], None]
ok: class CLASS cv::.CalibrateRobertson : CalibrateCRF, name: CalibrateRobertson, base: CalibrateCRF

--- Incoming ---
[u'cv.CalibrateRobertson.getMaxIter', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.CalibrateRobertson.getMaxIter []>

--- Incoming ---
[   u'cv.CalibrateRobertson.setMaxIter',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'max_iter', u'', []]],
    u'void']
ok: FUNC <void cv.CalibrateRobertson.setMaxIter [ARG int max_iter=]>

--- Incoming ---
[   u'cv.CalibrateRobertson.getThreshold',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.CalibrateRobertson.getThreshold []>

--- Incoming ---
[   u'cv.CalibrateRobertson.setThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.CalibrateRobertson.setThreshold [ARG float threshold=]>

--- Incoming ---
[u'cv.CalibrateRobertson.getRadiance', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.CalibrateRobertson.getRadiance []>

--- Incoming ---
[   u'cv.createCalibrateRobertson',
    u'Ptr_CalibrateRobertson',
    [],
    [[u'int', u'max_iter', u'30', []], [u'float', u'threshold', u'0.01f', []]],
    u'Ptr<CalibrateRobertson>']
ok: FUNC <Ptr_CalibrateRobertson cv..createCalibrateRobertson [ARG int max_iter=30, ARG float threshold=0.01f]>

--- Incoming ---
[u'class cv.MergeExposures', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.MergeExposures : Algorithm, name: MergeExposures, base: Algorithm

--- Incoming ---
[   u'cv.MergeExposures.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.MergeExposures.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[u'class cv.MergeDebevec', u': cv::MergeExposures', [], [], None]
ok: class CLASS cv::.MergeDebevec : MergeExposures, name: MergeDebevec, base: MergeExposures

--- Incoming ---
[   u'cv.MergeDebevec.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   u'cv.MergeDebevec.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []]],
    u'void']
ok: FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>

--- Incoming ---
[u'cv.createMergeDebevec', u'Ptr_MergeDebevec', [], [], u'Ptr<MergeDebevec>']
ok: FUNC <Ptr_MergeDebevec cv..createMergeDebevec []>

--- Incoming ---
[u'class cv.MergeMertens', u': cv::MergeExposures', [], [], None]
ok: class CLASS cv::.MergeMertens : MergeExposures, name: MergeMertens, base: MergeExposures

--- Incoming ---
[   u'cv.MergeMertens.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   u'cv.MergeMertens.process',
    u'void',
    ['/V', '/PV'],
    [['vector_Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.MergeMertens.getContrastWeight',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.MergeMertens.getContrastWeight []>

--- Incoming ---
[   u'cv.MergeMertens.setContrastWeight',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'contrast_weiht', u'', []]],
    u'void']
ok: FUNC <void cv.MergeMertens.setContrastWeight [ARG float contrast_weiht=]>

--- Incoming ---
[   u'cv.MergeMertens.getSaturationWeight',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.MergeMertens.getSaturationWeight []>

--- Incoming ---
[   u'cv.MergeMertens.setSaturationWeight',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'saturation_weight', u'', []]],
    u'void']
ok: FUNC <void cv.MergeMertens.setSaturationWeight [ARG float saturation_weight=]>

--- Incoming ---
[   u'cv.MergeMertens.getExposureWeight',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.MergeMertens.getExposureWeight []>

--- Incoming ---
[   u'cv.MergeMertens.setExposureWeight',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'exposure_weight', u'', []]],
    u'void']
ok: FUNC <void cv.MergeMertens.setExposureWeight [ARG float exposure_weight=]>

--- Incoming ---
[   u'cv.createMergeMertens',
    u'Ptr_MergeMertens',
    [],
    [   [u'float', u'contrast_weight', u'1.0f', []],
        [u'float', u'saturation_weight', u'1.0f', []],
        [u'float', u'exposure_weight', u'0.0f', []]],
    u'Ptr<MergeMertens>']
ok: FUNC <Ptr_MergeMertens cv..createMergeMertens [ARG float contrast_weight=1.0f, ARG float saturation_weight=1.0f, ARG float exposure_weight=0.0f]>

--- Incoming ---
[u'class cv.MergeRobertson', u': cv::MergeExposures', [], [], None]
ok: class CLASS cv::.MergeRobertson : MergeExposures, name: MergeRobertson, base: MergeExposures

--- Incoming ---
[   u'cv.MergeRobertson.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []],
        ['Mat', u'response', '', []]],
    u'void']
ok: FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>

--- Incoming ---
[   u'cv.MergeRobertson.process',
    u'void',
    ['/V', '/PV'],
    [   ['vector_Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'times', '', []]],
    u'void']
ok: FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>

--- Incoming ---
[   u'cv.createMergeRobertson',
    u'Ptr_MergeRobertson',
    [],
    [],
    u'Ptr<MergeRobertson>']
ok: FUNC <Ptr_MergeRobertson cv..createMergeRobertson []>

--- Incoming ---
[   u'cv.decolor',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'grayscale', '', ['/O']],
        ['Mat', u'color_boost', '', ['/O']]],
    u'void']
ok: FUNC <void cv..decolor [ARG Mat src=, ARG Mat grayscale=, ARG Mat color_boost=]>

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.NORMAL_CLONE', u'1', [], [], None, ''],
        [u'const cv.MIXED_CLONE', u'2', [], [], None, ''],
        [u'const cv.MONOCHROME_TRANSFER', u'3', [], [], None, '']],
    None]
ok: CONST NORMAL_CLONE=1
ok: CONST MIXED_CLONE=2
ok: CONST MONOCHROME_TRANSFER=3

--- Incoming ---
[   u'cv.seamlessClone',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', []],
        ['Mat', u'mask', '', []],
        [u'Point', u'p', u'', []],
        ['Mat', u'blend', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..seamlessClone [ARG Mat src=, ARG Mat dst=, ARG Mat mask=, ARG Point p=, ARG Mat blend=, ARG int flags=]>

--- Incoming ---
[   u'cv.colorChange',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mask', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'red_mul', u'1.0f', []],
        [u'float', u'green_mul', u'1.0f', []],
        [u'float', u'blue_mul', u'1.0f', []]],
    u'void']
ok: FUNC <void cv..colorChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float red_mul=1.0f, ARG float green_mul=1.0f, ARG float blue_mul=1.0f]>

--- Incoming ---
[   u'cv.illuminationChange',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mask', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'alpha', u'0.2f', []],
        [u'float', u'beta', u'0.4f', []]],
    u'void']
ok: FUNC <void cv..illuminationChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float alpha=0.2f, ARG float beta=0.4f]>

--- Incoming ---
[   u'cv.textureFlattening',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mask', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'low_threshold', u'30', []],
        [u'float', u'high_threshold', u'45', []],
        [u'int', u'kernel_size', u'3', []]],
    u'void']
ok: FUNC <void cv..textureFlattening [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float low_threshold=30, ARG float high_threshold=45, ARG int kernel_size=3]>

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.RECURS_FILTER', u'1', [], [], None, ''],
        [u'const cv.NORMCONV_FILTER', u'2', [], [], None, '']],
    None]
ok: CONST RECURS_FILTER=1
ok: CONST NORMCONV_FILTER=2

--- Incoming ---
[   u'cv.edgePreservingFilter',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'int', u'flags', u'1', []],
        [u'float', u'sigma_s', u'60', []],
        [u'float', u'sigma_r', u'0.4f', []]],
    u'void']
ok: FUNC <void cv..edgePreservingFilter [ARG Mat src=, ARG Mat dst=, ARG int flags=1, ARG float sigma_s=60, ARG float sigma_r=0.4f]>

--- Incoming ---
[   u'cv.detailEnhance',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'sigma_s', u'10', []],
        [u'float', u'sigma_r', u'0.15f', []]],
    u'void']
ok: FUNC <void cv..detailEnhance [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=10, ARG float sigma_r=0.15f]>

--- Incoming ---
[   u'cv.pencilSketch',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst1', '', ['/O']],
        ['Mat', u'dst2', '', ['/O']],
        [u'float', u'sigma_s', u'60', []],
        [u'float', u'sigma_r', u'0.07f', []],
        [u'float', u'shade_factor', u'0.02f', []]],
    u'void']
ok: FUNC <void cv..pencilSketch [ARG Mat src=, ARG Mat dst1=, ARG Mat dst2=, ARG float sigma_s=60, ARG float sigma_r=0.07f, ARG float shade_factor=0.02f]>

--- Incoming ---
[   u'cv.stylization',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        [u'float', u'sigma_s', u'60', []],
        [u'float', u'sigma_r', u'0.45f', []]],
    u'void']
ok: FUNC <void cv..stylization [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=60, ARG float sigma_r=0.45f]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/photo/include/opencv2/photo/cuda.hpp =====
Namespaces: set([u'cv.cuda', u'cv'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/photo/include/opencv2/photo/cuda.hpp


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/photo/include/opencv2/photo/photo.hpp =====
Namespaces: set([u'cv.cuda', u'cv'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/photo/include/opencv2/photo/photo.hpp


===== Generating... =====
CLASS cv::.MergeMertens : MergeExposures
FUNC <float cv.MergeMertens.getContrastWeight []>
java: float getContrastWeight()
FUNC <float cv.MergeMertens.getExposureWeight []>
java: float getExposureWeight()
FUNC <float cv.MergeMertens.getSaturationWeight []>
java: float getSaturationWeight()
FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
FUNC <void cv.MergeMertens.process [ARG vector_Mat src=, ARG Mat dst=]>
java: void process(List<Mat> src, Mat dst)
FUNC <void cv.MergeMertens.setContrastWeight [ARG float contrast_weiht=]>
java: void setContrastWeight(float contrast_weiht)
FUNC <void cv.MergeMertens.setExposureWeight [ARG float exposure_weight=]>
java: void setExposureWeight(float exposure_weight)
FUNC <void cv.MergeMertens.setSaturationWeight [ARG float saturation_weight=]>
java: void setSaturationWeight(float saturation_weight)
CLASS cv::.TonemapMantiuk : Tonemap
FUNC <float cv.TonemapMantiuk.getSaturation []>
java: float getSaturation()
FUNC <float cv.TonemapMantiuk.getScale []>
java: float getScale()
FUNC <void cv.TonemapMantiuk.setSaturation [ARG float saturation=]>
java: void setSaturation(float saturation)
FUNC <void cv.TonemapMantiuk.setScale [ARG float scale=]>
java: void setScale(float scale)
CLASS cv::.CalibrateRobertson : CalibrateCRF
FUNC <Mat cv.CalibrateRobertson.getRadiance []>
java: Mat getRadiance()
FUNC <float cv.CalibrateRobertson.getThreshold []>
java: float getThreshold()
FUNC <int cv.CalibrateRobertson.getMaxIter []>
java: int getMaxIter()
FUNC <void cv.CalibrateRobertson.setMaxIter [ARG int max_iter=]>
java: void setMaxIter(int max_iter)
FUNC <void cv.CalibrateRobertson.setThreshold [ARG float threshold=]>
java: void setThreshold(float threshold)
CLASS cv::.CalibrateDebevec : CalibrateCRF
FUNC <bool cv.CalibrateDebevec.getRandom []>
java: boolean getRandom()
FUNC <float cv.CalibrateDebevec.getLambda []>
java: float getLambda()
FUNC <int cv.CalibrateDebevec.getSamples []>
java: int getSamples()
FUNC <void cv.CalibrateDebevec.setLambda [ARG float lambda=]>
java: void setLambda(float lambda)
FUNC <void cv.CalibrateDebevec.setRandom [ARG bool random=]>
java: void setRandom(boolean random)
FUNC <void cv.CalibrateDebevec.setSamples [ARG int samples=]>
java: void setSamples(int samples)
CLASS cv::.TonemapReinhard : Tonemap
FUNC <float cv.TonemapReinhard.getColorAdaptation []>
java: float getColorAdaptation()
FUNC <float cv.TonemapReinhard.getIntensity []>
java: float getIntensity()
FUNC <float cv.TonemapReinhard.getLightAdaptation []>
java: float getLightAdaptation()
FUNC <void cv.TonemapReinhard.setColorAdaptation [ARG float color_adapt=]>
java: void setColorAdaptation(float color_adapt)
FUNC <void cv.TonemapReinhard.setIntensity [ARG float intensity=]>
java: void setIntensity(float intensity)
FUNC <void cv.TonemapReinhard.setLightAdaptation [ARG float light_adapt=]>
java: void setLightAdaptation(float light_adapt)
CLASS ::.Photo : 
[CONST INPAINT_NS=0, CONST INPAINT_TELEA=1, CONST LDR_SIZE=256, CONST NORMAL_CLONE=1, CONST MIXED_CLONE=2, CONST MONOCHROME_TRANSFER=3, CONST RECURS_FILTER=1, CONST NORMCONV_FILTER=2]
FUNC <Ptr_AlignMTB cv..createAlignMTB [ARG int max_bits=6, ARG int exclude_range=4, ARG bool cut=true]>
java: AlignMTB createAlignMTB(int max_bits, int exclude_range, boolean cut)
java: AlignMTB createAlignMTB(int max_bits, int exclude_range)
java: AlignMTB createAlignMTB(int max_bits)
java: AlignMTB createAlignMTB()
FUNC <Ptr_CalibrateDebevec cv..createCalibrateDebevec [ARG int samples=70, ARG float lambda=10.0f, ARG bool random=false]>
java: CalibrateDebevec createCalibrateDebevec(int samples, float lambda, boolean random)
java: CalibrateDebevec createCalibrateDebevec(int samples, float lambda)
java: CalibrateDebevec createCalibrateDebevec(int samples)
java: CalibrateDebevec createCalibrateDebevec()
FUNC <Ptr_CalibrateRobertson cv..createCalibrateRobertson [ARG int max_iter=30, ARG float threshold=0.01f]>
java: CalibrateRobertson createCalibrateRobertson(int max_iter, float threshold)
java: CalibrateRobertson createCalibrateRobertson(int max_iter)
java: CalibrateRobertson createCalibrateRobertson()
FUNC <Ptr_MergeDebevec cv..createMergeDebevec []>
java: MergeDebevec createMergeDebevec()
FUNC <Ptr_MergeMertens cv..createMergeMertens [ARG float contrast_weight=1.0f, ARG float saturation_weight=1.0f, ARG float exposure_weight=0.0f]>
java: MergeMertens createMergeMertens(float contrast_weight, float saturation_weight, float exposure_weight)
java: MergeMertens createMergeMertens(float contrast_weight, float saturation_weight)
java: MergeMertens createMergeMertens(float contrast_weight)
java: MergeMertens createMergeMertens()
FUNC <Ptr_MergeRobertson cv..createMergeRobertson []>
java: MergeRobertson createMergeRobertson()
FUNC <Ptr_Tonemap cv..createTonemap [ARG float gamma=1.0f]>
java: Tonemap createTonemap(float gamma)
java: Tonemap createTonemap()
FUNC <Ptr_TonemapDrago cv..createTonemapDrago [ARG float gamma=1.0f, ARG float saturation=1.0f, ARG float bias=0.85f]>
java: TonemapDrago createTonemapDrago(float gamma, float saturation, float bias)
java: TonemapDrago createTonemapDrago(float gamma, float saturation)
java: TonemapDrago createTonemapDrago(float gamma)
java: TonemapDrago createTonemapDrago()
FUNC <Ptr_TonemapMantiuk cv..createTonemapMantiuk [ARG float gamma=1.0f, ARG float scale=0.7f, ARG float saturation=1.0f]>
java: TonemapMantiuk createTonemapMantiuk(float gamma, float scale, float saturation)
java: TonemapMantiuk createTonemapMantiuk(float gamma, float scale)
java: TonemapMantiuk createTonemapMantiuk(float gamma)
java: TonemapMantiuk createTonemapMantiuk()
FUNC <Ptr_TonemapReinhard cv..createTonemapReinhard [ARG float gamma=1.0f, ARG float intensity=0.0f, ARG float light_adapt=1.0f, ARG float color_adapt=0.0f]>
java: TonemapReinhard createTonemapReinhard(float gamma, float intensity, float light_adapt, float color_adapt)
java: TonemapReinhard createTonemapReinhard(float gamma, float intensity, float light_adapt)
java: TonemapReinhard createTonemapReinhard(float gamma, float intensity)
java: TonemapReinhard createTonemapReinhard(float gamma)
java: TonemapReinhard createTonemapReinhard()
FUNC <void cv..colorChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float red_mul=1.0f, ARG float green_mul=1.0f, ARG float blue_mul=1.0f]>
java: void colorChange(Mat src, Mat mask, Mat dst, float red_mul, float green_mul, float blue_mul)
java: void colorChange(Mat src, Mat mask, Mat dst, float red_mul, float green_mul)
java: void colorChange(Mat src, Mat mask, Mat dst, float red_mul)
java: void colorChange(Mat src, Mat mask, Mat dst)
FUNC <void cv..decolor [ARG Mat src=, ARG Mat grayscale=, ARG Mat color_boost=]>
java: void decolor(Mat src, Mat grayscale, Mat color_boost)
FUNC <void cv..denoise_TVL1 [ARG vector_Mat observations=, ARG Mat result=, ARG double lambda=1.0, ARG int niters=30]>
java: void denoise_TVL1(List<Mat> observations, Mat result, double lambda, int niters)
java: void denoise_TVL1(List<Mat> observations, Mat result, double lambda)
java: void denoise_TVL1(List<Mat> observations, Mat result)
FUNC <void cv..detailEnhance [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=10, ARG float sigma_r=0.15f]>
java: void detailEnhance(Mat src, Mat dst, float sigma_s, float sigma_r)
java: void detailEnhance(Mat src, Mat dst, float sigma_s)
java: void detailEnhance(Mat src, Mat dst)
FUNC <void cv..edgePreservingFilter [ARG Mat src=, ARG Mat dst=, ARG int flags=1, ARG float sigma_s=60, ARG float sigma_r=0.4f]>
java: void edgePreservingFilter(Mat src, Mat dst, int flags, float sigma_s, float sigma_r)
java: void edgePreservingFilter(Mat src, Mat dst, int flags, float sigma_s)
java: void edgePreservingFilter(Mat src, Mat dst, int flags)
java: void edgePreservingFilter(Mat src, Mat dst)
FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoising(Mat src, Mat dst, float h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, float h, int templateWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, float h)
java: void fastNlMeansDenoising(Mat src, Mat dst)
FUNC <void cv..fastNlMeansDenoising [ARG Mat src=, ARG Mat dst=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h, int templateWindowSize, int searchWindowSize, int normType)
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h, int templateWindowSize)
java: void fastNlMeansDenoising(Mat src, Mat dst, MatOfFloat h)
FUNC <void cv..fastNlMeansDenoisingColored [ARG Mat src=, ARG Mat dst=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h, float hColor, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h, float hColor, int templateWindowSize)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h, float hColor)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst, float h)
java: void fastNlMeansDenoisingColored(Mat src, Mat dst)
FUNC <void cv..fastNlMeansDenoisingColoredMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG float hColor=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, float hColor, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, float hColor, int templateWindowSize)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, float hColor)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h)
java: void fastNlMeansDenoisingColoredMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize)
FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG float h=3, ARG int templateWindowSize=7, ARG int searchWindowSize=21]>
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h, int templateWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, float h)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize)
FUNC <void cv..fastNlMeansDenoisingMulti [ARG vector_Mat srcImgs=, ARG Mat dst=, ARG int imgToDenoiseIndex=, ARG int temporalWindowSize=, ARG vector_float h=, ARG int templateWindowSize=7, ARG int searchWindowSize=21, ARG int normType=NORM_L2]>
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h, int templateWindowSize, int searchWindowSize, int normType)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h, int templateWindowSize, int searchWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h, int templateWindowSize)
java: void fastNlMeansDenoisingMulti(List<Mat> srcImgs, Mat dst, int imgToDenoiseIndex, int temporalWindowSize, MatOfFloat h)
FUNC <void cv..illuminationChange [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float alpha=0.2f, ARG float beta=0.4f]>
java: void illuminationChange(Mat src, Mat mask, Mat dst, float alpha, float beta)
java: void illuminationChange(Mat src, Mat mask, Mat dst, float alpha)
java: void illuminationChange(Mat src, Mat mask, Mat dst)
FUNC <void cv..inpaint [ARG Mat src=, ARG Mat inpaintMask=, ARG Mat dst=, ARG double inpaintRadius=, ARG int flags=]>
java: void inpaint(Mat src, Mat inpaintMask, Mat dst, double inpaintRadius, int flags)
FUNC <void cv..pencilSketch [ARG Mat src=, ARG Mat dst1=, ARG Mat dst2=, ARG float sigma_s=60, ARG float sigma_r=0.07f, ARG float shade_factor=0.02f]>
java: void pencilSketch(Mat src, Mat dst1, Mat dst2, float sigma_s, float sigma_r, float shade_factor)
java: void pencilSketch(Mat src, Mat dst1, Mat dst2, float sigma_s, float sigma_r)
java: void pencilSketch(Mat src, Mat dst1, Mat dst2, float sigma_s)
java: void pencilSketch(Mat src, Mat dst1, Mat dst2)
FUNC <void cv..seamlessClone [ARG Mat src=, ARG Mat dst=, ARG Mat mask=, ARG Point p=, ARG Mat blend=, ARG int flags=]>
java: void seamlessClone(Mat src, Mat dst, Mat mask, Point p, Mat blend, int flags)
FUNC <void cv..stylization [ARG Mat src=, ARG Mat dst=, ARG float sigma_s=60, ARG float sigma_r=0.45f]>
java: void stylization(Mat src, Mat dst, float sigma_s, float sigma_r)
java: void stylization(Mat src, Mat dst, float sigma_s)
java: void stylization(Mat src, Mat dst)
FUNC <void cv..textureFlattening [ARG Mat src=, ARG Mat mask=, ARG Mat dst=, ARG float low_threshold=30, ARG float high_threshold=45, ARG int kernel_size=3]>
java: void textureFlattening(Mat src, Mat mask, Mat dst, float low_threshold, float high_threshold, int kernel_size)
java: void textureFlattening(Mat src, Mat mask, Mat dst, float low_threshold, float high_threshold)
java: void textureFlattening(Mat src, Mat mask, Mat dst, float low_threshold)
java: void textureFlattening(Mat src, Mat mask, Mat dst)
CLASS cv::.AlignExposures : Algorithm
FUNC <void cv.AlignExposures.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, List<Mat> dst, Mat times, Mat response)
CLASS cv::.CalibrateCRF : Algorithm
FUNC <void cv.CalibrateCRF.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>
java: void process(List<Mat> src, Mat dst, Mat times)
CLASS cv::.TonemapDrago : Tonemap
FUNC <float cv.TonemapDrago.getBias []>
java: float getBias()
FUNC <float cv.TonemapDrago.getSaturation []>
java: float getSaturation()
FUNC <void cv.TonemapDrago.setBias [ARG float bias=]>
java: void setBias(float bias)
FUNC <void cv.TonemapDrago.setSaturation [ARG float saturation=]>
java: void setSaturation(float saturation)
CLASS cv::.AlignMTB : AlignExposures
FUNC <Point cv.AlignMTB.calculateShift [ARG Mat img0=, ARG Mat img1=]>
java: Point calculateShift(Mat img0, Mat img1)
FUNC <bool cv.AlignMTB.getCut []>
java: boolean getCut()
FUNC <int cv.AlignMTB.getExcludeRange []>
java: int getExcludeRange()
FUNC <int cv.AlignMTB.getMaxBits []>
java: int getMaxBits()
FUNC <void cv.AlignMTB.computeBitmaps [ARG Mat img=, ARG Mat tb=, ARG Mat eb=]>
java: void computeBitmaps(Mat img, Mat tb, Mat eb)
FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, List<Mat> dst, Mat times, Mat response)
FUNC <void cv.AlignMTB.process [ARG vector_Mat src=, ARG vector_Mat dst=]>
java: void process(List<Mat> src, List<Mat> dst)
FUNC <void cv.AlignMTB.setCut [ARG bool value=]>
java: void setCut(boolean value)
FUNC <void cv.AlignMTB.setExcludeRange [ARG int exclude_range=]>
java: void setExcludeRange(int exclude_range)
FUNC <void cv.AlignMTB.setMaxBits [ARG int max_bits=]>
java: void setMaxBits(int max_bits)
FUNC <void cv.AlignMTB.shiftMat [ARG Mat src=, ARG Mat dst=, ARG Point shift=]>
java: void shiftMat(Mat src, Mat dst, Point shift)
CLASS cv::.MergeDebevec : MergeExposures
FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
FUNC <void cv.MergeDebevec.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>
java: void process(List<Mat> src, Mat dst, Mat times)
CLASS cv::.MergeExposures : Algorithm
FUNC <void cv.MergeExposures.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
CLASS cv::.MergeRobertson : MergeExposures
FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=, ARG Mat response=]>
java: void process(List<Mat> src, Mat dst, Mat times, Mat response)
FUNC <void cv.MergeRobertson.process [ARG vector_Mat src=, ARG Mat dst=, ARG Mat times=]>
java: void process(List<Mat> src, Mat dst, Mat times)
CLASS cv::.Tonemap : Algorithm
FUNC <float cv.Tonemap.getGamma []>
java: float getGamma()
FUNC <void cv.Tonemap.process [ARG Mat src=, ARG Mat dst=]>
java: void process(Mat src, Mat dst)
FUNC <void cv.Tonemap.setGamma [ARG float gamma=]>
java: void setGamma(float gamma)

=== MODULE: dnn (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn) ===


Files (8):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/shape_utils.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/all_layers.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/version.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/layer.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/dict.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/dnn.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/utils/inference_engine.hpp']

Common headers (1):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/misc/java/src/cpp/dnn_converters.hpp']
ok: class CLASS ::.Dnn : , name: Dnn, base: 

===== Common header : /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/misc/java/src/cpp/dnn_converters.hpp =====


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn.hpp =====
Namespaces: set([])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn.hpp


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/shape_utils.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/shape_utils.hpp


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/all_layers.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/all_layers.hpp


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/version.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv', u'cv.dnn.CV__DNN_INLINE_NS'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/version.hpp


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/layer.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv', u'cv.dnn.CV__DNN_INLINE_NS'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/layer.hpp


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/dict.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv', u'cv.dnn.CV__DNN_INLINE_NS'])

--- Incoming ---
[u'struct cv.dnn.DictValue', '', [], [], None]
ok: class CLASS cv.dnn::.DictValue : , name: DictValue, base: 

--- Incoming ---
[u'cv.dnn.DictValue.DictValue', '', [], [[u'int', u'i', u'', []]], None]
ok: FUNC < cv.dnn.DictValue.DictValue [ARG int i=]>

--- Incoming ---
[u'cv.dnn.DictValue.DictValue', '', [], [[u'double', u'p', u'', []]], None]
ok: FUNC < cv.dnn.DictValue.DictValue [ARG double p=]>

--- Incoming ---
[   u'cv.dnn.DictValue.DictValue',
    '',
    [],
    [[u'String', u's', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.DictValue.DictValue [ARG String s=]>

--- Incoming ---
[u'cv.dnn.DictValue.isInt', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.dnn.DictValue.isInt []>

--- Incoming ---
[u'cv.dnn.DictValue.isString', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.dnn.DictValue.isString []>

--- Incoming ---
[u'cv.dnn.DictValue.isReal', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.dnn.DictValue.isReal []>

--- Incoming ---
[   u'cv.dnn.DictValue.getIntValue',
    u'int',
    ['/C'],
    [[u'int', u'idx', u'-1', []]],
    u'int']
ok: FUNC <int cv.dnn.DictValue.getIntValue [ARG int idx=-1]>

--- Incoming ---
[   u'cv.dnn.DictValue.getRealValue',
    u'double',
    ['/C'],
    [[u'int', u'idx', u'-1', []]],
    u'double']
ok: FUNC <double cv.dnn.DictValue.getRealValue [ARG int idx=-1]>

--- Incoming ---
[   u'cv.dnn.DictValue.getStringValue',
    u'String',
    ['/C'],
    [[u'int', u'idx', u'-1', []]],
    u'String']
ok: FUNC <String cv.dnn.DictValue.getStringValue [ARG int idx=-1]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/dnn.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv', u'cv.dnn.CV__DNN_INLINE_NS'])

--- Incoming ---
[   u'enum cv.dnn.Backend',
    '',
    [],
    [   [u'const cv.dnn.DNN_BACKEND_DEFAULT', u'0', [], [], None, ''],
        [u'const cv.dnn.DNN_BACKEND_HALIDE', u'0+1', [], [], None, ''],
        [   u'const cv.dnn.DNN_BACKEND_INFERENCE_ENGINE',
            u'0+2',
            [],
            [],
            None,
            ''],
        [u'const cv.dnn.DNN_BACKEND_OPENCV', u'0+3', [], [], None, ''],
        [u'const cv.dnn.DNN_BACKEND_VKCOM', u'0+4', [], [], None, ''],
        [u'const cv.dnn.DNN_BACKEND_CUDA', u'0+5', [], [], None, '']],
    None]
ok: CONST DNN_BACKEND_DEFAULT=0
ok: CONST DNN_BACKEND_HALIDE=0+1
ok: CONST DNN_BACKEND_INFERENCE_ENGINE=0+2
ok: CONST DNN_BACKEND_OPENCV=0+3
ok: CONST DNN_BACKEND_VKCOM=0+4
ok: CONST DNN_BACKEND_CUDA=0+5

--- Incoming ---
[   u'enum cv.dnn.Target',
    '',
    [],
    [   [u'const cv.dnn.DNN_TARGET_CPU', u'0', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_OPENCL', u'0+1', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_OPENCL_FP16', u'0+2', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_MYRIAD', u'0+3', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_VULKAN', u'0+4', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_FPGA', u'0+5', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_CUDA', u'0+6', [], [], None, ''],
        [u'const cv.dnn.DNN_TARGET_CUDA_FP16', u'0+7', [], [], None, '']],
    None]
ok: CONST DNN_TARGET_CPU=0
ok: CONST DNN_TARGET_OPENCL=0+1
ok: CONST DNN_TARGET_OPENCL_FP16=0+2
ok: CONST DNN_TARGET_MYRIAD=0+3
ok: CONST DNN_TARGET_VULKAN=0+4
ok: CONST DNN_TARGET_FPGA=0+5
ok: CONST DNN_TARGET_CUDA=0+6
ok: CONST DNN_TARGET_CUDA_FP16=0+7

--- Incoming ---
[   u'cv.dnn.getAvailableTargets',
    u'vector_Target',
    [],
    [[u'dnn_Backend', u'be', u'', []]],
    u'std::vector<Target>']
ok: FUNC <vector_Target cv.dnn..getAvailableTargets [ARG dnn_Backend be=]>

--- Incoming ---
[   u'class cv.dnn.Layer',
    ': cv::Algorithm',
    [],
    [   [u'vector_Mat', u'blobs', '', ['/RW']],
        [u'String', u'name', '', []],
        [u'String', u'type', '', []],
        [u'int', u'preferableTarget', '', []]],
    None]
ok: class CLASS cv.dnn::.Layer : Algorithm, name: Layer, base: Algorithm

--- Incoming ---
[   u'cv.dnn.Layer.finalize',
    u'void',
    ['/V'],
    [   ['vector_Mat', u'inputs', '', []],
        ['vector_Mat', u'outputs', '', ['/O']]],
    u'void']
ok: FUNC <void cv.dnn.Layer.finalize [ARG vector_Mat inputs=, ARG vector_Mat outputs=]>

--- Incoming ---
[   u'cv.dnn.Layer.run',
    u'void',
    [],
    [   [u'vector_Mat', u'inputs', u'', ['/C', '/Ref']],
        [u'vector_Mat', u'outputs', u'', ['/O', '/Ref']],
        [u'vector_Mat', u'internals', u'', ['/IO', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Layer.run [ARG vector_Mat inputs=, ARG vector_Mat outputs=, ARG vector_Mat internals=]>

--- Incoming ---
[   u'cv.dnn.Layer.outputNameToIndex',
    u'int',
    ['/V'],
    [[u'String', u'outputName', u'', ['/C', '/Ref']]],
    u'int']
ok: FUNC <int cv.dnn.Layer.outputNameToIndex [ARG String outputName=]>

--- Incoming ---
[u'class cv.dnn.Net', '', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.Net : , name: Net, base: 

--- Incoming ---
[u'cv.dnn.Net.Net', '', [], [], None]
ok: FUNC < cv.dnn.Net.Net []>

--- Incoming ---
[   u'cv.dnn.Net.readFromModelOptimizer',
    u'Net',
    ['/S'],
    [   [u'String', u'xml', u'', ['/C', '/Ref']],
        [u'String', u'bin', u'', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn.Net.readFromModelOptimizer [ARG String xml=, ARG String bin=]>

--- Incoming ---
[   u'cv.dnn.Net.readFromModelOptimizer',
    u'Net',
    ['/S'],
    [   [u'vector_uchar', u'bufferModelConfig', u'', ['/C', '/Ref']],
        [u'vector_uchar', u'bufferWeights', u'', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn.Net.readFromModelOptimizer [ARG vector_uchar bufferModelConfig=, ARG vector_uchar bufferWeights=]>

--- Incoming ---
[u'cv.dnn.Net.empty', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.dnn.Net.empty []>

--- Incoming ---
[u'cv.dnn.Net.dump', u'String', [], [], u'String']
ok: FUNC <String cv.dnn.Net.dump []>

--- Incoming ---
[   u'cv.dnn.Net.dumpToFile',
    u'void',
    [],
    [[u'String', u'path', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.dumpToFile [ARG String path=]>

--- Incoming ---
[   u'cv.dnn.Net.getLayerId',
    u'int',
    [],
    [[u'String', u'layer', u'', ['/C', '/Ref']]],
    u'int']
ok: FUNC <int cv.dnn.Net.getLayerId [ARG String layer=]>

--- Incoming ---
[   u'cv.dnn.Net.getLayerNames',
    u'vector_String',
    ['/C'],
    [],
    u'std::vector<String>']
ok: FUNC <vector_String cv.dnn.Net.getLayerNames []>

--- Incoming ---
[   u'cv.dnn.Net.getLayer',
    u'Ptr_Layer',
    [],
    [[u'LayerId', u'layerId', u'', []]],
    u'Ptr<Layer>']
ok: FUNC <Ptr_Layer cv.dnn.Net.getLayer [ARG LayerId layerId=]>

--- Incoming ---
[   u'cv.dnn.Net.connect',
    u'void',
    [],
    [[u'String', u'outPin', u'', []], [u'String', u'inpPin', u'', []]],
    u'void']
ok: FUNC <void cv.dnn.Net.connect [ARG String outPin=, ARG String inpPin=]>

--- Incoming ---
[   u'cv.dnn.Net.setInputsNames',
    u'void',
    [],
    [[u'vector_String', u'inputBlobNames', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.setInputsNames [ARG vector_String inputBlobNames=]>

--- Incoming ---
[   u'cv.dnn.Net.setInputShape',
    u'void',
    [],
    [   [u'String', u'inputName', u'', ['/C', '/Ref']],
        [u'MatShape', u'shape', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.setInputShape [ARG String inputName=, ARG MatShape shape=]>

--- Incoming ---
[   u'cv.dnn.Net.forward',
    u'Mat',
    [],
    [[u'String', u'outputName', u'String()', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.dnn.Net.forward [ARG String outputName=String()]>

--- Incoming ---
[   u'cv.dnn.Net.forwardAsync',
    u'AsyncArray',
    [],
    [[u'String', u'outputName', u'String()', ['/C', '/Ref']]],
    u'AsyncArray']
ok: FUNC <AsyncArray cv.dnn.Net.forwardAsync [ARG String outputName=String()]>

--- Incoming ---
[   u'cv.dnn.Net.forward',
    u'void',
    [],
    [   ['vector_Mat', u'outputBlobs', '', ['/O']],
        [u'String', u'outputName', u'String()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG String outputName=String()]>

--- Incoming ---
[   u'cv.dnn.Net.forward',
    u'void',
    [],
    [   ['vector_Mat', u'outputBlobs', '', ['/O']],
        [u'vector_String', u'outBlobNames', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>

--- Incoming ---
[   u'cv.dnn.Net.forward',
    u'void',
    [u'=forwardAndRetrieve'],
    [   [u'vector_vector_Mat', u'outputBlobs', u'', ['/O', '/Ref']],
        [u'vector_String', u'outBlobNames', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.forward [ARG vector_vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>

--- Incoming ---
[   u'cv.dnn.Net.setHalideScheduler',
    u'void',
    [],
    [[u'String', u'scheduler', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.setHalideScheduler [ARG String scheduler=]>

--- Incoming ---
[   u'cv.dnn.Net.setPreferableBackend',
    u'void',
    [],
    [[u'int', u'backendId', u'', []]],
    u'void']
ok: FUNC <void cv.dnn.Net.setPreferableBackend [ARG int backendId=]>

--- Incoming ---
[   u'cv.dnn.Net.setPreferableTarget',
    u'void',
    [],
    [[u'int', u'targetId', u'', []]],
    u'void']
ok: FUNC <void cv.dnn.Net.setPreferableTarget [ARG int targetId=]>

--- Incoming ---
[   u'cv.dnn.Net.setInput',
    u'void',
    [],
    [   ['Mat', u'blob', '', []],
        [u'String', u'name', u'""', ['/C', '/Ref']],
        [u'double', u'scalefactor', u'1.0', []],
        [u'Scalar', u'mean', u'Scalar()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.setInput [ARG Mat blob=, ARG String name="", ARG double scalefactor=1.0, ARG Scalar mean=Scalar()]>

--- Incoming ---
[   u'cv.dnn.Net.setParam',
    u'void',
    [],
    [   [u'LayerId', u'layer', u'', []],
        [u'int', u'numParam', u'', []],
        [u'Mat', u'blob', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.setParam [ARG LayerId layer=, ARG int numParam=, ARG Mat blob=]>

--- Incoming ---
[   u'cv.dnn.Net.getParam',
    u'Mat',
    [],
    [[u'LayerId', u'layer', u'', []], [u'int', u'numParam', u'0', []]],
    u'Mat']
ok: FUNC <Mat cv.dnn.Net.getParam [ARG LayerId layer=, ARG int numParam=0]>

--- Incoming ---
[   u'cv.dnn.Net.getUnconnectedOutLayers',
    u'vector_int',
    ['/C'],
    [],
    u'std::vector<int>']
ok: FUNC <vector_int cv.dnn.Net.getUnconnectedOutLayers []>

--- Incoming ---
[   u'cv.dnn.Net.getUnconnectedOutLayersNames',
    u'vector_String',
    ['/C'],
    [],
    u'std::vector<String>']
ok: FUNC <vector_String cv.dnn.Net.getUnconnectedOutLayersNames []>

--- Incoming ---
[   u'cv.dnn.Net.getLayersShapes',
    u'void',
    ['/C'],
    [   [u'vector_MatShape', u'netInputShapes', u'', ['/C', '/Ref']],
        [u'vector_int', u'layersIds', u'', ['/O', '/Ref']],
        [u'vector_vector_MatShape', u'inLayersShapes', u'', ['/O', '/Ref']],
        [u'vector_vector_MatShape', u'outLayersShapes', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getLayersShapes [ARG vector_MatShape netInputShapes=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>

--- Incoming ---
[   u'cv.dnn.Net.getLayersShapes',
    u'void',
    ['/C'],
    [   [u'MatShape', u'netInputShape', u'', ['/C', '/Ref']],
        [u'vector_int', u'layersIds', u'', ['/O', '/Ref']],
        [u'vector_vector_MatShape', u'inLayersShapes', u'', ['/O', '/Ref']],
        [u'vector_vector_MatShape', u'outLayersShapes', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getLayersShapes [ARG MatShape netInputShape=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>

--- Incoming ---
[   u'cv.dnn.Net.getFLOPS',
    u'int64',
    ['/C'],
    [[u'vector_MatShape', u'netInputShapes', u'', ['/C', '/Ref']]],
    u'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG vector_MatShape netInputShapes=]>

--- Incoming ---
[   u'cv.dnn.Net.getFLOPS',
    u'int64',
    ['/C'],
    [[u'MatShape', u'netInputShape', u'', ['/C', '/Ref']]],
    u'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG MatShape netInputShape=]>

--- Incoming ---
[   u'cv.dnn.Net.getFLOPS',
    u'int64',
    ['/C'],
    [   [u'int', u'layerId', u'', ['/C']],
        [u'vector_MatShape', u'netInputShapes', u'', ['/C', '/Ref']]],
    u'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG vector_MatShape netInputShapes=]>

--- Incoming ---
[   u'cv.dnn.Net.getFLOPS',
    u'int64',
    ['/C'],
    [   [u'int', u'layerId', u'', ['/C']],
        [u'MatShape', u'netInputShape', u'', ['/C', '/Ref']]],
    u'int64']
ok: FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG MatShape netInputShape=]>

--- Incoming ---
[   u'cv.dnn.Net.getLayerTypes',
    u'void',
    ['/C'],
    [[u'vector_String', u'layersTypes', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getLayerTypes [ARG vector_String layersTypes=]>

--- Incoming ---
[   u'cv.dnn.Net.getLayersCount',
    u'int',
    ['/C'],
    [[u'String', u'layerType', u'', ['/C', '/Ref']]],
    u'int']
ok: FUNC <int cv.dnn.Net.getLayersCount [ARG String layerType=]>

--- Incoming ---
[   u'cv.dnn.Net.getMemoryConsumption',
    u'void',
    ['/C'],
    [   [u'MatShape', u'netInputShape', u'', ['/C', '/Ref']],
        [u'size_t', u'weights', u'', ['/O', '/Ref']],
        [u'size_t', u'blobs', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getMemoryConsumption [ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>

--- Incoming ---
[   u'cv.dnn.Net.getMemoryConsumption',
    u'void',
    ['/C'],
    [   [u'int', u'layerId', u'', ['/C']],
        [u'vector_MatShape', u'netInputShapes', u'', ['/C', '/Ref']],
        [u'size_t', u'weights', u'', ['/O', '/Ref']],
        [u'size_t', u'blobs', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG vector_MatShape netInputShapes=, ARG size_t weights=, ARG size_t blobs=]>

--- Incoming ---
[   u'cv.dnn.Net.getMemoryConsumption',
    u'void',
    ['/C'],
    [   [u'int', u'layerId', u'', ['/C']],
        [u'MatShape', u'netInputShape', u'', ['/C', '/Ref']],
        [u'size_t', u'weights', u'', ['/O', '/Ref']],
        [u'size_t', u'blobs', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>

--- Incoming ---
[   u'cv.dnn.Net.enableFusion',
    u'void',
    [],
    [[u'bool', u'fusion', u'', []]],
    u'void']
ok: FUNC <void cv.dnn.Net.enableFusion [ARG bool fusion=]>

--- Incoming ---
[   u'cv.dnn.Net.getPerfProfile',
    u'int64',
    [],
    [[u'vector_double', u'timings', u'', ['/O', '/Ref']]],
    u'int64']
ok: FUNC <int64 cv.dnn.Net.getPerfProfile [ARG vector_double timings=]>

--- Incoming ---
[   u'cv.dnn.readNetFromDarknet',
    u'Net',
    [],
    [   [u'String', u'cfgFile', u'', ['/C', '/Ref']],
        [u'String', u'darknetModel', u'String()', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromDarknet [ARG String cfgFile=, ARG String darknetModel=String()]>

--- Incoming ---
[   u'cv.dnn.readNetFromDarknet',
    u'Net',
    [],
    [   [u'vector_uchar', u'bufferCfg', u'', ['/C', '/Ref']],
        [   u'vector_uchar',
            u'bufferModel',
            u'std::vector<uchar>()',
            ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromDarknet [ARG vector_uchar bufferCfg=, ARG vector_uchar bufferModel=std::vector<uchar>()]>

--- Incoming ---
[   u'cv.dnn.readNetFromCaffe',
    u'Net',
    [],
    [   [u'String', u'prototxt', u'', ['/C', '/Ref']],
        [u'String', u'caffeModel', u'String()', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromCaffe [ARG String prototxt=, ARG String caffeModel=String()]>

--- Incoming ---
[   u'cv.dnn.readNetFromCaffe',
    u'Net',
    [],
    [   [u'vector_uchar', u'bufferProto', u'', ['/C', '/Ref']],
        [   u'vector_uchar',
            u'bufferModel',
            u'std::vector<uchar>()',
            ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromCaffe [ARG vector_uchar bufferProto=, ARG vector_uchar bufferModel=std::vector<uchar>()]>

--- Incoming ---
[   u'cv.dnn.readNetFromTensorflow',
    u'Net',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'String', u'config', u'String()', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromTensorflow [ARG String model=, ARG String config=String()]>

--- Incoming ---
[   u'cv.dnn.readNetFromTensorflow',
    u'Net',
    [],
    [   [u'vector_uchar', u'bufferModel', u'', ['/C', '/Ref']],
        [   u'vector_uchar',
            u'bufferConfig',
            u'std::vector<uchar>()',
            ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromTensorflow [ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>

--- Incoming ---
[   u'cv.dnn.readNetFromTorch',
    u'Net',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'bool', u'isBinary', u'true', []],
        [u'bool', u'evaluate', u'true', []]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromTorch [ARG String model=, ARG bool isBinary=true, ARG bool evaluate=true]>

--- Incoming ---
[   u'cv.dnn.readNet',
    u'Net',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'String', u'config', u'""', ['/C', '/Ref']],
        [u'String', u'framework', u'""', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNet [ARG String model=, ARG String config="", ARG String framework=""]>

--- Incoming ---
[   u'cv.dnn.readNet',
    u'Net',
    [],
    [   [u'String', u'framework', u'', ['/C', '/Ref']],
        [u'vector_uchar', u'bufferModel', u'', ['/C', '/Ref']],
        [   u'vector_uchar',
            u'bufferConfig',
            u'std::vector<uchar>()',
            ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNet [ARG String framework=, ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>

--- Incoming ---
[   u'cv.dnn.readTorchBlob',
    u'Mat',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'bool', u'isBinary', u'true', []]],
    u'Mat']
ok: FUNC <Mat cv.dnn..readTorchBlob [ARG String filename=, ARG bool isBinary=true]>

--- Incoming ---
[   u'cv.dnn.readNetFromModelOptimizer',
    u'Net',
    [],
    [   [u'String', u'xml', u'', ['/C', '/Ref']],
        [u'String', u'bin', u'', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromModelOptimizer [ARG String xml=, ARG String bin=]>

--- Incoming ---
[   u'cv.dnn.readNetFromModelOptimizer',
    u'Net',
    [],
    [   [u'vector_uchar', u'bufferModelConfig', u'', ['/C', '/Ref']],
        [u'vector_uchar', u'bufferWeights', u'', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromModelOptimizer [ARG vector_uchar bufferModelConfig=, ARG vector_uchar bufferWeights=]>

--- Incoming ---
[   u'cv.dnn.readNetFromONNX',
    u'Net',
    [],
    [[u'String', u'onnxFile', u'', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromONNX [ARG String onnxFile=]>

--- Incoming ---
[   u'cv.dnn.readNetFromONNX',
    u'Net',
    [],
    [[u'vector_uchar', u'buffer', u'', ['/C', '/Ref']]],
    u'Net']
ok: FUNC <Net cv.dnn..readNetFromONNX [ARG vector_uchar buffer=]>

--- Incoming ---
[   u'cv.dnn.readTensorFromONNX',
    u'Mat',
    [],
    [[u'String', u'path', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.dnn..readTensorFromONNX [ARG String path=]>

--- Incoming ---
[   u'cv.dnn.blobFromImage',
    u'Mat',
    [],
    [   ['Mat', u'image', '', []],
        [u'double', u'scalefactor', u'1.0', []],
        [u'Size', u'size', u'Size()', ['/C', '/Ref']],
        [u'Scalar', u'mean', u'Scalar()', ['/C', '/Ref']],
        [u'bool', u'swapRB', u'false', []],
        [u'bool', u'crop', u'false', []],
        [u'int', u'ddepth', u'CV_32F', []]],
    u'Mat']
ok: FUNC <Mat cv.dnn..blobFromImage [ARG Mat image=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>

--- Incoming ---
[   u'cv.dnn.blobFromImages',
    u'Mat',
    [],
    [   ['vector_Mat', u'images', '', []],
        [u'double', u'scalefactor', u'1.0', []],
        [u'Size', u'size', u'Size()', []],
        [u'Scalar', u'mean', u'Scalar()', ['/C', '/Ref']],
        [u'bool', u'swapRB', u'false', []],
        [u'bool', u'crop', u'false', []],
        [u'int', u'ddepth', u'CV_32F', []]],
    u'Mat']
ok: FUNC <Mat cv.dnn..blobFromImages [ARG vector_Mat images=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>

--- Incoming ---
[   u'cv.dnn.imagesFromBlob',
    u'void',
    [],
    [   [u'Mat', u'blob_', u'', ['/C', '/Ref']],
        ['vector_Mat', u'images_', '', ['/O']]],
    u'void']
ok: FUNC <void cv.dnn..imagesFromBlob [ARG Mat blob_=, ARG vector_Mat images_=]>

--- Incoming ---
[   u'cv.dnn.shrinkCaffeModel',
    u'void',
    [],
    [   [u'String', u'src', u'', ['/C', '/Ref']],
        [u'String', u'dst', u'', ['/C', '/Ref']],
        [   u'vector_String',
            u'layersTypes',
            u'std::vector<String>()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn..shrinkCaffeModel [ARG String src=, ARG String dst=, ARG vector_String layersTypes=std::vector<String>()]>

--- Incoming ---
[   u'cv.dnn.writeTextGraph',
    u'void',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'String', u'output', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn..writeTextGraph [ARG String model=, ARG String output=]>

--- Incoming ---
[   u'cv.dnn.NMSBoxes',
    u'void',
    [],
    [   [u'vector_Rect2d', u'bboxes', u'', ['/C', '/Ref']],
        [u'vector_float', u'scores', u'', ['/C', '/Ref']],
        [u'float', u'score_threshold', u'', ['/C']],
        [u'float', u'nms_threshold', u'', ['/C']],
        [u'vector_int', u'indices', u'', ['/O', '/Ref']],
        [u'float', u'eta', u'1.f', ['/C']],
        [u'int', u'top_k', u'0', ['/C']]],
    u'void']
ok: FUNC <void cv.dnn..NMSBoxes [ARG vector_Rect2d bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>

--- Incoming ---
[   u'cv.dnn.NMSBoxes',
    u'void',
    [u'=NMSBoxesRotated'],
    [   [u'vector_RotatedRect', u'bboxes', u'', ['/C', '/Ref']],
        [u'vector_float', u'scores', u'', ['/C', '/Ref']],
        [u'float', u'score_threshold', u'', ['/C']],
        [u'float', u'nms_threshold', u'', ['/C']],
        [u'vector_int', u'indices', u'', ['/O', '/Ref']],
        [u'float', u'eta', u'1.f', ['/C']],
        [u'int', u'top_k', u'0', ['/C']]],
    u'void']
ok: FUNC <void cv.dnn..NMSBoxes [ARG vector_RotatedRect bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>

--- Incoming ---
[u'class cv.dnn.Model', u': cv::dnn::Net', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.Model : Net, name: Model, base: Net

--- Incoming ---
[   u'cv.dnn.Model.Model',
    '',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'String', u'config', u'""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.Model.Model [ARG String model=, ARG String config=""]>

--- Incoming ---
[   u'cv.dnn.Model.Model',
    '',
    [],
    [[u'Net', u'network', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.Model.Model [ARG Net network=]>

--- Incoming ---
[   u'cv.dnn.Model.setInputSize',
    u'Model',
    [],
    [[u'Size', u'size', u'', ['/C', '/Ref']]],
    u'Model']
ok: FUNC <Model cv.dnn.Model.setInputSize [ARG Size size=]>

--- Incoming ---
[   u'cv.dnn.Model.setInputSize',
    u'Model',
    [],
    [[u'int', u'width', u'', []], [u'int', u'height', u'', []]],
    u'Model']
ok: FUNC <Model cv.dnn.Model.setInputSize [ARG int width=, ARG int height=]>

--- Incoming ---
[   u'cv.dnn.Model.setInputMean',
    u'Model',
    [],
    [[u'Scalar', u'mean', u'', ['/C', '/Ref']]],
    u'Model']
ok: FUNC <Model cv.dnn.Model.setInputMean [ARG Scalar mean=]>

--- Incoming ---
[   u'cv.dnn.Model.setInputScale',
    u'Model',
    [],
    [[u'double', u'scale', u'', []]],
    u'Model']
ok: FUNC <Model cv.dnn.Model.setInputScale [ARG double scale=]>

--- Incoming ---
[   u'cv.dnn.Model.setInputCrop',
    u'Model',
    [],
    [[u'bool', u'crop', u'', []]],
    u'Model']
ok: FUNC <Model cv.dnn.Model.setInputCrop [ARG bool crop=]>

--- Incoming ---
[   u'cv.dnn.Model.setInputSwapRB',
    u'Model',
    [],
    [[u'bool', u'swapRB', u'', []]],
    u'Model']
ok: FUNC <Model cv.dnn.Model.setInputSwapRB [ARG bool swapRB=]>

--- Incoming ---
[   u'cv.dnn.Model.setInputParams',
    u'void',
    [],
    [   [u'double', u'scale', u'1.0', []],
        [u'Size', u'size', u'Size()', ['/C', '/Ref']],
        [u'Scalar', u'mean', u'Scalar()', ['/C', '/Ref']],
        [u'bool', u'swapRB', u'false', []],
        [u'bool', u'crop', u'false', []]],
    u'void']
ok: FUNC <void cv.dnn.Model.setInputParams [ARG double scale=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false]>

--- Incoming ---
[   u'cv.dnn.Model.predict',
    u'void',
    [],
    [['Mat', u'frame', '', []], ['vector_Mat', u'outs', '', ['/O']]],
    u'void']
ok: FUNC <void cv.dnn.Model.predict [ARG Mat frame=, ARG vector_Mat outs=]>

--- Incoming ---
[   u'class cv.dnn.ClassificationModel',
    u': cv::dnn::Model',
    ['/Simple'],
    [],
    None]
ok: class CLASS cv.dnn::.ClassificationModel : Model, name: ClassificationModel, base: Model

--- Incoming ---
[   u'cv.dnn.ClassificationModel.ClassificationModel',
    '',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'String', u'config', u'""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.ClassificationModel.ClassificationModel [ARG String model=, ARG String config=""]>

--- Incoming ---
[   u'cv.dnn.ClassificationModel.ClassificationModel',
    '',
    [],
    [[u'Net', u'network', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.ClassificationModel.ClassificationModel [ARG Net network=]>

--- Incoming ---
[   u'cv.dnn.ClassificationModel.classify',
    u'void',
    [],
    [   ['Mat', u'frame', '', []],
        [u'int', u'classId', u'', ['/O', '/Ref']],
        [u'float', u'conf', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.dnn.ClassificationModel.classify [ARG Mat frame=, ARG int classId=, ARG float conf=]>

--- Incoming ---
[u'class cv.dnn.KeypointsModel', u': cv::dnn::Model', [], [], None]
ok: class CLASS cv.dnn::.KeypointsModel : Model, name: KeypointsModel, base: Model

--- Incoming ---
[   u'cv.dnn.KeypointsModel.KeypointsModel',
    '',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'String', u'config', u'""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.KeypointsModel.KeypointsModel [ARG String model=, ARG String config=""]>

--- Incoming ---
[   u'cv.dnn.KeypointsModel.KeypointsModel',
    '',
    [],
    [[u'Net', u'network', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.KeypointsModel.KeypointsModel [ARG Net network=]>

--- Incoming ---
[   u'cv.dnn.KeypointsModel.estimate',
    u'vector_Point2f',
    [],
    [['Mat', u'frame', '', []], [u'float', u'thresh', u'0.5', []]],
    u'std::vector<Point2f>']
ok: FUNC <vector_Point2f cv.dnn.KeypointsModel.estimate [ARG Mat frame=, ARG float thresh=0.5]>

--- Incoming ---
[u'class cv.dnn.SegmentationModel', u': cv::dnn::Model', [], [], None]
ok: class CLASS cv.dnn::.SegmentationModel : Model, name: SegmentationModel, base: Model

--- Incoming ---
[   u'cv.dnn.SegmentationModel.SegmentationModel',
    '',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'String', u'config', u'""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.SegmentationModel.SegmentationModel [ARG String model=, ARG String config=""]>

--- Incoming ---
[   u'cv.dnn.SegmentationModel.SegmentationModel',
    '',
    [],
    [[u'Net', u'network', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.SegmentationModel.SegmentationModel [ARG Net network=]>

--- Incoming ---
[   u'cv.dnn.SegmentationModel.segment',
    u'void',
    [],
    [['Mat', u'frame', '', []], ['Mat', u'mask', '', ['/O']]],
    u'void']
ok: FUNC <void cv.dnn.SegmentationModel.segment [ARG Mat frame=, ARG Mat mask=]>

--- Incoming ---
[u'class cv.dnn.DetectionModel', u': cv::dnn::Model', ['/Simple'], [], None]
ok: class CLASS cv.dnn::.DetectionModel : Model, name: DetectionModel, base: Model

--- Incoming ---
[   u'cv.dnn.DetectionModel.DetectionModel',
    '',
    [],
    [   [u'String', u'model', u'', ['/C', '/Ref']],
        [u'String', u'config', u'""', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.DetectionModel.DetectionModel [ARG String model=, ARG String config=""]>

--- Incoming ---
[   u'cv.dnn.DetectionModel.DetectionModel',
    '',
    [],
    [[u'Net', u'network', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.dnn.DetectionModel.DetectionModel [ARG Net network=]>

--- Incoming ---
[   u'cv.dnn.DetectionModel.detect',
    u'void',
    [],
    [   ['Mat', u'frame', '', []],
        [u'vector_int', u'classIds', u'', ['/O', '/Ref']],
        [u'vector_float', u'confidences', u'', ['/O', '/Ref']],
        [u'vector_Rect', u'boxes', u'', ['/O', '/Ref']],
        [u'float', u'confThreshold', u'0.5f', []],
        [u'float', u'nmsThreshold', u'0.0f', []]],
    u'void']
ok: FUNC <void cv.dnn.DetectionModel.detect [ARG Mat frame=, ARG vector_int classIds=, ARG vector_float confidences=, ARG vector_Rect boxes=, ARG float confThreshold=0.5f, ARG float nmsThreshold=0.0f]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/dnn/include/opencv2/dnn/utils/inference_engine.hpp =====
Namespaces: set([u'cv.dnn.<unnamed>', u'cv.dnn', u'cv', u'cv.dnn.CV__DNN_INLINE_NS'])

--- Incoming ---
[u'cv.dnn.getInferenceEngineBackendType', u'String', [], [], u'cv::String']
ok: FUNC <String cv.dnn..getInferenceEngineBackendType []>

--- Incoming ---
[   u'cv.dnn.setInferenceEngineBackendType',
    u'String',
    [],
    [[u'String', u'newBackendType', u'', ['/C', '/Ref']]],
    u'cv::String']
ok: FUNC <String cv.dnn..setInferenceEngineBackendType [ARG String newBackendType=]>

--- Incoming ---
[u'cv.dnn.resetMyriadDevice', u'void', [], [], u'void']
ok: FUNC <void cv.dnn..resetMyriadDevice []>

--- Incoming ---
[u'cv.dnn.getInferenceEngineVPUType', u'String', [], [], u'cv::String']
ok: FUNC <String cv.dnn..getInferenceEngineVPUType []>


===== Generating... =====
CLASS cv.dnn::.Layer : Algorithm
FUNC <int cv.dnn.Layer.outputNameToIndex [ARG String outputName=]>
java: int outputNameToIndex(String outputName)
FUNC <void cv.dnn.Layer.finalize [ARG vector_Mat inputs=, ARG vector_Mat outputs=]>
java: void finalize(List<Mat> inputs, List<Mat> outputs)
FUNC <void cv.dnn.Layer.run [ARG vector_Mat inputs=, ARG vector_Mat outputs=, ARG vector_Mat internals=]>
java: void run(List<Mat> inputs, List<Mat> outputs, List<Mat> internals)
FUNC <vector_Mat cv.dnn.Layer.get_blobs []>
java: List<Mat> get_blobs()
FUNC <void cv.dnn.Layer.set_blobs [ARG vector_Mat blobs=]>
java: void set_blobs(List<Mat> blobs)
FUNC <String cv.dnn.Layer.get_name []>
java: String get_name()
FUNC <String cv.dnn.Layer.get_type []>
java: String get_type()
FUNC <int cv.dnn.Layer.get_preferableTarget []>
java: int get_preferableTarget()
CLASS ::.Dnn : 
[CONST DNN_BACKEND_DEFAULT=0, CONST DNN_BACKEND_HALIDE=0+1, CONST DNN_BACKEND_INFERENCE_ENGINE=0+2, CONST DNN_BACKEND_OPENCV=0+3, CONST DNN_BACKEND_VKCOM=0+4, CONST DNN_BACKEND_CUDA=0+5]
[CONST DNN_TARGET_CPU=0, CONST DNN_TARGET_OPENCL=0+1, CONST DNN_TARGET_OPENCL_FP16=0+2, CONST DNN_TARGET_MYRIAD=0+3, CONST DNN_TARGET_VULKAN=0+4, CONST DNN_TARGET_FPGA=0+5, CONST DNN_TARGET_CUDA=0+6, CONST DNN_TARGET_CUDA_FP16=0+7]
FUNC <Mat cv.dnn..blobFromImage [ARG Mat image=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop, int ddepth)
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop)
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean, boolean swapRB)
java: Mat blobFromImage(Mat image, double scalefactor, Size size, Scalar mean)
java: Mat blobFromImage(Mat image, double scalefactor, Size size)
java: Mat blobFromImage(Mat image, double scalefactor)
java: Mat blobFromImage(Mat image)
FUNC <Mat cv.dnn..blobFromImages [ARG vector_Mat images=, ARG double scalefactor=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false, ARG int ddepth=CV_32F]>
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop, int ddepth)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean, boolean swapRB, boolean crop)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean, boolean swapRB)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size, Scalar mean)
java: Mat blobFromImages(List<Mat> images, double scalefactor, Size size)
java: Mat blobFromImages(List<Mat> images, double scalefactor)
java: Mat blobFromImages(List<Mat> images)
FUNC <Mat cv.dnn..readTensorFromONNX [ARG String path=]>
java: Mat readTensorFromONNX(String path)
FUNC <Mat cv.dnn..readTorchBlob [ARG String filename=, ARG bool isBinary=true]>
java: Mat readTorchBlob(String filename, boolean isBinary)
java: Mat readTorchBlob(String filename)
FUNC <Net cv.dnn..readNet [ARG String framework=, ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>
java: Net readNet(String framework, MatOfByte bufferModel, MatOfByte bufferConfig)
java: Net readNet(String framework, MatOfByte bufferModel)
FUNC <Net cv.dnn..readNet [ARG String model=, ARG String config="", ARG String framework=""]>
java: Net readNet(String model, String config, String framework)
java: Net readNet(String model, String config)
java: Net readNet(String model)
FUNC <Net cv.dnn..readNetFromCaffe [ARG String prototxt=, ARG String caffeModel=String()]>
java: Net readNetFromCaffe(String prototxt, String caffeModel)
java: Net readNetFromCaffe(String prototxt)
FUNC <Net cv.dnn..readNetFromCaffe [ARG vector_uchar bufferProto=, ARG vector_uchar bufferModel=std::vector<uchar>()]>
java: Net readNetFromCaffe(MatOfByte bufferProto, MatOfByte bufferModel)
java: Net readNetFromCaffe(MatOfByte bufferProto)
FUNC <Net cv.dnn..readNetFromDarknet [ARG String cfgFile=, ARG String darknetModel=String()]>
java: Net readNetFromDarknet(String cfgFile, String darknetModel)
java: Net readNetFromDarknet(String cfgFile)
FUNC <Net cv.dnn..readNetFromDarknet [ARG vector_uchar bufferCfg=, ARG vector_uchar bufferModel=std::vector<uchar>()]>
java: Net readNetFromDarknet(MatOfByte bufferCfg, MatOfByte bufferModel)
java: Net readNetFromDarknet(MatOfByte bufferCfg)
FUNC <Net cv.dnn..readNetFromModelOptimizer [ARG String xml=, ARG String bin=]>
java: Net readNetFromModelOptimizer(String xml, String bin)
FUNC <Net cv.dnn..readNetFromModelOptimizer [ARG vector_uchar bufferModelConfig=, ARG vector_uchar bufferWeights=]>
java: Net readNetFromModelOptimizer(MatOfByte bufferModelConfig, MatOfByte bufferWeights)
FUNC <Net cv.dnn..readNetFromONNX [ARG String onnxFile=]>
java: Net readNetFromONNX(String onnxFile)
FUNC <Net cv.dnn..readNetFromONNX [ARG vector_uchar buffer=]>
java: Net readNetFromONNX(MatOfByte buffer)
FUNC <Net cv.dnn..readNetFromTensorflow [ARG String model=, ARG String config=String()]>
java: Net readNetFromTensorflow(String model, String config)
java: Net readNetFromTensorflow(String model)
FUNC <Net cv.dnn..readNetFromTensorflow [ARG vector_uchar bufferModel=, ARG vector_uchar bufferConfig=std::vector<uchar>()]>
java: Net readNetFromTensorflow(MatOfByte bufferModel, MatOfByte bufferConfig)
java: Net readNetFromTensorflow(MatOfByte bufferModel)
FUNC <Net cv.dnn..readNetFromTorch [ARG String model=, ARG bool isBinary=true, ARG bool evaluate=true]>
java: Net readNetFromTorch(String model, boolean isBinary, boolean evaluate)
java: Net readNetFromTorch(String model, boolean isBinary)
java: Net readNetFromTorch(String model)
FUNC <String cv.dnn..getInferenceEngineBackendType []>
java: String getInferenceEngineBackendType()
FUNC <String cv.dnn..getInferenceEngineVPUType []>
java: String getInferenceEngineVPUType()
FUNC <String cv.dnn..setInferenceEngineBackendType [ARG String newBackendType=]>
java: String setInferenceEngineBackendType(String newBackendType)
FUNC <vector_Target cv.dnn..getAvailableTargets [ARG dnn_Backend be=]>
java: List<Integer> getAvailableTargets(int be)
FUNC <void cv.dnn..NMSBoxes [ARG vector_Rect2d bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>
java: void NMSBoxes(MatOfRect2d bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta, int top_k)
java: void NMSBoxes(MatOfRect2d bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta)
java: void NMSBoxes(MatOfRect2d bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices)
FUNC <void cv.dnn..NMSBoxes [ARG vector_RotatedRect bboxes=, ARG vector_float scores=, ARG float score_threshold=, ARG float nms_threshold=, ARG vector_int indices=, ARG float eta=1.f, ARG int top_k=0]>
java: void NMSBoxesRotated(MatOfRotatedRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta, int top_k)
java: void NMSBoxesRotated(MatOfRotatedRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices, float eta)
java: void NMSBoxesRotated(MatOfRotatedRect bboxes, MatOfFloat scores, float score_threshold, float nms_threshold, MatOfInt indices)
FUNC <void cv.dnn..imagesFromBlob [ARG Mat blob_=, ARG vector_Mat images_=]>
java: void imagesFromBlob(Mat blob_, List<Mat> images_)
FUNC <void cv.dnn..resetMyriadDevice []>
java: void resetMyriadDevice()
FUNC <void cv.dnn..shrinkCaffeModel [ARG String src=, ARG String dst=, ARG vector_String layersTypes=std::vector<String>()]>
java: void shrinkCaffeModel(String src, String dst, List<String> layersTypes)
java: void shrinkCaffeModel(String src, String dst)
FUNC <void cv.dnn..writeTextGraph [ARG String model=, ARG String output=]>
java: void writeTextGraph(String model, String output)
CLASS cv.dnn::.SegmentationModel : Model
FUNC < cv.dnn.SegmentationModel.SegmentationModel [ARG Net network=]>
java:  SegmentationModel(Net network)
FUNC < cv.dnn.SegmentationModel.SegmentationModel [ARG String model=, ARG String config=""]>
java:  SegmentationModel(String model, String config)
java:  SegmentationModel(String model)
FUNC <void cv.dnn.SegmentationModel.segment [ARG Mat frame=, ARG Mat mask=]>
java: void segment(Mat frame, Mat mask)
CLASS cv.dnn::.KeypointsModel : Model
FUNC < cv.dnn.KeypointsModel.KeypointsModel [ARG Net network=]>
java:  KeypointsModel(Net network)
FUNC < cv.dnn.KeypointsModel.KeypointsModel [ARG String model=, ARG String config=""]>
java:  KeypointsModel(String model, String config)
java:  KeypointsModel(String model)
FUNC <vector_Point2f cv.dnn.KeypointsModel.estimate [ARG Mat frame=, ARG float thresh=0.5]>
java: MatOfPoint2f estimate(Mat frame, float thresh)
java: MatOfPoint2f estimate(Mat frame)
CLASS cv.dnn::.DictValue : 
FUNC < cv.dnn.DictValue.DictValue [ARG String s=]>
java:  DictValue(String s)
FUNC < cv.dnn.DictValue.DictValue [ARG double p=]>
java:  DictValue(double p)
FUNC < cv.dnn.DictValue.DictValue [ARG int i=]>
java:  DictValue(int i)
FUNC <String cv.dnn.DictValue.getStringValue [ARG int idx=-1]>
java: String getStringValue(int idx)
java: String getStringValue()
FUNC <bool cv.dnn.DictValue.isInt []>
java: boolean isInt()
FUNC <bool cv.dnn.DictValue.isReal []>
java: boolean isReal()
FUNC <bool cv.dnn.DictValue.isString []>
java: boolean isString()
FUNC <double cv.dnn.DictValue.getRealValue [ARG int idx=-1]>
java: double getRealValue(int idx)
java: double getRealValue()
FUNC <int cv.dnn.DictValue.getIntValue [ARG int idx=-1]>
java: int getIntValue(int idx)
java: int getIntValue()
CLASS cv.dnn::.ClassificationModel : Model
FUNC < cv.dnn.ClassificationModel.ClassificationModel [ARG Net network=]>
java:  ClassificationModel(Net network)
FUNC < cv.dnn.ClassificationModel.ClassificationModel [ARG String model=, ARG String config=""]>
java:  ClassificationModel(String model, String config)
java:  ClassificationModel(String model)
FUNC <void cv.dnn.ClassificationModel.classify [ARG Mat frame=, ARG int classId=, ARG float conf=]>
java: void classify(Mat frame, int[] classId, float[] conf)
CLASS cv.dnn::.DetectionModel : Model
FUNC < cv.dnn.DetectionModel.DetectionModel [ARG Net network=]>
java:  DetectionModel(Net network)
FUNC < cv.dnn.DetectionModel.DetectionModel [ARG String model=, ARG String config=""]>
java:  DetectionModel(String model, String config)
java:  DetectionModel(String model)
FUNC <void cv.dnn.DetectionModel.detect [ARG Mat frame=, ARG vector_int classIds=, ARG vector_float confidences=, ARG vector_Rect boxes=, ARG float confThreshold=0.5f, ARG float nmsThreshold=0.0f]>
java: void detect(Mat frame, MatOfInt classIds, MatOfFloat confidences, MatOfRect boxes, float confThreshold, float nmsThreshold)
java: void detect(Mat frame, MatOfInt classIds, MatOfFloat confidences, MatOfRect boxes, float confThreshold)
java: void detect(Mat frame, MatOfInt classIds, MatOfFloat confidences, MatOfRect boxes)
CLASS cv.dnn::.Model : Net
FUNC < cv.dnn.Model.Model [ARG Net network=]>
java:  Model(Net network)
FUNC < cv.dnn.Model.Model [ARG String model=, ARG String config=""]>
java:  Model(String model, String config)
java:  Model(String model)
FUNC <Model cv.dnn.Model.setInputCrop [ARG bool crop=]>
java: Model setInputCrop(boolean crop)
FUNC <Model cv.dnn.Model.setInputMean [ARG Scalar mean=]>
java: Model setInputMean(Scalar mean)
FUNC <Model cv.dnn.Model.setInputScale [ARG double scale=]>
java: Model setInputScale(double scale)
FUNC <Model cv.dnn.Model.setInputSize [ARG Size size=]>
java: Model setInputSize(Size size)
FUNC <Model cv.dnn.Model.setInputSize [ARG int width=, ARG int height=]>
java: Model setInputSize(int width, int height)
FUNC <Model cv.dnn.Model.setInputSwapRB [ARG bool swapRB=]>
java: Model setInputSwapRB(boolean swapRB)
FUNC <void cv.dnn.Model.predict [ARG Mat frame=, ARG vector_Mat outs=]>
java: void predict(Mat frame, List<Mat> outs)
FUNC <void cv.dnn.Model.setInputParams [ARG double scale=1.0, ARG Size size=Size(), ARG Scalar mean=Scalar(), ARG bool swapRB=false, ARG bool crop=false]>
java: void setInputParams(double scale, Size size, Scalar mean, boolean swapRB, boolean crop)
java: void setInputParams(double scale, Size size, Scalar mean, boolean swapRB)
java: void setInputParams(double scale, Size size, Scalar mean)
java: void setInputParams(double scale, Size size)
java: void setInputParams(double scale)
java: void setInputParams()
CLASS cv.dnn::.Net : 
FUNC < cv.dnn.Net.Net []>
java:  Net()
FUNC <AsyncArray cv.dnn.Net.forwardAsync [ARG String outputName=String()]>
SKIP:AsyncArray cv::dnn::Net::forwardAsync(String outputName = String())	 due to RET type AsyncArray
FUNC <Mat cv.dnn.Net.forward [ARG String outputName=String()]>
java: Mat forward(String outputName)
java: Mat forward()
FUNC <Mat cv.dnn.Net.getParam [ARG LayerId layer=, ARG int numParam=0]>
java: Mat getParam(DictValue layer, int numParam)
java: Mat getParam(DictValue layer)
FUNC <Net cv.dnn.Net.readFromModelOptimizer [ARG String xml=, ARG String bin=]>
java: Net readFromModelOptimizer(String xml, String bin)
FUNC <Net cv.dnn.Net.readFromModelOptimizer [ARG vector_uchar bufferModelConfig=, ARG vector_uchar bufferWeights=]>
java: Net readFromModelOptimizer(MatOfByte bufferModelConfig, MatOfByte bufferWeights)
FUNC <Ptr_Layer cv.dnn.Net.getLayer [ARG LayerId layerId=]>
java: Layer getLayer(DictValue layerId)
FUNC <String cv.dnn.Net.dump []>
java: String dump()
FUNC <bool cv.dnn.Net.empty []>
java: boolean empty()
FUNC <int cv.dnn.Net.getLayerId [ARG String layer=]>
java: int getLayerId(String layer)
FUNC <int cv.dnn.Net.getLayersCount [ARG String layerType=]>
java: int getLayersCount(String layerType)
FUNC <int64 cv.dnn.Net.getFLOPS [ARG MatShape netInputShape=]>
java: long getFLOPS(MatOfInt netInputShape)
FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG MatShape netInputShape=]>
java: long getFLOPS(int layerId, MatOfInt netInputShape)
FUNC <int64 cv.dnn.Net.getFLOPS [ARG int layerId=, ARG vector_MatShape netInputShapes=]>
java: long getFLOPS(int layerId, List<MatOfInt> netInputShapes)
FUNC <int64 cv.dnn.Net.getFLOPS [ARG vector_MatShape netInputShapes=]>
java: long getFLOPS(List<MatOfInt> netInputShapes)
FUNC <int64 cv.dnn.Net.getPerfProfile [ARG vector_double timings=]>
java: long getPerfProfile(MatOfDouble timings)
FUNC <vector_String cv.dnn.Net.getLayerNames []>
java: List<String> getLayerNames()
FUNC <vector_String cv.dnn.Net.getUnconnectedOutLayersNames []>
java: List<String> getUnconnectedOutLayersNames()
FUNC <vector_int cv.dnn.Net.getUnconnectedOutLayers []>
java: MatOfInt getUnconnectedOutLayers()
FUNC <void cv.dnn.Net.connect [ARG String outPin=, ARG String inpPin=]>
java: void connect(String outPin, String inpPin)
FUNC <void cv.dnn.Net.dumpToFile [ARG String path=]>
java: void dumpToFile(String path)
FUNC <void cv.dnn.Net.enableFusion [ARG bool fusion=]>
java: void enableFusion(boolean fusion)
FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG String outputName=String()]>
java: void forward(List<Mat> outputBlobs, String outputName)
java: void forward(List<Mat> outputBlobs)
FUNC <void cv.dnn.Net.forward [ARG vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>
java: void forward(List<Mat> outputBlobs, List<String> outBlobNames)
FUNC <void cv.dnn.Net.forward [ARG vector_vector_Mat outputBlobs=, ARG vector_String outBlobNames=]>
SKIP:void cv::dnn::Net::forward(vector_vector_Mat& outputBlobs, vector_String outBlobNames)	 due to ARG type vector_vector_Mat/O
FUNC <void cv.dnn.Net.getLayerTypes [ARG vector_String layersTypes=]>
java: void getLayerTypes(List<String> layersTypes)
FUNC <void cv.dnn.Net.getLayersShapes [ARG MatShape netInputShape=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>
SKIP:void cv::dnn::Net::getLayersShapes(MatShape netInputShape, vector_int& layersIds, vector_vector_MatShape& inLayersShapes, vector_vector_MatShape& outLayersShapes)	 due to ARG type vector_vector_MatShape/O
FUNC <void cv.dnn.Net.getLayersShapes [ARG vector_MatShape netInputShapes=, ARG vector_int layersIds=, ARG vector_vector_MatShape inLayersShapes=, ARG vector_vector_MatShape outLayersShapes=]>
SKIP:void cv::dnn::Net::getLayersShapes(vector_MatShape netInputShapes, vector_int& layersIds, vector_vector_MatShape& inLayersShapes, vector_vector_MatShape& outLayersShapes)	 due to ARG type vector_vector_MatShape/O
FUNC <void cv.dnn.Net.getMemoryConsumption [ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>
java: void getMemoryConsumption(MatOfInt netInputShape, long[] weights, long[] blobs)
FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG MatShape netInputShape=, ARG size_t weights=, ARG size_t blobs=]>
java: void getMemoryConsumption(int layerId, MatOfInt netInputShape, long[] weights, long[] blobs)
FUNC <void cv.dnn.Net.getMemoryConsumption [ARG int layerId=, ARG vector_MatShape netInputShapes=, ARG size_t weights=, ARG size_t blobs=]>
java: void getMemoryConsumption(int layerId, List<MatOfInt> netInputShapes, long[] weights, long[] blobs)
FUNC <void cv.dnn.Net.setHalideScheduler [ARG String scheduler=]>
java: void setHalideScheduler(String scheduler)
FUNC <void cv.dnn.Net.setInput [ARG Mat blob=, ARG String name="", ARG double scalefactor=1.0, ARG Scalar mean=Scalar()]>
java: void setInput(Mat blob, String name, double scalefactor, Scalar mean)
java: void setInput(Mat blob, String name, double scalefactor)
java: void setInput(Mat blob, String name)
java: void setInput(Mat blob)
FUNC <void cv.dnn.Net.setInputShape [ARG String inputName=, ARG MatShape shape=]>
java: void setInputShape(String inputName, MatOfInt shape)
FUNC <void cv.dnn.Net.setInputsNames [ARG vector_String inputBlobNames=]>
java: void setInputsNames(List<String> inputBlobNames)
FUNC <void cv.dnn.Net.setParam [ARG LayerId layer=, ARG int numParam=, ARG Mat blob=]>
java: void setParam(DictValue layer, int numParam, Mat blob)
FUNC <void cv.dnn.Net.setPreferableBackend [ARG int backendId=]>
java: void setPreferableBackend(int backendId)
FUNC <void cv.dnn.Net.setPreferableTarget [ARG int targetId=]>
java: void setPreferableTarget(int targetId)

=== MODULE: features2d (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/features2d) ===


Files (1):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/features2d/include/opencv2/features2d.hpp']

Common headers (1):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/features2d/misc/java/src/cpp/features2d_converters.hpp']
ok: class CLASS ::.Features2d : , name: Features2d, base: 

===== Common header : /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/features2d/misc/java/src/cpp/features2d_converters.hpp =====


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/features2d/include/opencv2/features2d.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'class cv.Feature2D',
    u': cv::Algorithm, cv::class, cv::Feature2D, cv::Algorithm',
    [],
    [],
    None]
ok: class CLASS cv::.Feature2D : Algorithm, name: Feature2D, base: Algorithm

--- Incoming ---
[   u'cv.Feature2D.detect',
    u'void',
    ['/V'],
    [   ['Mat', u'image', '', []],
        [u'vector_KeyPoint', u'keypoints', u'', ['/O', '/Ref']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.Feature2D.detect [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.Feature2D.detect',
    u'void',
    ['/V'],
    [   ['vector_Mat', u'images', '', []],
        [u'vector_vector_KeyPoint', u'keypoints', u'', ['/O', '/Ref']],
        ['vector_Mat', u'masks', u'vector_Mat()', []]],
    u'void']
ok: FUNC <void cv.Feature2D.detect [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat masks=vector_Mat()]>

--- Incoming ---
[   u'cv.Feature2D.compute',
    u'void',
    ['/V'],
    [   ['Mat', u'image', '', []],
        [u'vector_KeyPoint', u'keypoints', u'', ['/O', '/IO', '/Ref']],
        ['Mat', u'descriptors', '', ['/O']]],
    u'void']
ok: FUNC <void cv.Feature2D.compute [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=]>

--- Incoming ---
[   u'cv.Feature2D.compute',
    u'void',
    ['/V'],
    [   ['vector_Mat', u'images', '', []],
        [u'vector_vector_KeyPoint', u'keypoints', u'', ['/O', '/IO', '/Ref']],
        ['vector_Mat', u'descriptors', '', ['/O']]],
    u'void']
ok: FUNC <void cv.Feature2D.compute [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat descriptors=]>

--- Incoming ---
[   u'cv.Feature2D.detectAndCompute',
    u'void',
    ['/V'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'mask', '', []],
        [u'vector_KeyPoint', u'keypoints', u'', ['/O', '/Ref']],
        ['Mat', u'descriptors', '', ['/O']],
        [u'bool', u'useProvidedKeypoints', u'false', []]],
    u'void']
ok: FUNC <void cv.Feature2D.detectAndCompute [ARG Mat image=, ARG Mat mask=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=, ARG bool useProvidedKeypoints=false]>

--- Incoming ---
[u'cv.Feature2D.descriptorSize', u'int', ['/C', '/V'], [], u'int']
ok: FUNC <int cv.Feature2D.descriptorSize []>

--- Incoming ---
[u'cv.Feature2D.descriptorType', u'int', ['/C', '/V'], [], u'int']
ok: FUNC <int cv.Feature2D.descriptorType []>

--- Incoming ---
[u'cv.Feature2D.defaultNorm', u'int', ['/C', '/V'], [], u'int']
ok: FUNC <int cv.Feature2D.defaultNorm []>

--- Incoming ---
[   u'cv.Feature2D.write',
    u'void',
    ['/C'],
    [[u'String', u'fileName', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Feature2D.write [ARG String fileName=]>

--- Incoming ---
[   u'cv.Feature2D.read',
    u'void',
    [],
    [[u'String', u'fileName', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Feature2D.read [ARG String fileName=]>

--- Incoming ---
[   u'cv.Feature2D.read',
    u'void',
    ['/V'],
    [[u'FileNode', 'arg1', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Feature2D.read [ARG FileNode arg1=]>

--- Incoming ---
[u'cv.Feature2D.empty', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.Feature2D.empty []>

--- Incoming ---
[u'cv.Feature2D.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.Feature2D.getDefaultName []>

--- Incoming ---
[   u'cv.Feature2D.write',
    u'void',
    ['/C'],
    [   [u'Ptr_FileStorage', u'fs', u'', ['/C', '/Ref']],
        [u'String', u'name', u'String()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.Feature2D.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>

--- Incoming ---
[u'class cv.BRISK', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.BRISK : Feature2D, name: BRISK, base: Feature2D

--- Incoming ---
[   u'cv.BRISK.create',
    u'Ptr_BRISK',
    ['/S'],
    [   [u'int', u'thresh', u'30', []],
        [u'int', u'octaves', u'3', []],
        [u'float', u'patternScale', u'1.0f', []]],
    u'Ptr<BRISK>']
ok: FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=30, ARG int octaves=3, ARG float patternScale=1.0f]>

--- Incoming ---
[   u'cv.BRISK.create',
    u'Ptr_BRISK',
    ['/S'],
    [   [u'vector_float', u'radiusList', u'', ['/C', '/Ref']],
        [u'vector_int', u'numberList', u'', ['/C', '/Ref']],
        [u'float', u'dMax', u'5.85f', []],
        [u'float', u'dMin', u'8.2f', []],
        [   u'vector_int',
            u'indexChange',
            u'std::vector<int>()',
            ['/C', '/Ref']]],
    u'Ptr<BRISK>']
ok: FUNC <Ptr_BRISK cv.BRISK.create [ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>

--- Incoming ---
[   u'cv.BRISK.create',
    u'Ptr_BRISK',
    ['/S'],
    [   [u'int', u'thresh', u'', []],
        [u'int', u'octaves', u'', []],
        [u'vector_float', u'radiusList', u'', ['/C', '/Ref']],
        [u'vector_int', u'numberList', u'', ['/C', '/Ref']],
        [u'float', u'dMax', u'5.85f', []],
        [u'float', u'dMin', u'8.2f', []],
        [   u'vector_int',
            u'indexChange',
            u'std::vector<int>()',
            ['/C', '/Ref']]],
    u'Ptr<BRISK>']
ok: FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=, ARG int octaves=, ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>

--- Incoming ---
[u'cv.BRISK.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.BRISK.getDefaultName []>

--- Incoming ---
[   u'cv.BRISK.setThreshold',
    u'void',
    ['/V'],
    [[u'int', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.BRISK.setThreshold [ARG int threshold=]>

--- Incoming ---
[u'cv.BRISK.getThreshold', u'int', ['/C', '/V'], [], u'int']
ok: FUNC <int cv.BRISK.getThreshold []>

--- Incoming ---
[   u'cv.BRISK.setOctaves',
    u'void',
    ['/V'],
    [[u'int', u'octaves', u'', []]],
    u'void']
ok: FUNC <void cv.BRISK.setOctaves [ARG int octaves=]>

--- Incoming ---
[u'cv.BRISK.getOctaves', u'int', ['/C', '/V'], [], u'int']
ok: FUNC <int cv.BRISK.getOctaves []>

--- Incoming ---
[u'class cv.ORB', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.ORB : Feature2D, name: ORB, base: Feature2D

--- Incoming ---
[   u'enum cv.ORB.ScoreType',
    '',
    [],
    [   [u'const cv.ORB.HARRIS_SCORE', u'0', [], [], None, ''],
        [u'const cv.ORB.FAST_SCORE', u'1', [], [], None, '']],
    None]
ok: CONST HARRIS_SCORE=0
ok: CONST FAST_SCORE=1

--- Incoming ---
[   u'cv.ORB.create',
    u'Ptr_ORB',
    ['/S'],
    [   [u'int', u'nfeatures', u'500', []],
        [u'float', u'scaleFactor', u'1.2f', []],
        [u'int', u'nlevels', u'8', []],
        [u'int', u'edgeThreshold', u'31', []],
        [u'int', u'firstLevel', u'0', []],
        [u'int', u'WTA_K', u'2', []],
        [u'ORB_ScoreType', u'scoreType', u'ORB::HARRIS_SCORE', []],
        [u'int', u'patchSize', u'31', []],
        [u'int', u'fastThreshold', u'20', []]],
    u'Ptr<ORB>']
ok: FUNC <Ptr_ORB cv.ORB.create [ARG int nfeatures=500, ARG float scaleFactor=1.2f, ARG int nlevels=8, ARG int edgeThreshold=31, ARG int firstLevel=0, ARG int WTA_K=2, ARG ORB_ScoreType scoreType=ORB::HARRIS_SCORE, ARG int patchSize=31, ARG int fastThreshold=20]>

--- Incoming ---
[   u'cv.ORB.setMaxFeatures',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxFeatures', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setMaxFeatures [ARG int maxFeatures=]>

--- Incoming ---
[u'cv.ORB.getMaxFeatures', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getMaxFeatures []>

--- Incoming ---
[   u'cv.ORB.setScaleFactor',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'scaleFactor', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setScaleFactor [ARG double scaleFactor=]>

--- Incoming ---
[u'cv.ORB.getScaleFactor', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.ORB.getScaleFactor []>

--- Incoming ---
[   u'cv.ORB.setNLevels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'nlevels', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setNLevels [ARG int nlevels=]>

--- Incoming ---
[u'cv.ORB.getNLevels', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getNLevels []>

--- Incoming ---
[   u'cv.ORB.setEdgeThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'edgeThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setEdgeThreshold [ARG int edgeThreshold=]>

--- Incoming ---
[u'cv.ORB.getEdgeThreshold', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getEdgeThreshold []>

--- Incoming ---
[   u'cv.ORB.setFirstLevel',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'firstLevel', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setFirstLevel [ARG int firstLevel=]>

--- Incoming ---
[u'cv.ORB.getFirstLevel', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getFirstLevel []>

--- Incoming ---
[   u'cv.ORB.setWTA_K',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'wta_k', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setWTA_K [ARG int wta_k=]>

--- Incoming ---
[u'cv.ORB.getWTA_K', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getWTA_K []>

--- Incoming ---
[   u'cv.ORB.setScoreType',
    u'void',
    ['/V', '/PV'],
    [[u'ORB_ScoreType', u'scoreType', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setScoreType [ARG ORB_ScoreType scoreType=]>

--- Incoming ---
[   u'cv.ORB.getScoreType',
    u'ORB_ScoreType',
    ['/C', '/V', '/PV'],
    [],
    u'ORB::ScoreType']
ok: FUNC <ORB_ScoreType cv.ORB.getScoreType []>

--- Incoming ---
[   u'cv.ORB.setPatchSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'patchSize', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setPatchSize [ARG int patchSize=]>

--- Incoming ---
[u'cv.ORB.getPatchSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getPatchSize []>

--- Incoming ---
[   u'cv.ORB.setFastThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'fastThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.ORB.setFastThreshold [ARG int fastThreshold=]>

--- Incoming ---
[u'cv.ORB.getFastThreshold', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.ORB.getFastThreshold []>

--- Incoming ---
[u'cv.ORB.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.ORB.getDefaultName []>

--- Incoming ---
[u'class cv.MSER', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.MSER : Feature2D, name: MSER, base: Feature2D

--- Incoming ---
[   u'cv.MSER.create',
    u'Ptr_MSER',
    ['/S'],
    [   [u'int', u'_delta', u'5', []],
        [u'int', u'_min_area', u'60', []],
        [u'int', u'_max_area', u'14400', []],
        [u'double', u'_max_variation', u'0.25', []],
        [u'double', u'_min_diversity', u'.2', []],
        [u'int', u'_max_evolution', u'200', []],
        [u'double', u'_area_threshold', u'1.01', []],
        [u'double', u'_min_margin', u'0.003', []],
        [u'int', u'_edge_blur_size', u'5', []]],
    u'Ptr<MSER>']
ok: FUNC <Ptr_MSER cv.MSER.create [ARG int _delta=5, ARG int _min_area=60, ARG int _max_area=14400, ARG double _max_variation=0.25, ARG double _min_diversity=.2, ARG int _max_evolution=200, ARG double _area_threshold=1.01, ARG double _min_margin=0.003, ARG int _edge_blur_size=5]>

--- Incoming ---
[   u'cv.MSER.detectRegions',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        [u'vector_vector_Point', u'msers', u'', ['/O', '/Ref']],
        [u'vector_Rect', u'bboxes', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.MSER.detectRegions [ARG Mat image=, ARG vector_vector_Point msers=, ARG vector_Rect bboxes=]>

--- Incoming ---
[   u'cv.MSER.setDelta',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'delta', u'', []]],
    u'void']
ok: FUNC <void cv.MSER.setDelta [ARG int delta=]>

--- Incoming ---
[u'cv.MSER.getDelta', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.MSER.getDelta []>

--- Incoming ---
[   u'cv.MSER.setMinArea',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'minArea', u'', []]],
    u'void']
ok: FUNC <void cv.MSER.setMinArea [ARG int minArea=]>

--- Incoming ---
[u'cv.MSER.getMinArea', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.MSER.getMinArea []>

--- Incoming ---
[   u'cv.MSER.setMaxArea',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxArea', u'', []]],
    u'void']
ok: FUNC <void cv.MSER.setMaxArea [ARG int maxArea=]>

--- Incoming ---
[u'cv.MSER.getMaxArea', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.MSER.getMaxArea []>

--- Incoming ---
[   u'cv.MSER.setPass2Only',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'f', u'', []]],
    u'void']
ok: FUNC <void cv.MSER.setPass2Only [ARG bool f=]>

--- Incoming ---
[u'cv.MSER.getPass2Only', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.MSER.getPass2Only []>

--- Incoming ---
[u'cv.MSER.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.MSER.getDefaultName []>

--- Incoming ---
[u'class cv.FastFeatureDetector', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.FastFeatureDetector : Feature2D, name: FastFeatureDetector, base: Feature2D

--- Incoming ---
[   u'enum cv.FastFeatureDetector.DetectorType',
    '',
    [],
    [   [u'const cv.FastFeatureDetector.TYPE_5_8', u'0', [], [], None, ''],
        [u'const cv.FastFeatureDetector.TYPE_7_12', u'1', [], [], None, ''],
        [u'const cv.FastFeatureDetector.TYPE_9_16', u'2', [], [], None, '']],
    None]
ok: CONST TYPE_5_8=0
ok: CONST TYPE_7_12=1
ok: CONST TYPE_9_16=2

--- Incoming ---
[   u'enum cv.FastFeatureDetector.<unnamed>',
    '',
    [],
    [   [   u'const cv.FastFeatureDetector.THRESHOLD',
            u'10000',
            [],
            [],
            None,
            ''],
        [   u'const cv.FastFeatureDetector.NONMAX_SUPPRESSION',
            u'10001',
            [],
            [],
            None,
            ''],
        [u'const cv.FastFeatureDetector.FAST_N', u'10002', [], [], None, '']],
    None]
ok: CONST THRESHOLD=10000
ok: CONST NONMAX_SUPPRESSION=10001
ok: CONST FAST_N=10002

--- Incoming ---
[   u'cv.FastFeatureDetector.create',
    u'Ptr_FastFeatureDetector',
    ['/S'],
    [   [u'int', u'threshold', u'10', []],
        [u'bool', u'nonmaxSuppression', u'true', []],
        [   u'FastFeatureDetector_DetectorType',
            u'type',
            u'FastFeatureDetector::TYPE_9_16',
            []]],
    u'Ptr<FastFeatureDetector>']
ok: FUNC <Ptr_FastFeatureDetector cv.FastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG FastFeatureDetector_DetectorType type=FastFeatureDetector::TYPE_9_16]>

--- Incoming ---
[   u'cv.FastFeatureDetector.setThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.FastFeatureDetector.setThreshold [ARG int threshold=]>

--- Incoming ---
[   u'cv.FastFeatureDetector.getThreshold',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.FastFeatureDetector.getThreshold []>

--- Incoming ---
[   u'cv.FastFeatureDetector.setNonmaxSuppression',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'f', u'', []]],
    u'void']
ok: FUNC <void cv.FastFeatureDetector.setNonmaxSuppression [ARG bool f=]>

--- Incoming ---
[   u'cv.FastFeatureDetector.getNonmaxSuppression',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.FastFeatureDetector.getNonmaxSuppression []>

--- Incoming ---
[   u'cv.FastFeatureDetector.setType',
    u'void',
    ['/V', '/PV'],
    [[u'FastFeatureDetector_DetectorType', u'type', u'', []]],
    u'void']
ok: FUNC <void cv.FastFeatureDetector.setType [ARG FastFeatureDetector_DetectorType type=]>

--- Incoming ---
[   u'cv.FastFeatureDetector.getType',
    u'FastFeatureDetector_DetectorType',
    ['/C', '/V', '/PV'],
    [],
    u'FastFeatureDetector::DetectorType']
ok: FUNC <FastFeatureDetector_DetectorType cv.FastFeatureDetector.getType []>

--- Incoming ---
[   u'cv.FastFeatureDetector.getDefaultName',
    u'String',
    ['/C', '/V'],
    [],
    u'String']
ok: FUNC <String cv.FastFeatureDetector.getDefaultName []>

--- Incoming ---
[u'class cv.AgastFeatureDetector', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.AgastFeatureDetector : Feature2D, name: AgastFeatureDetector, base: Feature2D

--- Incoming ---
[   u'enum cv.AgastFeatureDetector.DetectorType',
    '',
    [],
    [   [u'const cv.AgastFeatureDetector.AGAST_5_8', u'0', [], [], None, ''],
        [   u'const cv.AgastFeatureDetector.AGAST_7_12d',
            u'1',
            [],
            [],
            None,
            ''],
        [   u'const cv.AgastFeatureDetector.AGAST_7_12s',
            u'2',
            [],
            [],
            None,
            ''],
        [u'const cv.AgastFeatureDetector.OAST_9_16', u'3', [], [], None, '']],
    None]
ok: CONST AGAST_5_8=0
ok: CONST AGAST_7_12d=1
ok: CONST AGAST_7_12s=2
ok: CONST OAST_9_16=3

--- Incoming ---
[   u'enum cv.AgastFeatureDetector.<unnamed>',
    '',
    [],
    [   [   u'const cv.AgastFeatureDetector.THRESHOLD',
            u'10000',
            [],
            [],
            None,
            ''],
        [   u'const cv.AgastFeatureDetector.NONMAX_SUPPRESSION',
            u'10001',
            [],
            [],
            None,
            '']],
    None]
ok: CONST THRESHOLD=10000
ok: CONST NONMAX_SUPPRESSION=10001

--- Incoming ---
[   u'cv.AgastFeatureDetector.create',
    u'Ptr_AgastFeatureDetector',
    ['/S'],
    [   [u'int', u'threshold', u'10', []],
        [u'bool', u'nonmaxSuppression', u'true', []],
        [   u'AgastFeatureDetector_DetectorType',
            u'type',
            u'AgastFeatureDetector::OAST_9_16',
            []]],
    u'Ptr<AgastFeatureDetector>']
ok: FUNC <Ptr_AgastFeatureDetector cv.AgastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG AgastFeatureDetector_DetectorType type=AgastFeatureDetector::OAST_9_16]>

--- Incoming ---
[   u'cv.AgastFeatureDetector.setThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.AgastFeatureDetector.setThreshold [ARG int threshold=]>

--- Incoming ---
[   u'cv.AgastFeatureDetector.getThreshold',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.AgastFeatureDetector.getThreshold []>

--- Incoming ---
[   u'cv.AgastFeatureDetector.setNonmaxSuppression',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'f', u'', []]],
    u'void']
ok: FUNC <void cv.AgastFeatureDetector.setNonmaxSuppression [ARG bool f=]>

--- Incoming ---
[   u'cv.AgastFeatureDetector.getNonmaxSuppression',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.AgastFeatureDetector.getNonmaxSuppression []>

--- Incoming ---
[   u'cv.AgastFeatureDetector.setType',
    u'void',
    ['/V', '/PV'],
    [[u'AgastFeatureDetector_DetectorType', u'type', u'', []]],
    u'void']
ok: FUNC <void cv.AgastFeatureDetector.setType [ARG AgastFeatureDetector_DetectorType type=]>

--- Incoming ---
[   u'cv.AgastFeatureDetector.getType',
    u'AgastFeatureDetector_DetectorType',
    ['/C', '/V', '/PV'],
    [],
    u'AgastFeatureDetector::DetectorType']
ok: FUNC <AgastFeatureDetector_DetectorType cv.AgastFeatureDetector.getType []>

--- Incoming ---
[   u'cv.AgastFeatureDetector.getDefaultName',
    u'String',
    ['/C', '/V'],
    [],
    u'String']
ok: FUNC <String cv.AgastFeatureDetector.getDefaultName []>

--- Incoming ---
[u'class cv.GFTTDetector', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.GFTTDetector : Feature2D, name: GFTTDetector, base: Feature2D

--- Incoming ---
[   u'cv.GFTTDetector.create',
    u'Ptr_GFTTDetector',
    ['/S'],
    [   [u'int', u'maxCorners', u'1000', []],
        [u'double', u'qualityLevel', u'0.01', []],
        [u'double', u'minDistance', u'1', []],
        [u'int', u'blockSize', u'3', []],
        [u'bool', u'useHarrisDetector', u'false', []],
        [u'double', u'k', u'0.04', []]],
    u'Ptr<GFTTDetector>']
ok: FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=1000, ARG double qualityLevel=0.01, ARG double minDistance=1, ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   u'cv.GFTTDetector.create',
    u'Ptr_GFTTDetector',
    ['/S'],
    [   [u'int', u'maxCorners', u'', []],
        [u'double', u'qualityLevel', u'', []],
        [u'double', u'minDistance', u'', []],
        [u'int', u'blockSize', u'', []],
        [u'int', u'gradiantSize', u'', []],
        [u'bool', u'useHarrisDetector', u'false', []],
        [u'double', u'k', u'0.04', []]],
    u'Ptr<GFTTDetector>']
ok: FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG int blockSize=, ARG int gradiantSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>

--- Incoming ---
[   u'cv.GFTTDetector.setMaxFeatures',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxFeatures', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setMaxFeatures [ARG int maxFeatures=]>

--- Incoming ---
[u'cv.GFTTDetector.getMaxFeatures', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.GFTTDetector.getMaxFeatures []>

--- Incoming ---
[   u'cv.GFTTDetector.setQualityLevel',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'qlevel', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setQualityLevel [ARG double qlevel=]>

--- Incoming ---
[   u'cv.GFTTDetector.getQualityLevel',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GFTTDetector.getQualityLevel []>

--- Incoming ---
[   u'cv.GFTTDetector.setMinDistance',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'minDistance', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setMinDistance [ARG double minDistance=]>

--- Incoming ---
[   u'cv.GFTTDetector.getMinDistance',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.GFTTDetector.getMinDistance []>

--- Incoming ---
[   u'cv.GFTTDetector.setBlockSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'blockSize', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setBlockSize [ARG int blockSize=]>

--- Incoming ---
[u'cv.GFTTDetector.getBlockSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.GFTTDetector.getBlockSize []>

--- Incoming ---
[   u'cv.GFTTDetector.setHarrisDetector',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setHarrisDetector [ARG bool val=]>

--- Incoming ---
[   u'cv.GFTTDetector.getHarrisDetector',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.GFTTDetector.getHarrisDetector []>

--- Incoming ---
[   u'cv.GFTTDetector.setK',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'k', u'', []]],
    u'void']
ok: FUNC <void cv.GFTTDetector.setK [ARG double k=]>

--- Incoming ---
[u'cv.GFTTDetector.getK', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.GFTTDetector.getK []>

--- Incoming ---
[u'cv.GFTTDetector.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.GFTTDetector.getDefaultName []>

--- Incoming ---
[u'class cv.SimpleBlobDetector', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.SimpleBlobDetector : Feature2D, name: SimpleBlobDetector, base: Feature2D

--- Incoming ---
[   u'struct cv.SimpleBlobDetector.Params',
    '',
    ['/Simple'],
    [   [u'float', u'thresholdStep', '', ['/RW']],
        [u'float', u'minThreshold', '', ['/RW']],
        [u'float', u'maxThreshold', '', ['/RW']],
        [u'size_t', u'minRepeatability', '', ['/RW']],
        [u'float', u'minDistBetweenBlobs', '', ['/RW']],
        [u'bool', u'filterByColor', '', ['/RW']],
        [u'uchar', u'blobColor', '', ['/RW']],
        [u'bool', u'filterByArea', '', ['/RW']],
        [u'float', u'minArea', '', ['/RW']],
        [u'float', u'maxArea', '', ['/RW']],
        [u'bool', u'filterByCircularity', '', ['/RW']],
        [u'float', u'minCircularity', '', ['/RW']],
        [u'float', u'maxCircularity', '', ['/RW']],
        [u'bool', u'filterByInertia', '', ['/RW']],
        [u'float', u'minInertiaRatio', '', ['/RW']],
        [u'float', u'maxInertiaRatio', '', ['/RW']],
        [u'bool', u'filterByConvexity', '', ['/RW']],
        [u'float', u'minConvexity', '', ['/RW']],
        [u'float', u'maxConvexity', '', ['/RW']]],
    None]
ok: class CLASS cv::SimpleBlobDetector.Params : , name: Params, base: 

--- Incoming ---
[u'cv.SimpleBlobDetector.Params.Params', '', [], [], None]
ok: FUNC < cv.SimpleBlobDetector.Params.Params []>

--- Incoming ---
[   u'cv.SimpleBlobDetector.create',
    u'Ptr_SimpleBlobDetector',
    ['/S'],
    [   [   u'SimpleBlobDetector_Params',
            u'parameters',
            u'SimpleBlobDetector::Params()',
            ['/C', '/Ref']]],
    u'Ptr<SimpleBlobDetector>']
ok: FUNC <Ptr_SimpleBlobDetector cv.SimpleBlobDetector.create [ARG SimpleBlobDetector_Params parameters=SimpleBlobDetector::Params()]>

--- Incoming ---
[   u'cv.SimpleBlobDetector.getDefaultName',
    u'String',
    ['/C', '/V'],
    [],
    u'String']
ok: FUNC <String cv.SimpleBlobDetector.getDefaultName []>

--- Incoming ---
[u'class cv.KAZE', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.KAZE : Feature2D, name: KAZE, base: Feature2D

--- Incoming ---
[   u'enum cv.KAZE.DiffusivityType',
    '',
    [],
    [   [u'const cv.KAZE.DIFF_PM_G1', u'0', [], [], None, ''],
        [u'const cv.KAZE.DIFF_PM_G2', u'1', [], [], None, ''],
        [u'const cv.KAZE.DIFF_WEICKERT', u'2', [], [], None, ''],
        [u'const cv.KAZE.DIFF_CHARBONNIER', u'3', [], [], None, '']],
    None]
ok: CONST DIFF_PM_G1=0
ok: CONST DIFF_PM_G2=1
ok: CONST DIFF_WEICKERT=2
ok: CONST DIFF_CHARBONNIER=3

--- Incoming ---
[   u'cv.KAZE.create',
    u'Ptr_KAZE',
    ['/S'],
    [   [u'bool', u'extended', u'false', []],
        [u'bool', u'upright', u'false', []],
        [u'float', u'threshold', u'0.001f', []],
        [u'int', u'nOctaves', u'4', []],
        [u'int', u'nOctaveLayers', u'4', []],
        [u'KAZE_DiffusivityType', u'diffusivity', u'KAZE::DIFF_PM_G2', []]],
    u'Ptr<KAZE>']
ok: FUNC <Ptr_KAZE cv.KAZE.create [ARG bool extended=false, ARG bool upright=false, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>

--- Incoming ---
[   u'cv.KAZE.setExtended',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'extended', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setExtended [ARG bool extended=]>

--- Incoming ---
[u'cv.KAZE.getExtended', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.KAZE.getExtended []>

--- Incoming ---
[   u'cv.KAZE.setUpright',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'upright', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setUpright [ARG bool upright=]>

--- Incoming ---
[u'cv.KAZE.getUpright', u'bool', ['/C', '/V', '/PV'], [], u'bool']
ok: FUNC <bool cv.KAZE.getUpright []>

--- Incoming ---
[   u'cv.KAZE.setThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setThreshold [ARG double threshold=]>

--- Incoming ---
[u'cv.KAZE.getThreshold', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.KAZE.getThreshold []>

--- Incoming ---
[   u'cv.KAZE.setNOctaves',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'octaves', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setNOctaves [ARG int octaves=]>

--- Incoming ---
[u'cv.KAZE.getNOctaves', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.KAZE.getNOctaves []>

--- Incoming ---
[   u'cv.KAZE.setNOctaveLayers',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'octaveLayers', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setNOctaveLayers [ARG int octaveLayers=]>

--- Incoming ---
[u'cv.KAZE.getNOctaveLayers', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.KAZE.getNOctaveLayers []>

--- Incoming ---
[   u'cv.KAZE.setDiffusivity',
    u'void',
    ['/V', '/PV'],
    [[u'KAZE_DiffusivityType', u'diff', u'', []]],
    u'void']
ok: FUNC <void cv.KAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>

--- Incoming ---
[   u'cv.KAZE.getDiffusivity',
    u'KAZE_DiffusivityType',
    ['/C', '/V', '/PV'],
    [],
    u'KAZE::DiffusivityType']
ok: FUNC <KAZE_DiffusivityType cv.KAZE.getDiffusivity []>

--- Incoming ---
[u'cv.KAZE.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.KAZE.getDefaultName []>

--- Incoming ---
[u'class cv.AKAZE', u': cv::Feature2D', [], [], None]
ok: class CLASS cv::.AKAZE : Feature2D, name: AKAZE, base: Feature2D

--- Incoming ---
[   u'enum cv.AKAZE.DescriptorType',
    '',
    [],
    [   [u'const cv.AKAZE.DESCRIPTOR_KAZE_UPRIGHT', u'2', [], [], None, ''],
        [u'const cv.AKAZE.DESCRIPTOR_KAZE', u'3', [], [], None, ''],
        [u'const cv.AKAZE.DESCRIPTOR_MLDB_UPRIGHT', u'4', [], [], None, ''],
        [u'const cv.AKAZE.DESCRIPTOR_MLDB', u'5', [], [], None, '']],
    None]
ok: CONST DESCRIPTOR_KAZE_UPRIGHT=2
ok: CONST DESCRIPTOR_KAZE=3
ok: CONST DESCRIPTOR_MLDB_UPRIGHT=4
ok: CONST DESCRIPTOR_MLDB=5

--- Incoming ---
[   u'cv.AKAZE.create',
    u'Ptr_AKAZE',
    ['/S'],
    [   [   u'AKAZE_DescriptorType',
            u'descriptor_type',
            u'AKAZE::DESCRIPTOR_MLDB',
            []],
        [u'int', u'descriptor_size', u'0', []],
        [u'int', u'descriptor_channels', u'3', []],
        [u'float', u'threshold', u'0.001f', []],
        [u'int', u'nOctaves', u'4', []],
        [u'int', u'nOctaveLayers', u'4', []],
        [u'KAZE_DiffusivityType', u'diffusivity', u'KAZE::DIFF_PM_G2', []]],
    u'Ptr<AKAZE>']
ok: FUNC <Ptr_AKAZE cv.AKAZE.create [ARG AKAZE_DescriptorType descriptor_type=AKAZE::DESCRIPTOR_MLDB, ARG int descriptor_size=0, ARG int descriptor_channels=3, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>

--- Incoming ---
[   u'cv.AKAZE.setDescriptorType',
    u'void',
    ['/V', '/PV'],
    [[u'AKAZE_DescriptorType', u'dtype', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setDescriptorType [ARG AKAZE_DescriptorType dtype=]>

--- Incoming ---
[   u'cv.AKAZE.getDescriptorType',
    u'AKAZE_DescriptorType',
    ['/C', '/V', '/PV'],
    [],
    u'AKAZE::DescriptorType']
ok: FUNC <AKAZE_DescriptorType cv.AKAZE.getDescriptorType []>

--- Incoming ---
[   u'cv.AKAZE.setDescriptorSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'dsize', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setDescriptorSize [ARG int dsize=]>

--- Incoming ---
[u'cv.AKAZE.getDescriptorSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AKAZE.getDescriptorSize []>

--- Incoming ---
[   u'cv.AKAZE.setDescriptorChannels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'dch', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setDescriptorChannels [ARG int dch=]>

--- Incoming ---
[u'cv.AKAZE.getDescriptorChannels', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AKAZE.getDescriptorChannels []>

--- Incoming ---
[   u'cv.AKAZE.setThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setThreshold [ARG double threshold=]>

--- Incoming ---
[u'cv.AKAZE.getThreshold', u'double', ['/C', '/V', '/PV'], [], u'double']
ok: FUNC <double cv.AKAZE.getThreshold []>

--- Incoming ---
[   u'cv.AKAZE.setNOctaves',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'octaves', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setNOctaves [ARG int octaves=]>

--- Incoming ---
[u'cv.AKAZE.getNOctaves', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AKAZE.getNOctaves []>

--- Incoming ---
[   u'cv.AKAZE.setNOctaveLayers',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'octaveLayers', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setNOctaveLayers [ARG int octaveLayers=]>

--- Incoming ---
[u'cv.AKAZE.getNOctaveLayers', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.AKAZE.getNOctaveLayers []>

--- Incoming ---
[   u'cv.AKAZE.setDiffusivity',
    u'void',
    ['/V', '/PV'],
    [[u'KAZE_DiffusivityType', u'diff', u'', []]],
    u'void']
ok: FUNC <void cv.AKAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>

--- Incoming ---
[   u'cv.AKAZE.getDiffusivity',
    u'KAZE_DiffusivityType',
    ['/C', '/V', '/PV'],
    [],
    u'KAZE::DiffusivityType']
ok: FUNC <KAZE_DiffusivityType cv.AKAZE.getDiffusivity []>

--- Incoming ---
[u'cv.AKAZE.getDefaultName', u'String', ['/C', '/V'], [], u'String']
ok: FUNC <String cv.AKAZE.getDefaultName []>

--- Incoming ---
[u'class cv.DescriptorMatcher', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.DescriptorMatcher : Algorithm, name: DescriptorMatcher, base: Algorithm

--- Incoming ---
[   u'enum cv.DescriptorMatcher.MatcherType',
    '',
    [],
    [   [u'const cv.DescriptorMatcher.FLANNBASED', u'1', [], [], None, ''],
        [u'const cv.DescriptorMatcher.BRUTEFORCE', u'2', [], [], None, ''],
        [u'const cv.DescriptorMatcher.BRUTEFORCE_L1', u'3', [], [], None, ''],
        [   u'const cv.DescriptorMatcher.BRUTEFORCE_HAMMING',
            u'4',
            [],
            [],
            None,
            ''],
        [   u'const cv.DescriptorMatcher.BRUTEFORCE_HAMMINGLUT',
            u'5',
            [],
            [],
            None,
            ''],
        [   u'const cv.DescriptorMatcher.BRUTEFORCE_SL2',
            u'6',
            [],
            [],
            None,
            '']],
    None]
ok: CONST FLANNBASED=1
ok: CONST BRUTEFORCE=2
ok: CONST BRUTEFORCE_L1=3
ok: CONST BRUTEFORCE_HAMMING=4
ok: CONST BRUTEFORCE_HAMMINGLUT=5
ok: CONST BRUTEFORCE_SL2=6

--- Incoming ---
[   u'cv.DescriptorMatcher.add',
    u'void',
    ['/V'],
    [['vector_Mat', u'descriptors', '', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.add [ARG vector_Mat descriptors=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.getTrainDescriptors',
    u'vector_Mat',
    ['/C'],
    [],
    u'std::vector<Mat>']
ok: FUNC <vector_Mat cv.DescriptorMatcher.getTrainDescriptors []>

--- Incoming ---
[u'cv.DescriptorMatcher.clear', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.DescriptorMatcher.clear []>

--- Incoming ---
[u'cv.DescriptorMatcher.empty', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.DescriptorMatcher.empty []>

--- Incoming ---
[   u'cv.DescriptorMatcher.isMaskSupported',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.DescriptorMatcher.isMaskSupported []>

--- Incoming ---
[u'cv.DescriptorMatcher.train', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.DescriptorMatcher.train []>

--- Incoming ---
[   u'cv.DescriptorMatcher.match',
    u'void',
    ['/C'],
    [   ['Mat', u'queryDescriptors', '', []],
        ['Mat', u'trainDescriptors', '', []],
        [u'vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        ['Mat', u'mask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_DMatch matches=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.DescriptorMatcher.knnMatch',
    u'void',
    ['/C'],
    [   ['Mat', u'queryDescriptors', '', []],
        ['Mat', u'trainDescriptors', '', []],
        [u'vector_vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        [u'int', u'k', u'', []],
        ['Mat', u'mask', u'Mat()', []],
        [u'bool', u'compactResult', u'false', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG Mat mask=Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   u'cv.DescriptorMatcher.radiusMatch',
    u'void',
    ['/C'],
    [   ['Mat', u'queryDescriptors', '', []],
        ['Mat', u'trainDescriptors', '', []],
        [u'vector_vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        [u'float', u'maxDistance', u'', []],
        ['Mat', u'mask', u'Mat()', []],
        [u'bool', u'compactResult', u'false', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG Mat mask=Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   u'cv.DescriptorMatcher.match',
    u'void',
    [],
    [   ['Mat', u'queryDescriptors', '', []],
        [u'vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        ['vector_Mat', u'masks', u'vector_Mat()', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG vector_DMatch matches=, ARG vector_Mat masks=vector_Mat()]>

--- Incoming ---
[   u'cv.DescriptorMatcher.knnMatch',
    u'void',
    [],
    [   ['Mat', u'queryDescriptors', '', []],
        [u'vector_vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        [u'int', u'k', u'', []],
        ['vector_Mat', u'masks', u'vector_Mat()', []],
        [u'bool', u'compactResult', u'false', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   u'cv.DescriptorMatcher.radiusMatch',
    u'void',
    [],
    [   ['Mat', u'queryDescriptors', '', []],
        [u'vector_vector_DMatch', u'matches', u'', ['/O', '/Ref']],
        [u'float', u'maxDistance', u'', []],
        ['vector_Mat', u'masks', u'vector_Mat()', []],
        [u'bool', u'compactResult', u'false', []]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>

--- Incoming ---
[   u'cv.DescriptorMatcher.write',
    u'void',
    ['/C'],
    [[u'String', u'fileName', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.write [ARG String fileName=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.read',
    u'void',
    [],
    [[u'String', u'fileName', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.read [ARG String fileName=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.read',
    u'void',
    ['/V'],
    [[u'FileNode', 'arg1', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.read [ARG FileNode arg1=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.clone',
    u'Ptr_DescriptorMatcher',
    ['/C', '/V', '/PV'],
    [[u'bool', u'emptyTrainData', u'false', []]],
    u'Ptr<DescriptorMatcher>']
ok: FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.clone [ARG bool emptyTrainData=false]>

--- Incoming ---
[   u'cv.DescriptorMatcher.create',
    u'Ptr_DescriptorMatcher',
    ['/S'],
    [[u'String', u'descriptorMatcherType', u'', ['/C', '/Ref']]],
    u'Ptr<DescriptorMatcher>']
ok: FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG String descriptorMatcherType=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.create',
    u'Ptr_DescriptorMatcher',
    ['/S'],
    [[   u'DescriptorMatcher_MatcherType',
            u'matcherType',
            u'',
            ['/C', '/Ref']]],
    u'Ptr<DescriptorMatcher>']
ok: FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG DescriptorMatcher_MatcherType matcherType=]>

--- Incoming ---
[   u'cv.DescriptorMatcher.write',
    u'void',
    ['/C'],
    [   [u'Ptr_FileStorage', u'fs', u'', ['/C', '/Ref']],
        [u'String', u'name', u'String()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.DescriptorMatcher.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>

--- Incoming ---
[u'class cv.BFMatcher', u': cv::DescriptorMatcher', [], [], None]
ok: class CLASS cv::.BFMatcher : DescriptorMatcher, name: BFMatcher, base: DescriptorMatcher

--- Incoming ---
[   u'cv.BFMatcher.BFMatcher',
    '',
    [],
    [   [u'int', u'normType', u'NORM_L2', []],
        [u'bool', u'crossCheck', u'false', []]],
    None]
ok: FUNC < cv.BFMatcher.BFMatcher [ARG int normType=NORM_L2, ARG bool crossCheck=false]>

--- Incoming ---
[   u'cv.BFMatcher.create',
    u'Ptr_BFMatcher',
    ['/S'],
    [   [u'int', u'normType', u'NORM_L2', []],
        [u'bool', u'crossCheck', u'false', []]],
    u'Ptr<BFMatcher>']
ok: FUNC <Ptr_BFMatcher cv.BFMatcher.create [ARG int normType=NORM_L2, ARG bool crossCheck=false]>

--- Incoming ---
[u'class cv.FlannBasedMatcher', u': cv::DescriptorMatcher', [], [], None]
ok: class CLASS cv::.FlannBasedMatcher : DescriptorMatcher, name: FlannBasedMatcher, base: DescriptorMatcher

--- Incoming ---
[   u'cv.FlannBasedMatcher.FlannBasedMatcher',
    '',
    [],
    [   [   u'Ptr_flann_IndexParams',
            u'indexParams',
            u'makePtr<flann::KDTreeIndexParams>()',
            ['/C', '/Ref']],
        [   u'Ptr_flann_SearchParams',
            u'searchParams',
            u'makePtr<flann::SearchParams>()',
            ['/C', '/Ref']]],
    None]
ok: FUNC < cv.FlannBasedMatcher.FlannBasedMatcher [ARG Ptr_flann_IndexParams indexParams=makePtr<flann::KDTreeIndexParams>(), ARG Ptr_flann_SearchParams searchParams=makePtr<flann::SearchParams>()]>

--- Incoming ---
[   u'cv.FlannBasedMatcher.create',
    u'Ptr_FlannBasedMatcher',
    ['/S'],
    [],
    u'Ptr<FlannBasedMatcher>']
ok: FUNC <Ptr_FlannBasedMatcher cv.FlannBasedMatcher.create []>

--- Incoming ---
[   u'enum struct cv.DrawMatchesFlags',
    '',
    [],
    [   [u'const cv.DrawMatchesFlags.DEFAULT', u'0', [], [], None, ''],
        [   u'const cv.DrawMatchesFlags.DRAW_OVER_OUTIMG',
            u'1',
            [],
            [],
            None,
            ''],
        [   u'const cv.DrawMatchesFlags.NOT_DRAW_SINGLE_POINTS',
            u'2',
            [],
            [],
            None,
            ''],
        [   u'const cv.DrawMatchesFlags.DRAW_RICH_KEYPOINTS',
            u'4',
            [],
            [],
            None,
            '']],
    None]
class not found: CONST DEFAULT=0
ok: CONST DrawMatchesFlags_DEFAULT=0
class not found: CONST DRAW_OVER_OUTIMG=1
ok: CONST DrawMatchesFlags_DRAW_OVER_OUTIMG=1
class not found: CONST NOT_DRAW_SINGLE_POINTS=2
ok: CONST DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS=2
class not found: CONST DRAW_RICH_KEYPOINTS=4
ok: CONST DrawMatchesFlags_DRAW_RICH_KEYPOINTS=4

--- Incoming ---
[   u'cv.drawKeypoints',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'vector_KeyPoint', u'keypoints', u'', ['/C', '/Ref']],
        ['Mat', u'outImage', '', ['/IO']],
        [u'Scalar', u'color', u'Scalar::all(-1)', ['/C', '/Ref']],
        [u'DrawMatchesFlags', u'flags', u'DrawMatchesFlags::DEFAULT', []]],
    u'void']
ok: FUNC <void cv..drawKeypoints [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat outImage=, ARG Scalar color=Scalar::all(-1), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>

--- Incoming ---
[   u'cv.drawMatches',
    u'void',
    [],
    [   ['Mat', u'img1', '', []],
        [u'vector_KeyPoint', u'keypoints1', u'', ['/C', '/Ref']],
        ['Mat', u'img2', '', []],
        [u'vector_KeyPoint', u'keypoints2', u'', ['/C', '/Ref']],
        [u'vector_DMatch', u'matches1to2', u'', ['/C', '/Ref']],
        ['Mat', u'outImg', '', ['/IO']],
        [u'Scalar', u'matchColor', u'Scalar::all(-1)', ['/C', '/Ref']],
        [u'Scalar', u'singlePointColor', u'Scalar::all(-1)', ['/C', '/Ref']],
        [   u'vector_char',
            u'matchesMask',
            u'std::vector<char>()',
            ['/C', '/Ref']],
        [u'DrawMatchesFlags', u'flags', u'DrawMatchesFlags::DEFAULT', []]],
    u'void']
ok: FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_char matchesMask=std::vector<char>(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>

--- Incoming ---
[   u'cv.drawMatches',
    u'void',
    [u'=drawMatchesKnn'],
    [   ['Mat', u'img1', '', []],
        [u'vector_KeyPoint', u'keypoints1', u'', ['/C', '/Ref']],
        ['Mat', u'img2', '', []],
        [u'vector_KeyPoint', u'keypoints2', u'', ['/C', '/Ref']],
        [u'vector_vector_DMatch', u'matches1to2', u'', ['/C', '/Ref']],
        ['Mat', u'outImg', '', ['/IO']],
        [u'Scalar', u'matchColor', u'Scalar::all(-1)', ['/C', '/Ref']],
        [u'Scalar', u'singlePointColor', u'Scalar::all(-1)', ['/C', '/Ref']],
        [   u'vector_vector_char',
            u'matchesMask',
            u'std::vector<std::vector<char> >()',
            ['/C', '/Ref']],
        [u'DrawMatchesFlags', u'flags', u'DrawMatchesFlags::DEFAULT', []]],
    u'void']
ok: FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_vector_char matchesMask=std::vector<std::vector<char> >(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>

--- Incoming ---
[u'class cv.BOWTrainer', '', [], [], None]
ok: class CLASS cv::.BOWTrainer : , name: BOWTrainer, base: 

--- Incoming ---
[   u'cv.BOWTrainer.add',
    u'void',
    [],
    [[u'Mat', u'descriptors', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.BOWTrainer.add [ARG Mat descriptors=]>

--- Incoming ---
[   u'cv.BOWTrainer.getDescriptors',
    u'vector_Mat',
    ['/C'],
    [],
    u'std::vector<Mat>']
ok: FUNC <vector_Mat cv.BOWTrainer.getDescriptors []>

--- Incoming ---
[u'cv.BOWTrainer.descriptorsCount', u'int', ['/C'], [], u'int']
ok: FUNC <int cv.BOWTrainer.descriptorsCount []>

--- Incoming ---
[u'cv.BOWTrainer.clear', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.BOWTrainer.clear []>

--- Incoming ---
[u'cv.BOWTrainer.cluster', u'Mat', ['/C', '/V', '/PV'], [], u'Mat']
ok: FUNC <Mat cv.BOWTrainer.cluster []>

--- Incoming ---
[   u'cv.BOWTrainer.cluster',
    u'Mat',
    ['/C', '/V', '/PV'],
    [[u'Mat', u'descriptors', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.BOWTrainer.cluster [ARG Mat descriptors=]>

--- Incoming ---
[u'class cv.BOWKMeansTrainer', u': cv::BOWTrainer', [], [], None]
ok: class CLASS cv::.BOWKMeansTrainer : BOWTrainer, name: BOWKMeansTrainer, base: BOWTrainer

--- Incoming ---
[   u'cv.BOWKMeansTrainer.BOWKMeansTrainer',
    '',
    [],
    [   [u'int', u'clusterCount', u'', []],
        [u'TermCriteria', u'termcrit', u'TermCriteria()', ['/C', '/Ref']],
        [u'int', u'attempts', u'3', []],
        [u'int', u'flags', u'KMEANS_PP_CENTERS', []]],
    None]
ok: FUNC < cv.BOWKMeansTrainer.BOWKMeansTrainer [ARG int clusterCount=, ARG TermCriteria termcrit=TermCriteria(), ARG int attempts=3, ARG int flags=KMEANS_PP_CENTERS]>

--- Incoming ---
[u'cv.BOWKMeansTrainer.cluster', u'Mat', ['/C', '/V'], [], u'Mat']
ok: FUNC <Mat cv.BOWKMeansTrainer.cluster []>

--- Incoming ---
[   u'cv.BOWKMeansTrainer.cluster',
    u'Mat',
    ['/C', '/V'],
    [[u'Mat', u'descriptors', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.BOWKMeansTrainer.cluster [ARG Mat descriptors=]>

--- Incoming ---
[u'class cv.BOWImgDescriptorExtractor', '', [], [], None]
ok: class CLASS cv::.BOWImgDescriptorExtractor : , name: BOWImgDescriptorExtractor, base: 

--- Incoming ---
[   u'cv.BOWImgDescriptorExtractor.BOWImgDescriptorExtractor',
    '',
    [],
    [   [u'Ptr_DescriptorExtractor', u'dextractor', u'', ['/C', '/Ref']],
        [u'Ptr_DescriptorMatcher', u'dmatcher', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.BOWImgDescriptorExtractor.BOWImgDescriptorExtractor [ARG Ptr_DescriptorExtractor dextractor=, ARG Ptr_DescriptorMatcher dmatcher=]>

--- Incoming ---
[   u'cv.BOWImgDescriptorExtractor.setVocabulary',
    u'void',
    [],
    [[u'Mat', u'vocabulary', u'', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.BOWImgDescriptorExtractor.setVocabulary [ARG Mat vocabulary=]>

--- Incoming ---
[u'cv.BOWImgDescriptorExtractor.getVocabulary', u'Mat', ['/C'], [], u'Mat']
ok: FUNC <Mat cv.BOWImgDescriptorExtractor.getVocabulary []>

--- Incoming ---
[   u'cv.BOWImgDescriptorExtractor.compute2',
    u'void',
    [u'=compute'],
    [   [u'Mat', u'image', u'', ['/C', '/Ref']],
        [u'vector_KeyPoint', u'keypoints', u'', ['/Ref']],
        [u'Mat', u'imgDescriptor', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv.BOWImgDescriptorExtractor.compute2 [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat imgDescriptor=]>

--- Incoming ---
[u'cv.BOWImgDescriptorExtractor.descriptorSize', u'int', ['/C'], [], u'int']
ok: FUNC <int cv.BOWImgDescriptorExtractor.descriptorSize []>

--- Incoming ---
[u'cv.BOWImgDescriptorExtractor.descriptorType', u'int', ['/C'], [], u'int']
ok: FUNC <int cv.BOWImgDescriptorExtractor.descriptorType []>


===== Generating... =====
CLASS cv::.BOWImgDescriptorExtractor : 
FUNC < cv.BOWImgDescriptorExtractor.BOWImgDescriptorExtractor [ARG Ptr_DescriptorExtractor dextractor=, ARG Ptr_DescriptorMatcher dmatcher=]>
SKIP:cv::BOWImgDescriptorExtractor::BOWImgDescriptorExtractor(Ptr_DescriptorExtractor dextractor, Ptr_DescriptorMatcher dmatcher)	 due to ARG type Ptr_DescriptorExtractor/I
FUNC <Mat cv.BOWImgDescriptorExtractor.getVocabulary []>
java: Mat getVocabulary()
FUNC <int cv.BOWImgDescriptorExtractor.descriptorSize []>
java: int descriptorSize()
FUNC <int cv.BOWImgDescriptorExtractor.descriptorType []>
java: int descriptorType()
FUNC <void cv.BOWImgDescriptorExtractor.compute2 [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat imgDescriptor=]>
java: void compute(Mat image, MatOfKeyPoint keypoints, Mat imgDescriptor)
FUNC <void cv.BOWImgDescriptorExtractor.setVocabulary [ARG Mat vocabulary=]>
java: void setVocabulary(Mat vocabulary)
CLASS cv::.FastFeatureDetector : Feature2D
[CONST TYPE_5_8=0, CONST TYPE_7_12=1, CONST TYPE_9_16=2]
[CONST THRESHOLD=10000, CONST NONMAX_SUPPRESSION=10001, CONST FAST_N=10002]
FUNC <FastFeatureDetector_DetectorType cv.FastFeatureDetector.getType []>
java: int getType()
FUNC <Ptr_FastFeatureDetector cv.FastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG FastFeatureDetector_DetectorType type=FastFeatureDetector::TYPE_9_16]>
java: FastFeatureDetector create(int threshold, boolean nonmaxSuppression, int type)
java: FastFeatureDetector create(int threshold, boolean nonmaxSuppression)
java: FastFeatureDetector create(int threshold)
java: FastFeatureDetector create()
FUNC <String cv.FastFeatureDetector.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.FastFeatureDetector.getNonmaxSuppression []>
java: boolean getNonmaxSuppression()
FUNC <int cv.FastFeatureDetector.getThreshold []>
java: int getThreshold()
FUNC <void cv.FastFeatureDetector.setNonmaxSuppression [ARG bool f=]>
java: void setNonmaxSuppression(boolean f)
FUNC <void cv.FastFeatureDetector.setThreshold [ARG int threshold=]>
java: void setThreshold(int threshold)
FUNC <void cv.FastFeatureDetector.setType [ARG FastFeatureDetector_DetectorType type=]>
java: void setType(int type)
CLASS cv::.Feature2D : Algorithm
FUNC <String cv.Feature2D.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.Feature2D.empty []>
java: boolean empty()
FUNC <int cv.Feature2D.defaultNorm []>
java: int defaultNorm()
FUNC <int cv.Feature2D.descriptorSize []>
java: int descriptorSize()
FUNC <int cv.Feature2D.descriptorType []>
java: int descriptorType()
FUNC <void cv.Feature2D.compute [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=]>
java: void compute(Mat image, MatOfKeyPoint keypoints, Mat descriptors)
FUNC <void cv.Feature2D.compute [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat descriptors=]>
java: void compute(List<Mat> images, List<MatOfKeyPoint> keypoints, List<Mat> descriptors)
FUNC <void cv.Feature2D.detect [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat mask=Mat()]>
java: void detect(Mat image, MatOfKeyPoint keypoints, Mat mask)
java: void detect(Mat image, MatOfKeyPoint keypoints)
FUNC <void cv.Feature2D.detect [ARG vector_Mat images=, ARG vector_vector_KeyPoint keypoints=, ARG vector_Mat masks=vector_Mat()]>
java: void detect(List<Mat> images, List<MatOfKeyPoint> keypoints, List<Mat> masks)
java: void detect(List<Mat> images, List<MatOfKeyPoint> keypoints)
FUNC <void cv.Feature2D.detectAndCompute [ARG Mat image=, ARG Mat mask=, ARG vector_KeyPoint keypoints=, ARG Mat descriptors=, ARG bool useProvidedKeypoints=false]>
java: void detectAndCompute(Mat image, Mat mask, MatOfKeyPoint keypoints, Mat descriptors, boolean useProvidedKeypoints)
java: void detectAndCompute(Mat image, Mat mask, MatOfKeyPoint keypoints, Mat descriptors)
FUNC <void cv.Feature2D.read [ARG FileNode arg1=]>
SKIP:void cv::Feature2D::read(FileNode arg1)	 due to ARG type FileNode/I
FUNC <void cv.Feature2D.read [ARG String fileName=]>
java: void read(String fileName)
FUNC <void cv.Feature2D.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>
SKIP:void cv::Feature2D::write(Ptr_FileStorage fs, String name = String())	 due to ARG type Ptr_FileStorage/I
FUNC <void cv.Feature2D.write [ARG String fileName=]>
java: void write(String fileName)
CLASS cv::.BRISK : Feature2D
FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=, ARG int octaves=, ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin, MatOfInt indexChange)
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin)
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList, float dMax)
java: BRISK create(int thresh, int octaves, MatOfFloat radiusList, MatOfInt numberList)
FUNC <Ptr_BRISK cv.BRISK.create [ARG int thresh=30, ARG int octaves=3, ARG float patternScale=1.0f]>
java: BRISK create(int thresh, int octaves, float patternScale)
java: BRISK create(int thresh, int octaves)
java: BRISK create(int thresh)
java: BRISK create()
FUNC <Ptr_BRISK cv.BRISK.create [ARG vector_float radiusList=, ARG vector_int numberList=, ARG float dMax=5.85f, ARG float dMin=8.2f, ARG vector_int indexChange=std::vector<int>()]>
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin, MatOfInt indexChange)
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList, float dMax, float dMin)
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList, float dMax)
java: BRISK create(MatOfFloat radiusList, MatOfInt numberList)
FUNC <String cv.BRISK.getDefaultName []>
java: String getDefaultName()
FUNC <int cv.BRISK.getOctaves []>
java: int getOctaves()
FUNC <int cv.BRISK.getThreshold []>
java: int getThreshold()
FUNC <void cv.BRISK.setOctaves [ARG int octaves=]>
java: void setOctaves(int octaves)
FUNC <void cv.BRISK.setThreshold [ARG int threshold=]>
java: void setThreshold(int threshold)
CLASS cv::.SimpleBlobDetector : Feature2D
FUNC <Ptr_SimpleBlobDetector cv.SimpleBlobDetector.create [ARG SimpleBlobDetector_Params parameters=SimpleBlobDetector::Params()]>
java: SimpleBlobDetector create()
java: SimpleBlobDetector create()
FUNC <String cv.SimpleBlobDetector.getDefaultName []>
java: String getDefaultName()
CLASS cv::.AgastFeatureDetector : Feature2D
[CONST AGAST_5_8=0, CONST AGAST_7_12d=1, CONST AGAST_7_12s=2, CONST OAST_9_16=3]
[CONST THRESHOLD=10000, CONST NONMAX_SUPPRESSION=10001]
FUNC <AgastFeatureDetector_DetectorType cv.AgastFeatureDetector.getType []>
java: int getType()
FUNC <Ptr_AgastFeatureDetector cv.AgastFeatureDetector.create [ARG int threshold=10, ARG bool nonmaxSuppression=true, ARG AgastFeatureDetector_DetectorType type=AgastFeatureDetector::OAST_9_16]>
java: AgastFeatureDetector create(int threshold, boolean nonmaxSuppression, int type)
java: AgastFeatureDetector create(int threshold, boolean nonmaxSuppression)
java: AgastFeatureDetector create(int threshold)
java: AgastFeatureDetector create()
FUNC <String cv.AgastFeatureDetector.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.AgastFeatureDetector.getNonmaxSuppression []>
java: boolean getNonmaxSuppression()
FUNC <int cv.AgastFeatureDetector.getThreshold []>
java: int getThreshold()
FUNC <void cv.AgastFeatureDetector.setNonmaxSuppression [ARG bool f=]>
java: void setNonmaxSuppression(boolean f)
FUNC <void cv.AgastFeatureDetector.setThreshold [ARG int threshold=]>
java: void setThreshold(int threshold)
FUNC <void cv.AgastFeatureDetector.setType [ARG AgastFeatureDetector_DetectorType type=]>
java: void setType(int type)
CLASS cv::.GFTTDetector : Feature2D
FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=, ARG double qualityLevel=, ARG double minDistance=, ARG int blockSize=, ARG int gradiantSize=, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, int gradiantSize, boolean useHarrisDetector, double k)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, int gradiantSize, boolean useHarrisDetector)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, int gradiantSize)
FUNC <Ptr_GFTTDetector cv.GFTTDetector.create [ARG int maxCorners=1000, ARG double qualityLevel=0.01, ARG double minDistance=1, ARG int blockSize=3, ARG bool useHarrisDetector=false, ARG double k=0.04]>
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, boolean useHarrisDetector, double k)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize, boolean useHarrisDetector)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance, int blockSize)
java: GFTTDetector create(int maxCorners, double qualityLevel, double minDistance)
java: GFTTDetector create(int maxCorners, double qualityLevel)
java: GFTTDetector create(int maxCorners)
java: GFTTDetector create()
FUNC <String cv.GFTTDetector.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.GFTTDetector.getHarrisDetector []>
java: boolean getHarrisDetector()
FUNC <double cv.GFTTDetector.getK []>
java: double getK()
FUNC <double cv.GFTTDetector.getMinDistance []>
java: double getMinDistance()
FUNC <double cv.GFTTDetector.getQualityLevel []>
java: double getQualityLevel()
FUNC <int cv.GFTTDetector.getBlockSize []>
java: int getBlockSize()
FUNC <int cv.GFTTDetector.getMaxFeatures []>
java: int getMaxFeatures()
FUNC <void cv.GFTTDetector.setBlockSize [ARG int blockSize=]>
java: void setBlockSize(int blockSize)
FUNC <void cv.GFTTDetector.setHarrisDetector [ARG bool val=]>
java: void setHarrisDetector(boolean val)
FUNC <void cv.GFTTDetector.setK [ARG double k=]>
java: void setK(double k)
FUNC <void cv.GFTTDetector.setMaxFeatures [ARG int maxFeatures=]>
java: void setMaxFeatures(int maxFeatures)
FUNC <void cv.GFTTDetector.setMinDistance [ARG double minDistance=]>
java: void setMinDistance(double minDistance)
FUNC <void cv.GFTTDetector.setQualityLevel [ARG double qlevel=]>
java: void setQualityLevel(double qlevel)
CLASS cv::.DescriptorMatcher : Algorithm
[CONST FLANNBASED=1, CONST BRUTEFORCE=2, CONST BRUTEFORCE_L1=3, CONST BRUTEFORCE_HAMMING=4, CONST BRUTEFORCE_HAMMINGLUT=5, CONST BRUTEFORCE_SL2=6]
FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.clone [ARG bool emptyTrainData=false]>
java: DescriptorMatcher clone(boolean emptyTrainData)
java: DescriptorMatcher clone()
FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG DescriptorMatcher_MatcherType matcherType=]>
java: DescriptorMatcher create(int matcherType)
FUNC <Ptr_DescriptorMatcher cv.DescriptorMatcher.create [ARG String descriptorMatcherType=]>
java: DescriptorMatcher create(String descriptorMatcherType)
FUNC <bool cv.DescriptorMatcher.empty []>
java: boolean empty()
FUNC <bool cv.DescriptorMatcher.isMaskSupported []>
java: boolean isMaskSupported()
FUNC <vector_Mat cv.DescriptorMatcher.getTrainDescriptors []>
java: List<Mat> getTrainDescriptors()
FUNC <void cv.DescriptorMatcher.add [ARG vector_Mat descriptors=]>
java: void add(List<Mat> descriptors)
FUNC <void cv.DescriptorMatcher.clear []>
java: void clear()
FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG Mat mask=Mat(), ARG bool compactResult=false]>
java: void knnMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, int k, Mat mask, boolean compactResult)
java: void knnMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, int k, Mat mask)
java: void knnMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, int k)
FUNC <void cv.DescriptorMatcher.knnMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG int k=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>
java: void knnMatch(Mat queryDescriptors, List<MatOfDMatch> matches, int k, List<Mat> masks, boolean compactResult)
java: void knnMatch(Mat queryDescriptors, List<MatOfDMatch> matches, int k, List<Mat> masks)
java: void knnMatch(Mat queryDescriptors, List<MatOfDMatch> matches, int k)
FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_DMatch matches=, ARG Mat mask=Mat()]>
java: void match(Mat queryDescriptors, Mat trainDescriptors, MatOfDMatch matches, Mat mask)
java: void match(Mat queryDescriptors, Mat trainDescriptors, MatOfDMatch matches)
FUNC <void cv.DescriptorMatcher.match [ARG Mat queryDescriptors=, ARG vector_DMatch matches=, ARG vector_Mat masks=vector_Mat()]>
java: void match(Mat queryDescriptors, MatOfDMatch matches, List<Mat> masks)
java: void match(Mat queryDescriptors, MatOfDMatch matches)
FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG Mat trainDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG Mat mask=Mat(), ARG bool compactResult=false]>
java: void radiusMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, float maxDistance, Mat mask, boolean compactResult)
java: void radiusMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, float maxDistance, Mat mask)
java: void radiusMatch(Mat queryDescriptors, Mat trainDescriptors, List<MatOfDMatch> matches, float maxDistance)
FUNC <void cv.DescriptorMatcher.radiusMatch [ARG Mat queryDescriptors=, ARG vector_vector_DMatch matches=, ARG float maxDistance=, ARG vector_Mat masks=vector_Mat(), ARG bool compactResult=false]>
java: void radiusMatch(Mat queryDescriptors, List<MatOfDMatch> matches, float maxDistance, List<Mat> masks, boolean compactResult)
java: void radiusMatch(Mat queryDescriptors, List<MatOfDMatch> matches, float maxDistance, List<Mat> masks)
java: void radiusMatch(Mat queryDescriptors, List<MatOfDMatch> matches, float maxDistance)
FUNC <void cv.DescriptorMatcher.read [ARG FileNode arg1=]>
SKIP:void cv::DescriptorMatcher::read(FileNode arg1)	 due to ARG type FileNode/I
FUNC <void cv.DescriptorMatcher.read [ARG String fileName=]>
java: void read(String fileName)
FUNC <void cv.DescriptorMatcher.train []>
java: void train()
FUNC <void cv.DescriptorMatcher.write [ARG Ptr_FileStorage fs=, ARG String name=String()]>
SKIP:void cv::DescriptorMatcher::write(Ptr_FileStorage fs, String name = String())	 due to ARG type Ptr_FileStorage/I
FUNC <void cv.DescriptorMatcher.write [ARG String fileName=]>
java: void write(String fileName)
CLASS cv::.KAZE : Feature2D
[CONST DIFF_PM_G1=0, CONST DIFF_PM_G2=1, CONST DIFF_WEICKERT=2, CONST DIFF_CHARBONNIER=3]
FUNC <KAZE_DiffusivityType cv.KAZE.getDiffusivity []>
java: int getDiffusivity()
FUNC <Ptr_KAZE cv.KAZE.create [ARG bool extended=false, ARG bool upright=false, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>
java: KAZE create(boolean extended, boolean upright, float threshold, int nOctaves, int nOctaveLayers, int diffusivity)
java: KAZE create(boolean extended, boolean upright, float threshold, int nOctaves, int nOctaveLayers)
java: KAZE create(boolean extended, boolean upright, float threshold, int nOctaves)
java: KAZE create(boolean extended, boolean upright, float threshold)
java: KAZE create(boolean extended, boolean upright)
java: KAZE create(boolean extended)
java: KAZE create()
FUNC <String cv.KAZE.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.KAZE.getExtended []>
java: boolean getExtended()
FUNC <bool cv.KAZE.getUpright []>
java: boolean getUpright()
FUNC <double cv.KAZE.getThreshold []>
java: double getThreshold()
FUNC <int cv.KAZE.getNOctaveLayers []>
java: int getNOctaveLayers()
FUNC <int cv.KAZE.getNOctaves []>
java: int getNOctaves()
FUNC <void cv.KAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>
java: void setDiffusivity(int diff)
FUNC <void cv.KAZE.setExtended [ARG bool extended=]>
java: void setExtended(boolean extended)
FUNC <void cv.KAZE.setNOctaveLayers [ARG int octaveLayers=]>
java: void setNOctaveLayers(int octaveLayers)
FUNC <void cv.KAZE.setNOctaves [ARG int octaves=]>
java: void setNOctaves(int octaves)
FUNC <void cv.KAZE.setThreshold [ARG double threshold=]>
java: void setThreshold(double threshold)
FUNC <void cv.KAZE.setUpright [ARG bool upright=]>
java: void setUpright(boolean upright)
CLASS ::.Features2d : 
[CONST DrawMatchesFlags_DEFAULT=0, CONST DrawMatchesFlags_DRAW_OVER_OUTIMG=1, CONST DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS=2, CONST DrawMatchesFlags_DRAW_RICH_KEYPOINTS=4]
FUNC <void cv..drawKeypoints [ARG Mat image=, ARG vector_KeyPoint keypoints=, ARG Mat outImage=, ARG Scalar color=Scalar::all(-1), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>
java: void drawKeypoints(Mat image, MatOfKeyPoint keypoints, Mat outImage, Scalar color, int flags)
java: void drawKeypoints(Mat image, MatOfKeyPoint keypoints, Mat outImage, Scalar color)
java: void drawKeypoints(Mat image, MatOfKeyPoint keypoints, Mat outImage)
FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_char matchesMask=std::vector<char>(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, MatOfByte matchesMask, int flags)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, MatOfByte matchesMask)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg, Scalar matchColor)
java: void drawMatches(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, MatOfDMatch matches1to2, Mat outImg)
FUNC <void cv..drawMatches [ARG Mat img1=, ARG vector_KeyPoint keypoints1=, ARG Mat img2=, ARG vector_KeyPoint keypoints2=, ARG vector_vector_DMatch matches1to2=, ARG Mat outImg=, ARG Scalar matchColor=Scalar::all(-1), ARG Scalar singlePointColor=Scalar::all(-1), ARG vector_vector_char matchesMask=std::vector<std::vector<char> >(), ARG DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT]>
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, List<MatOfByte> matchesMask, int flags)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor, List<MatOfByte> matchesMask)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor, Scalar singlePointColor)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg, Scalar matchColor)
java: void drawMatchesKnn(Mat img1, MatOfKeyPoint keypoints1, Mat img2, MatOfKeyPoint keypoints2, List<MatOfDMatch> matches1to2, Mat outImg)
CLASS cv::.AKAZE : Feature2D
[CONST DESCRIPTOR_KAZE_UPRIGHT=2, CONST DESCRIPTOR_KAZE=3, CONST DESCRIPTOR_MLDB_UPRIGHT=4, CONST DESCRIPTOR_MLDB=5]
FUNC <AKAZE_DescriptorType cv.AKAZE.getDescriptorType []>
java: int getDescriptorType()
FUNC <KAZE_DiffusivityType cv.AKAZE.getDiffusivity []>
java: int getDiffusivity()
FUNC <Ptr_AKAZE cv.AKAZE.create [ARG AKAZE_DescriptorType descriptor_type=AKAZE::DESCRIPTOR_MLDB, ARG int descriptor_size=0, ARG int descriptor_channels=3, ARG float threshold=0.001f, ARG int nOctaves=4, ARG int nOctaveLayers=4, ARG KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2]>
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold, int nOctaves, int nOctaveLayers, int diffusivity)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold, int nOctaves, int nOctaveLayers)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold, int nOctaves)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold)
java: AKAZE create(int descriptor_type, int descriptor_size, int descriptor_channels)
java: AKAZE create(int descriptor_type, int descriptor_size)
java: AKAZE create(int descriptor_type)
java: AKAZE create()
FUNC <String cv.AKAZE.getDefaultName []>
java: String getDefaultName()
FUNC <double cv.AKAZE.getThreshold []>
java: double getThreshold()
FUNC <int cv.AKAZE.getDescriptorChannels []>
java: int getDescriptorChannels()
FUNC <int cv.AKAZE.getDescriptorSize []>
java: int getDescriptorSize()
FUNC <int cv.AKAZE.getNOctaveLayers []>
java: int getNOctaveLayers()
FUNC <int cv.AKAZE.getNOctaves []>
java: int getNOctaves()
FUNC <void cv.AKAZE.setDescriptorChannels [ARG int dch=]>
java: void setDescriptorChannels(int dch)
FUNC <void cv.AKAZE.setDescriptorSize [ARG int dsize=]>
java: void setDescriptorSize(int dsize)
FUNC <void cv.AKAZE.setDescriptorType [ARG AKAZE_DescriptorType dtype=]>
java: void setDescriptorType(int dtype)
FUNC <void cv.AKAZE.setDiffusivity [ARG KAZE_DiffusivityType diff=]>
java: void setDiffusivity(int diff)
FUNC <void cv.AKAZE.setNOctaveLayers [ARG int octaveLayers=]>
java: void setNOctaveLayers(int octaveLayers)
FUNC <void cv.AKAZE.setNOctaves [ARG int octaves=]>
java: void setNOctaves(int octaves)
FUNC <void cv.AKAZE.setThreshold [ARG double threshold=]>
java: void setThreshold(double threshold)
CLASS cv::SimpleBlobDetector.Params : 
FUNC < cv.SimpleBlobDetector.Params.Params []>
java:  Params()
FUNC <float cv.SimpleBlobDetector.Params.get_thresholdStep []>
java: float get_thresholdStep()
FUNC <void cv.SimpleBlobDetector.Params.set_thresholdStep [ARG float thresholdStep=]>
java: void set_thresholdStep(float thresholdStep)
FUNC <float cv.SimpleBlobDetector.Params.get_minThreshold []>
java: float get_minThreshold()
FUNC <void cv.SimpleBlobDetector.Params.set_minThreshold [ARG float minThreshold=]>
java: void set_minThreshold(float minThreshold)
FUNC <float cv.SimpleBlobDetector.Params.get_maxThreshold []>
java: float get_maxThreshold()
FUNC <void cv.SimpleBlobDetector.Params.set_maxThreshold [ARG float maxThreshold=]>
java: void set_maxThreshold(float maxThreshold)
FUNC <size_t cv.SimpleBlobDetector.Params.get_minRepeatability []>
java: long get_minRepeatability()
FUNC <void cv.SimpleBlobDetector.Params.set_minRepeatability [ARG size_t minRepeatability=]>
java: void set_minRepeatability(long minRepeatability)
FUNC <float cv.SimpleBlobDetector.Params.get_minDistBetweenBlobs []>
java: float get_minDistBetweenBlobs()
FUNC <void cv.SimpleBlobDetector.Params.set_minDistBetweenBlobs [ARG float minDistBetweenBlobs=]>
java: void set_minDistBetweenBlobs(float minDistBetweenBlobs)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByColor []>
java: boolean get_filterByColor()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByColor [ARG bool filterByColor=]>
java: void set_filterByColor(boolean filterByColor)
FUNC <uchar cv.SimpleBlobDetector.Params.get_blobColor []>
SKIP:uchar Params::blobColor	 due to RET type uchar
FUNC <void cv.SimpleBlobDetector.Params.set_blobColor [ARG uchar blobColor=]>
SKIP:void Params::blobColor	 due to ARG type uchar/I
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByArea []>
java: boolean get_filterByArea()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByArea [ARG bool filterByArea=]>
java: void set_filterByArea(boolean filterByArea)
FUNC <float cv.SimpleBlobDetector.Params.get_minArea []>
java: float get_minArea()
FUNC <void cv.SimpleBlobDetector.Params.set_minArea [ARG float minArea=]>
java: void set_minArea(float minArea)
FUNC <float cv.SimpleBlobDetector.Params.get_maxArea []>
java: float get_maxArea()
FUNC <void cv.SimpleBlobDetector.Params.set_maxArea [ARG float maxArea=]>
java: void set_maxArea(float maxArea)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByCircularity []>
java: boolean get_filterByCircularity()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByCircularity [ARG bool filterByCircularity=]>
java: void set_filterByCircularity(boolean filterByCircularity)
FUNC <float cv.SimpleBlobDetector.Params.get_minCircularity []>
java: float get_minCircularity()
FUNC <void cv.SimpleBlobDetector.Params.set_minCircularity [ARG float minCircularity=]>
java: void set_minCircularity(float minCircularity)
FUNC <float cv.SimpleBlobDetector.Params.get_maxCircularity []>
java: float get_maxCircularity()
FUNC <void cv.SimpleBlobDetector.Params.set_maxCircularity [ARG float maxCircularity=]>
java: void set_maxCircularity(float maxCircularity)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByInertia []>
java: boolean get_filterByInertia()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByInertia [ARG bool filterByInertia=]>
java: void set_filterByInertia(boolean filterByInertia)
FUNC <float cv.SimpleBlobDetector.Params.get_minInertiaRatio []>
java: float get_minInertiaRatio()
FUNC <void cv.SimpleBlobDetector.Params.set_minInertiaRatio [ARG float minInertiaRatio=]>
java: void set_minInertiaRatio(float minInertiaRatio)
FUNC <float cv.SimpleBlobDetector.Params.get_maxInertiaRatio []>
java: float get_maxInertiaRatio()
FUNC <void cv.SimpleBlobDetector.Params.set_maxInertiaRatio [ARG float maxInertiaRatio=]>
java: void set_maxInertiaRatio(float maxInertiaRatio)
FUNC <bool cv.SimpleBlobDetector.Params.get_filterByConvexity []>
java: boolean get_filterByConvexity()
FUNC <void cv.SimpleBlobDetector.Params.set_filterByConvexity [ARG bool filterByConvexity=]>
java: void set_filterByConvexity(boolean filterByConvexity)
FUNC <float cv.SimpleBlobDetector.Params.get_minConvexity []>
java: float get_minConvexity()
FUNC <void cv.SimpleBlobDetector.Params.set_minConvexity [ARG float minConvexity=]>
java: void set_minConvexity(float minConvexity)
FUNC <float cv.SimpleBlobDetector.Params.get_maxConvexity []>
java: float get_maxConvexity()
FUNC <void cv.SimpleBlobDetector.Params.set_maxConvexity [ARG float maxConvexity=]>
java: void set_maxConvexity(float maxConvexity)
CLASS cv::.BFMatcher : DescriptorMatcher
FUNC < cv.BFMatcher.BFMatcher [ARG int normType=NORM_L2, ARG bool crossCheck=false]>
java:  BFMatcher(int normType, boolean crossCheck)
java:  BFMatcher(int normType)
java:  BFMatcher()
FUNC <Ptr_BFMatcher cv.BFMatcher.create [ARG int normType=NORM_L2, ARG bool crossCheck=false]>
java: BFMatcher create(int normType, boolean crossCheck)
java: BFMatcher create(int normType)
java: BFMatcher create()
CLASS cv::.BOWTrainer : 
FUNC <Mat cv.BOWTrainer.cluster [ARG Mat descriptors=]>
java: Mat cluster(Mat descriptors)
FUNC <Mat cv.BOWTrainer.cluster []>
java: Mat cluster()
FUNC <int cv.BOWTrainer.descriptorsCount []>
java: int descriptorsCount()
FUNC <vector_Mat cv.BOWTrainer.getDescriptors []>
java: List<Mat> getDescriptors()
FUNC <void cv.BOWTrainer.add [ARG Mat descriptors=]>
java: void add(Mat descriptors)
FUNC <void cv.BOWTrainer.clear []>
java: void clear()
CLASS cv::.ORB : Feature2D
[CONST HARRIS_SCORE=0, CONST FAST_SCORE=1]
FUNC <ORB_ScoreType cv.ORB.getScoreType []>
java: int getScoreType()
FUNC <Ptr_ORB cv.ORB.create [ARG int nfeatures=500, ARG float scaleFactor=1.2f, ARG int nlevels=8, ARG int edgeThreshold=31, ARG int firstLevel=0, ARG int WTA_K=2, ARG ORB_ScoreType scoreType=ORB::HARRIS_SCORE, ARG int patchSize=31, ARG int fastThreshold=20]>
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K, int scoreType, int patchSize, int fastThreshold)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K, int scoreType, int patchSize)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K, int scoreType)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel, int WTA_K)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold, int firstLevel)
java: ORB create(int nfeatures, float scaleFactor, int nlevels, int edgeThreshold)
java: ORB create(int nfeatures, float scaleFactor, int nlevels)
java: ORB create(int nfeatures, float scaleFactor)
java: ORB create(int nfeatures)
java: ORB create()
FUNC <String cv.ORB.getDefaultName []>
java: String getDefaultName()
FUNC <double cv.ORB.getScaleFactor []>
java: double getScaleFactor()
FUNC <int cv.ORB.getEdgeThreshold []>
java: int getEdgeThreshold()
FUNC <int cv.ORB.getFastThreshold []>
java: int getFastThreshold()
FUNC <int cv.ORB.getFirstLevel []>
java: int getFirstLevel()
FUNC <int cv.ORB.getMaxFeatures []>
java: int getMaxFeatures()
FUNC <int cv.ORB.getNLevels []>
java: int getNLevels()
FUNC <int cv.ORB.getPatchSize []>
java: int getPatchSize()
FUNC <int cv.ORB.getWTA_K []>
java: int getWTA_K()
FUNC <void cv.ORB.setEdgeThreshold [ARG int edgeThreshold=]>
java: void setEdgeThreshold(int edgeThreshold)
FUNC <void cv.ORB.setFastThreshold [ARG int fastThreshold=]>
java: void setFastThreshold(int fastThreshold)
FUNC <void cv.ORB.setFirstLevel [ARG int firstLevel=]>
java: void setFirstLevel(int firstLevel)
FUNC <void cv.ORB.setMaxFeatures [ARG int maxFeatures=]>
java: void setMaxFeatures(int maxFeatures)
FUNC <void cv.ORB.setNLevels [ARG int nlevels=]>
java: void setNLevels(int nlevels)
FUNC <void cv.ORB.setPatchSize [ARG int patchSize=]>
java: void setPatchSize(int patchSize)
FUNC <void cv.ORB.setScaleFactor [ARG double scaleFactor=]>
java: void setScaleFactor(double scaleFactor)
FUNC <void cv.ORB.setScoreType [ARG ORB_ScoreType scoreType=]>
java: void setScoreType(int scoreType)
FUNC <void cv.ORB.setWTA_K [ARG int wta_k=]>
java: void setWTA_K(int wta_k)
CLASS cv::.MSER : Feature2D
FUNC <Ptr_MSER cv.MSER.create [ARG int _delta=5, ARG int _min_area=60, ARG int _max_area=14400, ARG double _max_variation=0.25, ARG double _min_diversity=.2, ARG int _max_evolution=200, ARG double _area_threshold=1.01, ARG double _min_margin=0.003, ARG int _edge_blur_size=5]>
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold, double _min_margin, int _edge_blur_size)
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold, double _min_margin)
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution, double _area_threshold)
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity, int _max_evolution)
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation, double _min_diversity)
java: MSER create(int _delta, int _min_area, int _max_area, double _max_variation)
java: MSER create(int _delta, int _min_area, int _max_area)
java: MSER create(int _delta, int _min_area)
java: MSER create(int _delta)
java: MSER create()
FUNC <String cv.MSER.getDefaultName []>
java: String getDefaultName()
FUNC <bool cv.MSER.getPass2Only []>
java: boolean getPass2Only()
FUNC <int cv.MSER.getDelta []>
java: int getDelta()
FUNC <int cv.MSER.getMaxArea []>
java: int getMaxArea()
FUNC <int cv.MSER.getMinArea []>
java: int getMinArea()
FUNC <void cv.MSER.detectRegions [ARG Mat image=, ARG vector_vector_Point msers=, ARG vector_Rect bboxes=]>
java: void detectRegions(Mat image, List<MatOfPoint> msers, MatOfRect bboxes)
FUNC <void cv.MSER.setDelta [ARG int delta=]>
java: void setDelta(int delta)
FUNC <void cv.MSER.setMaxArea [ARG int maxArea=]>
java: void setMaxArea(int maxArea)
FUNC <void cv.MSER.setMinArea [ARG int minArea=]>
java: void setMinArea(int minArea)
FUNC <void cv.MSER.setPass2Only [ARG bool f=]>
java: void setPass2Only(boolean f)
CLASS cv::.BOWKMeansTrainer : BOWTrainer
FUNC < cv.BOWKMeansTrainer.BOWKMeansTrainer [ARG int clusterCount=, ARG TermCriteria termcrit=TermCriteria(), ARG int attempts=3, ARG int flags=KMEANS_PP_CENTERS]>
java:  BOWKMeansTrainer(int clusterCount, TermCriteria termcrit, int attempts, int flags)
java:  BOWKMeansTrainer(int clusterCount, TermCriteria termcrit, int attempts)
java:  BOWKMeansTrainer(int clusterCount, TermCriteria termcrit)
java:  BOWKMeansTrainer(int clusterCount)
FUNC <Mat cv.BOWKMeansTrainer.cluster [ARG Mat descriptors=]>
java: Mat cluster(Mat descriptors)
FUNC <Mat cv.BOWKMeansTrainer.cluster []>
java: Mat cluster()
CLASS cv::.FlannBasedMatcher : DescriptorMatcher
FUNC < cv.FlannBasedMatcher.FlannBasedMatcher [ARG Ptr_flann_IndexParams indexParams=makePtr<flann::KDTreeIndexParams>(), ARG Ptr_flann_SearchParams searchParams=makePtr<flann::SearchParams>()]>
java:  FlannBasedMatcher()
java:  FlannBasedMatcher()
java:  FlannBasedMatcher()
FUNC <Ptr_FlannBasedMatcher cv.FlannBasedMatcher.create []>
java: FlannBasedMatcher create()

=== MODULE: imgcodecs (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs) ===


Files (4):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs/include/opencv2/imgcodecs/ios.h',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs_c.h',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs/include/opencv2/imgcodecs.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs.hpp']

Common headers (0):
[]
ok: class CLASS ::.Imgcodecs : , name: Imgcodecs, base: 


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs/include/opencv2/imgcodecs/ios.h =====
Namespaces: set([])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs/include/opencv2/imgcodecs/ios.h


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs_c.h =====
Namespaces: set([])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs_c.h


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs/include/opencv2/imgcodecs.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'enum cv.ImreadModes',
    '',
    [],
    [   [u'const cv.IMREAD_UNCHANGED', u'-1', [], [], None, ''],
        [u'const cv.IMREAD_GRAYSCALE', u'0', [], [], None, ''],
        [u'const cv.IMREAD_COLOR', u'1', [], [], None, ''],
        [u'const cv.IMREAD_ANYDEPTH', u'2', [], [], None, ''],
        [u'const cv.IMREAD_ANYCOLOR', u'4', [], [], None, ''],
        [u'const cv.IMREAD_LOAD_GDAL', u'8', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_GRAYSCALE_2', u'16', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_COLOR_2', u'17', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_GRAYSCALE_4', u'32', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_COLOR_4', u'33', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_GRAYSCALE_8', u'64', [], [], None, ''],
        [u'const cv.IMREAD_REDUCED_COLOR_8', u'65', [], [], None, ''],
        [u'const cv.IMREAD_IGNORE_ORIENTATION', u'128', [], [], None, '']],
    None]
ok: CONST IMREAD_UNCHANGED=-1
ok: CONST IMREAD_GRAYSCALE=0
ok: CONST IMREAD_COLOR=1
ok: CONST IMREAD_ANYDEPTH=2
ok: CONST IMREAD_ANYCOLOR=4
ok: CONST IMREAD_LOAD_GDAL=8
ok: CONST IMREAD_REDUCED_GRAYSCALE_2=16
ok: CONST IMREAD_REDUCED_COLOR_2=17
ok: CONST IMREAD_REDUCED_GRAYSCALE_4=32
ok: CONST IMREAD_REDUCED_COLOR_4=33
ok: CONST IMREAD_REDUCED_GRAYSCALE_8=64
ok: CONST IMREAD_REDUCED_COLOR_8=65
ok: CONST IMREAD_IGNORE_ORIENTATION=128

--- Incoming ---
[   u'enum cv.ImwriteFlags',
    '',
    [],
    [   [u'const cv.IMWRITE_JPEG_QUALITY', u'1', [], [], None, ''],
        [u'const cv.IMWRITE_JPEG_PROGRESSIVE', u'2', [], [], None, ''],
        [u'const cv.IMWRITE_JPEG_OPTIMIZE', u'3', [], [], None, ''],
        [u'const cv.IMWRITE_JPEG_RST_INTERVAL', u'4', [], [], None, ''],
        [u'const cv.IMWRITE_JPEG_LUMA_QUALITY', u'5', [], [], None, ''],
        [u'const cv.IMWRITE_JPEG_CHROMA_QUALITY', u'6', [], [], None, ''],
        [u'const cv.IMWRITE_PNG_COMPRESSION', u'16', [], [], None, ''],
        [u'const cv.IMWRITE_PNG_STRATEGY', u'17', [], [], None, ''],
        [u'const cv.IMWRITE_PNG_BILEVEL', u'18', [], [], None, ''],
        [u'const cv.IMWRITE_PXM_BINARY', u'32', [], [], None, ''],
        [u'const cv.IMWRITE_EXR_TYPE', u'(3 << 4) + 0', [], [], None, ''],
        [u'const cv.IMWRITE_WEBP_QUALITY', u'64', [], [], None, ''],
        [u'const cv.IMWRITE_PAM_TUPLETYPE', u'128', [], [], None, ''],
        [u'const cv.IMWRITE_TIFF_RESUNIT', u'256', [], [], None, ''],
        [u'const cv.IMWRITE_TIFF_XDPI', u'257', [], [], None, ''],
        [u'const cv.IMWRITE_TIFF_YDPI', u'258', [], [], None, ''],
        [u'const cv.IMWRITE_TIFF_COMPRESSION', u'259', [], [], None, ''],
        [   u'const cv.IMWRITE_JPEG2000_COMPRESSION_X1000',
            u'272',
            [],
            [],
            None,
            '']],
    None]
ok: CONST IMWRITE_JPEG_QUALITY=1
ok: CONST IMWRITE_JPEG_PROGRESSIVE=2
ok: CONST IMWRITE_JPEG_OPTIMIZE=3
ok: CONST IMWRITE_JPEG_RST_INTERVAL=4
ok: CONST IMWRITE_JPEG_LUMA_QUALITY=5
ok: CONST IMWRITE_JPEG_CHROMA_QUALITY=6
ok: CONST IMWRITE_PNG_COMPRESSION=16
ok: CONST IMWRITE_PNG_STRATEGY=17
ok: CONST IMWRITE_PNG_BILEVEL=18
ok: CONST IMWRITE_PXM_BINARY=32
ok: CONST IMWRITE_EXR_TYPE=(3 << 4) + 0
ok: CONST IMWRITE_WEBP_QUALITY=64
ok: CONST IMWRITE_PAM_TUPLETYPE=128
ok: CONST IMWRITE_TIFF_RESUNIT=256
ok: CONST IMWRITE_TIFF_XDPI=257
ok: CONST IMWRITE_TIFF_YDPI=258
ok: CONST IMWRITE_TIFF_COMPRESSION=259
ok: CONST IMWRITE_JPEG2000_COMPRESSION_X1000=272

--- Incoming ---
[   u'enum cv.ImwriteEXRTypeFlags',
    '',
    [],
    [   [u'const cv.IMWRITE_EXR_TYPE_HALF', u'1', [], [], None, ''],
        [u'const cv.IMWRITE_EXR_TYPE_FLOAT', u'2', [], [], None, '']],
    None]
ok: CONST IMWRITE_EXR_TYPE_HALF=1
ok: CONST IMWRITE_EXR_TYPE_FLOAT=2

--- Incoming ---
[   u'enum cv.ImwritePNGFlags',
    '',
    [],
    [   [u'const cv.IMWRITE_PNG_STRATEGY_DEFAULT', u'0', [], [], None, ''],
        [u'const cv.IMWRITE_PNG_STRATEGY_FILTERED', u'1', [], [], None, ''],
        [   u'const cv.IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY',
            u'2',
            [],
            [],
            None,
            ''],
        [u'const cv.IMWRITE_PNG_STRATEGY_RLE', u'3', [], [], None, ''],
        [u'const cv.IMWRITE_PNG_STRATEGY_FIXED', u'4', [], [], None, '']],
    None]
ok: CONST IMWRITE_PNG_STRATEGY_DEFAULT=0
ok: CONST IMWRITE_PNG_STRATEGY_FILTERED=1
ok: CONST IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY=2
ok: CONST IMWRITE_PNG_STRATEGY_RLE=3
ok: CONST IMWRITE_PNG_STRATEGY_FIXED=4

--- Incoming ---
[   u'enum cv.ImwritePAMFlags',
    '',
    [],
    [   [u'const cv.IMWRITE_PAM_FORMAT_NULL', u'0', [], [], None, ''],
        [   u'const cv.IMWRITE_PAM_FORMAT_BLACKANDWHITE',
            u'1',
            [],
            [],
            None,
            ''],
        [u'const cv.IMWRITE_PAM_FORMAT_GRAYSCALE', u'2', [], [], None, ''],
        [   u'const cv.IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA',
            u'3',
            [],
            [],
            None,
            ''],
        [u'const cv.IMWRITE_PAM_FORMAT_RGB', u'4', [], [], None, ''],
        [u'const cv.IMWRITE_PAM_FORMAT_RGB_ALPHA', u'5', [], [], None, '']],
    None]
ok: CONST IMWRITE_PAM_FORMAT_NULL=0
ok: CONST IMWRITE_PAM_FORMAT_BLACKANDWHITE=1
ok: CONST IMWRITE_PAM_FORMAT_GRAYSCALE=2
ok: CONST IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA=3
ok: CONST IMWRITE_PAM_FORMAT_RGB=4
ok: CONST IMWRITE_PAM_FORMAT_RGB_ALPHA=5

--- Incoming ---
[   u'cv.imread',
    u'Mat',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'flags', u'IMREAD_COLOR', []]],
    u'Mat']
ok: FUNC <Mat cv..imread [ARG String filename=, ARG int flags=IMREAD_COLOR]>

--- Incoming ---
[   u'cv.imreadmulti',
    u'bool',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'vector_Mat', u'mats', u'', ['/O', '/Ref']],
        [u'int', u'flags', u'IMREAD_ANYCOLOR', []]],
    u'bool']
ok: FUNC <bool cv..imreadmulti [ARG String filename=, ARG vector_Mat mats=, ARG int flags=IMREAD_ANYCOLOR]>

--- Incoming ---
[   u'cv.imwrite',
    u'bool',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        ['Mat', u'img', '', []],
        [u'vector_int', u'params', u'std::vector<int>()', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..imwrite [ARG String filename=, ARG Mat img=, ARG vector_int params=std::vector<int>()]>

--- Incoming ---
[   u'cv.imdecode',
    u'Mat',
    [],
    [['Mat', u'buf', '', []], [u'int', u'flags', u'', []]],
    u'Mat']
ok: FUNC <Mat cv..imdecode [ARG Mat buf=, ARG int flags=]>

--- Incoming ---
[   u'cv.imencode',
    u'bool',
    [],
    [   [u'String', u'ext', u'', ['/C', '/Ref']],
        ['Mat', u'img', '', []],
        [u'vector_uchar', u'buf', u'', ['/O', '/Ref']],
        [u'vector_int', u'params', u'std::vector<int>()', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..imencode [ARG String ext=, ARG Mat img=, ARG vector_uchar buf=, ARG vector_int params=std::vector<int>()]>

--- Incoming ---
[   u'cv.haveImageReader',
    u'bool',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..haveImageReader [ARG String filename=]>

--- Incoming ---
[   u'cv.haveImageWriter',
    u'bool',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..haveImageWriter [ARG String filename=]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs.hpp =====
Namespaces: set([u'cv'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/imgcodecs/include/opencv2/imgcodecs/imgcodecs.hpp


===== Generating... =====
CLASS ::.Imgcodecs : 
[CONST IMWRITE_JPEG_QUALITY=1, CONST IMWRITE_JPEG_PROGRESSIVE=2, CONST IMWRITE_JPEG_OPTIMIZE=3, CONST IMWRITE_JPEG_RST_INTERVAL=4, CONST IMWRITE_JPEG_LUMA_QUALITY=5, CONST IMWRITE_JPEG_CHROMA_QUALITY=6, CONST IMWRITE_PNG_COMPRESSION=16, CONST IMWRITE_PNG_STRATEGY=17, CONST IMWRITE_PNG_BILEVEL=18, CONST IMWRITE_PXM_BINARY=32, CONST IMWRITE_EXR_TYPE=(3 << 4) + 0, CONST IMWRITE_WEBP_QUALITY=64, CONST IMWRITE_PAM_TUPLETYPE=128, CONST IMWRITE_TIFF_RESUNIT=256, CONST IMWRITE_TIFF_XDPI=257, CONST IMWRITE_TIFF_YDPI=258, CONST IMWRITE_TIFF_COMPRESSION=259, CONST IMWRITE_JPEG2000_COMPRESSION_X1000=272]
[CONST IMREAD_UNCHANGED=-1, CONST IMREAD_GRAYSCALE=0, CONST IMREAD_COLOR=1, CONST IMREAD_ANYDEPTH=2, CONST IMREAD_ANYCOLOR=4, CONST IMREAD_LOAD_GDAL=8, CONST IMREAD_REDUCED_GRAYSCALE_2=16, CONST IMREAD_REDUCED_COLOR_2=17, CONST IMREAD_REDUCED_GRAYSCALE_4=32, CONST IMREAD_REDUCED_COLOR_4=33, CONST IMREAD_REDUCED_GRAYSCALE_8=64, CONST IMREAD_REDUCED_COLOR_8=65, CONST IMREAD_IGNORE_ORIENTATION=128]
[CONST IMWRITE_PAM_FORMAT_NULL=0, CONST IMWRITE_PAM_FORMAT_BLACKANDWHITE=1, CONST IMWRITE_PAM_FORMAT_GRAYSCALE=2, CONST IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA=3, CONST IMWRITE_PAM_FORMAT_RGB=4, CONST IMWRITE_PAM_FORMAT_RGB_ALPHA=5]
[CONST IMWRITE_EXR_TYPE_HALF=1, CONST IMWRITE_EXR_TYPE_FLOAT=2]
[CONST IMWRITE_PNG_STRATEGY_DEFAULT=0, CONST IMWRITE_PNG_STRATEGY_FILTERED=1, CONST IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY=2, CONST IMWRITE_PNG_STRATEGY_RLE=3, CONST IMWRITE_PNG_STRATEGY_FIXED=4]
FUNC <Mat cv..imdecode [ARG Mat buf=, ARG int flags=]>
java: Mat imdecode(Mat buf, int flags)
FUNC <Mat cv..imread [ARG String filename=, ARG int flags=IMREAD_COLOR]>
java: Mat imread(String filename, int flags)
java: Mat imread(String filename)
FUNC <bool cv..haveImageReader [ARG String filename=]>
java: boolean haveImageReader(String filename)
FUNC <bool cv..haveImageWriter [ARG String filename=]>
java: boolean haveImageWriter(String filename)
FUNC <bool cv..imencode [ARG String ext=, ARG Mat img=, ARG vector_uchar buf=, ARG vector_int params=std::vector<int>()]>
java: boolean imencode(String ext, Mat img, MatOfByte buf, MatOfInt params)
java: boolean imencode(String ext, Mat img, MatOfByte buf)
FUNC <bool cv..imreadmulti [ARG String filename=, ARG vector_Mat mats=, ARG int flags=IMREAD_ANYCOLOR]>
java: boolean imreadmulti(String filename, List<Mat> mats, int flags)
java: boolean imreadmulti(String filename, List<Mat> mats)
FUNC <bool cv..imwrite [ARG String filename=, ARG Mat img=, ARG vector_int params=std::vector<int>()]>
java: boolean imwrite(String filename, Mat img, MatOfInt params)
java: boolean imwrite(String filename, Mat img)

=== MODULE: videoio (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio) ===


Files (5):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio/cap_ios.h',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio/videoio_c.h',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio/registry.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio/videoio.hpp']

Common headers (0):
[]
ok: class CLASS ::.Videoio : , name: Videoio, base: 


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio/cap_ios.h =====
Namespaces: set([])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio/cap_ios.h


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio/videoio_c.h =====
Namespaces: set([''])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio/videoio_c.h


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio.hpp =====
Namespaces: set(['', u'cv', u'cv.internal'])

--- Incoming ---
[   u'enum cv.VideoCaptureAPIs',
    '',
    [],
    [   [u'const cv.CAP_ANY', u'0', [], [], None, ''],
        [u'const cv.CAP_VFW', u'200', [], [], None, ''],
        [u'const cv.CAP_V4L', u'200', [], [], None, ''],
        [u'const cv.CAP_V4L2', u'CAP_V4L', [], [], None, ''],
        [u'const cv.CAP_FIREWIRE', u'300', [], [], None, ''],
        [u'const cv.CAP_FIREWARE', u'CAP_FIREWIRE', [], [], None, ''],
        [u'const cv.CAP_IEEE1394', u'CAP_FIREWIRE', [], [], None, ''],
        [u'const cv.CAP_DC1394', u'CAP_FIREWIRE', [], [], None, ''],
        [u'const cv.CAP_CMU1394', u'CAP_FIREWIRE', [], [], None, ''],
        [u'const cv.CAP_QT', u'500', [], [], None, ''],
        [u'const cv.CAP_UNICAP', u'600', [], [], None, ''],
        [u'const cv.CAP_DSHOW', u'700', [], [], None, ''],
        [u'const cv.CAP_PVAPI', u'800', [], [], None, ''],
        [u'const cv.CAP_OPENNI', u'900', [], [], None, ''],
        [u'const cv.CAP_OPENNI_ASUS', u'910', [], [], None, ''],
        [u'const cv.CAP_ANDROID', u'1000', [], [], None, ''],
        [u'const cv.CAP_XIAPI', u'1100', [], [], None, ''],
        [u'const cv.CAP_AVFOUNDATION', u'1200', [], [], None, ''],
        [u'const cv.CAP_GIGANETIX', u'1300', [], [], None, ''],
        [u'const cv.CAP_MSMF', u'1400', [], [], None, ''],
        [u'const cv.CAP_WINRT', u'1410', [], [], None, ''],
        [u'const cv.CAP_INTELPERC', u'1500', [], [], None, ''],
        [u'const cv.CAP_REALSENSE', u'1500', [], [], None, ''],
        [u'const cv.CAP_OPENNI2', u'1600', [], [], None, ''],
        [u'const cv.CAP_OPENNI2_ASUS', u'1610', [], [], None, ''],
        [u'const cv.CAP_GPHOTO2', u'1700', [], [], None, ''],
        [u'const cv.CAP_GSTREAMER', u'1800', [], [], None, ''],
        [u'const cv.CAP_FFMPEG', u'1900', [], [], None, ''],
        [u'const cv.CAP_IMAGES', u'2000', [], [], None, ''],
        [u'const cv.CAP_ARAVIS', u'2100', [], [], None, ''],
        [u'const cv.CAP_OPENCV_MJPEG', u'2200', [], [], None, ''],
        [u'const cv.CAP_INTEL_MFX', u'2300', [], [], None, ''],
        [u'const cv.CAP_XINE', u'2400', [], [], None, '']],
    None]
ok: CONST CAP_ANY=0
ok: CONST CAP_VFW=200
ok: CONST CAP_V4L=200
ok: CONST CAP_V4L2=CAP_V4L
ok: CONST CAP_FIREWIRE=300
ok: CONST CAP_FIREWARE=CAP_FIREWIRE
ok: CONST CAP_IEEE1394=CAP_FIREWIRE
ok: CONST CAP_DC1394=CAP_FIREWIRE
ok: CONST CAP_CMU1394=CAP_FIREWIRE
ok: CONST CAP_QT=500
ok: CONST CAP_UNICAP=600
ok: CONST CAP_DSHOW=700
ok: CONST CAP_PVAPI=800
ok: CONST CAP_OPENNI=900
ok: CONST CAP_OPENNI_ASUS=910
ok: CONST CAP_ANDROID=1000
ok: CONST CAP_XIAPI=1100
ok: CONST CAP_AVFOUNDATION=1200
ok: CONST CAP_GIGANETIX=1300
ok: CONST CAP_MSMF=1400
ok: CONST CAP_WINRT=1410
ok: CONST CAP_INTELPERC=1500
ok: CONST CAP_REALSENSE=1500
ok: CONST CAP_OPENNI2=1600
ok: CONST CAP_OPENNI2_ASUS=1610
ok: CONST CAP_GPHOTO2=1700
ok: CONST CAP_GSTREAMER=1800
ok: CONST CAP_FFMPEG=1900
ok: CONST CAP_IMAGES=2000
ok: CONST CAP_ARAVIS=2100
ok: CONST CAP_OPENCV_MJPEG=2200
ok: CONST CAP_INTEL_MFX=2300
ok: CONST CAP_XINE=2400

--- Incoming ---
[   u'enum cv.VideoCaptureProperties',
    '',
    [],
    [   [u'const cv.CAP_PROP_POS_MSEC', u'0', [], [], None, ''],
        [u'const cv.CAP_PROP_POS_FRAMES', u'1', [], [], None, ''],
        [u'const cv.CAP_PROP_POS_AVI_RATIO', u'2', [], [], None, ''],
        [u'const cv.CAP_PROP_FRAME_WIDTH', u'3', [], [], None, ''],
        [u'const cv.CAP_PROP_FRAME_HEIGHT', u'4', [], [], None, ''],
        [u'const cv.CAP_PROP_FPS', u'5', [], [], None, ''],
        [u'const cv.CAP_PROP_FOURCC', u'6', [], [], None, ''],
        [u'const cv.CAP_PROP_FRAME_COUNT', u'7', [], [], None, ''],
        [u'const cv.CAP_PROP_FORMAT', u'8', [], [], None, ''],
        [u'const cv.CAP_PROP_MODE', u'9', [], [], None, ''],
        [u'const cv.CAP_PROP_BRIGHTNESS', u'10', [], [], None, ''],
        [u'const cv.CAP_PROP_CONTRAST', u'11', [], [], None, ''],
        [u'const cv.CAP_PROP_SATURATION', u'12', [], [], None, ''],
        [u'const cv.CAP_PROP_HUE', u'13', [], [], None, ''],
        [u'const cv.CAP_PROP_GAIN', u'14', [], [], None, ''],
        [u'const cv.CAP_PROP_EXPOSURE', u'15', [], [], None, ''],
        [u'const cv.CAP_PROP_CONVERT_RGB', u'16', [], [], None, ''],
        [u'const cv.CAP_PROP_WHITE_BALANCE_BLUE_U', u'17', [], [], None, ''],
        [u'const cv.CAP_PROP_RECTIFICATION', u'18', [], [], None, ''],
        [u'const cv.CAP_PROP_MONOCHROME', u'19', [], [], None, ''],
        [u'const cv.CAP_PROP_SHARPNESS', u'20', [], [], None, ''],
        [u'const cv.CAP_PROP_AUTO_EXPOSURE', u'21', [], [], None, ''],
        [u'const cv.CAP_PROP_GAMMA', u'22', [], [], None, ''],
        [u'const cv.CAP_PROP_TEMPERATURE', u'23', [], [], None, ''],
        [u'const cv.CAP_PROP_TRIGGER', u'24', [], [], None, ''],
        [u'const cv.CAP_PROP_TRIGGER_DELAY', u'25', [], [], None, ''],
        [u'const cv.CAP_PROP_WHITE_BALANCE_RED_V', u'26', [], [], None, ''],
        [u'const cv.CAP_PROP_ZOOM', u'27', [], [], None, ''],
        [u'const cv.CAP_PROP_FOCUS', u'28', [], [], None, ''],
        [u'const cv.CAP_PROP_GUID', u'29', [], [], None, ''],
        [u'const cv.CAP_PROP_ISO_SPEED', u'30', [], [], None, ''],
        [u'const cv.CAP_PROP_BACKLIGHT', u'32', [], [], None, ''],
        [u'const cv.CAP_PROP_PAN', u'33', [], [], None, ''],
        [u'const cv.CAP_PROP_TILT', u'34', [], [], None, ''],
        [u'const cv.CAP_PROP_ROLL', u'35', [], [], None, ''],
        [u'const cv.CAP_PROP_IRIS', u'36', [], [], None, ''],
        [u'const cv.CAP_PROP_SETTINGS', u'37', [], [], None, ''],
        [u'const cv.CAP_PROP_BUFFERSIZE', u'38', [], [], None, ''],
        [u'const cv.CAP_PROP_AUTOFOCUS', u'39', [], [], None, ''],
        [u'const cv.CAP_PROP_SAR_NUM', u'40', [], [], None, ''],
        [u'const cv.CAP_PROP_SAR_DEN', u'41', [], [], None, ''],
        [u'const cv.CAP_PROP_BACKEND', u'42', [], [], None, ''],
        [u'const cv.CAP_PROP_CHANNEL', u'43', [], [], None, ''],
        [u'const cv.CAP_PROP_AUTO_WB', u'44', [], [], None, ''],
        [u'const cv.CAP_PROP_WB_TEMPERATURE', u'45', [], [], None, ''],
        [u'const cv.CAP_PROP_CODEC_PIXEL_FORMAT', u'46', [], [], None, ''],
        [u'const cv.CAP_PROP_BITRATE', u'47', [], [], None, '']],
    None]
ok: CONST CAP_PROP_POS_MSEC=0
ok: CONST CAP_PROP_POS_FRAMES=1
ok: CONST CAP_PROP_POS_AVI_RATIO=2
ok: CONST CAP_PROP_FRAME_WIDTH=3
ok: CONST CAP_PROP_FRAME_HEIGHT=4
ok: CONST CAP_PROP_FPS=5
ok: CONST CAP_PROP_FOURCC=6
ok: CONST CAP_PROP_FRAME_COUNT=7
ok: CONST CAP_PROP_FORMAT=8
ok: CONST CAP_PROP_MODE=9
ok: CONST CAP_PROP_BRIGHTNESS=10
ok: CONST CAP_PROP_CONTRAST=11
ok: CONST CAP_PROP_SATURATION=12
ok: CONST CAP_PROP_HUE=13
ok: CONST CAP_PROP_GAIN=14
ok: CONST CAP_PROP_EXPOSURE=15
ok: CONST CAP_PROP_CONVERT_RGB=16
ok: CONST CAP_PROP_WHITE_BALANCE_BLUE_U=17
ok: CONST CAP_PROP_RECTIFICATION=18
ok: CONST CAP_PROP_MONOCHROME=19
ok: CONST CAP_PROP_SHARPNESS=20
ok: CONST CAP_PROP_AUTO_EXPOSURE=21
ok: CONST CAP_PROP_GAMMA=22
ok: CONST CAP_PROP_TEMPERATURE=23
ok: CONST CAP_PROP_TRIGGER=24
ok: CONST CAP_PROP_TRIGGER_DELAY=25
ok: CONST CAP_PROP_WHITE_BALANCE_RED_V=26
ok: CONST CAP_PROP_ZOOM=27
ok: CONST CAP_PROP_FOCUS=28
ok: CONST CAP_PROP_GUID=29
ok: CONST CAP_PROP_ISO_SPEED=30
ok: CONST CAP_PROP_BACKLIGHT=32
ok: CONST CAP_PROP_PAN=33
ok: CONST CAP_PROP_TILT=34
ok: CONST CAP_PROP_ROLL=35
ok: CONST CAP_PROP_IRIS=36
ok: CONST CAP_PROP_SETTINGS=37
ok: CONST CAP_PROP_BUFFERSIZE=38
ok: CONST CAP_PROP_AUTOFOCUS=39
ok: CONST CAP_PROP_SAR_NUM=40
ok: CONST CAP_PROP_SAR_DEN=41
ok: CONST CAP_PROP_BACKEND=42
ok: CONST CAP_PROP_CHANNEL=43
ok: CONST CAP_PROP_AUTO_WB=44
ok: CONST CAP_PROP_WB_TEMPERATURE=45
ok: CONST CAP_PROP_CODEC_PIXEL_FORMAT=46
ok: CONST CAP_PROP_BITRATE=47

--- Incoming ---
[   u'enum cv.VideoWriterProperties',
    '',
    [],
    [   [u'const cv.VIDEOWRITER_PROP_QUALITY', u'1', [], [], None, ''],
        [u'const cv.VIDEOWRITER_PROP_FRAMEBYTES', u'2', [], [], None, ''],
        [u'const cv.VIDEOWRITER_PROP_NSTRIPES', u'3', [], [], None, '']],
    None]
ok: CONST VIDEOWRITER_PROP_QUALITY=1
ok: CONST VIDEOWRITER_PROP_FRAMEBYTES=2
ok: CONST VIDEOWRITER_PROP_NSTRIPES=3

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_DC1394_OFF', u'-4', [], [], None, ''],
        [u'const cv.CAP_PROP_DC1394_MODE_MANUAL', u'-3', [], [], None, ''],
        [u'const cv.CAP_PROP_DC1394_MODE_AUTO', u'-2', [], [], None, ''],
        [   u'const cv.CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO',
            u'-1',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_DC1394_MAX', u'31', [], [], None, '']],
    None]
ok: CONST CAP_PROP_DC1394_OFF=-4
ok: CONST CAP_PROP_DC1394_MODE_MANUAL=-3
ok: CONST CAP_PROP_DC1394_MODE_AUTO=-2
ok: CONST CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO=-1
ok: CONST CAP_PROP_DC1394_MAX=31

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR',
            u'1 << 31',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_IMAGE_GENERATOR',
            u'1 << 30',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_OPENNI_IR_GENERATOR', u'1 << 29', [], [], None, ''],
        [   u'const cv.CAP_OPENNI_GENERATORS_MASK',
            u'CAP_OPENNI_DEPTH_GENERATOR + CAP_OPENNI_IMAGE_GENERATOR + CAP_OPENNI_IR_GENERATOR',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_OPENNI_DEPTH_GENERATOR=1 << 31
ok: CONST CAP_OPENNI_IMAGE_GENERATOR=1 << 30
ok: CONST CAP_OPENNI_IR_GENERATOR=1 << 29
ok: CONST CAP_OPENNI_GENERATORS_MASK=CAP_OPENNI_DEPTH_GENERATOR + CAP_OPENNI_IMAGE_GENERATOR + CAP_OPENNI_IR_GENERATOR

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_OPENNI_OUTPUT_MODE', u'100', [], [], None, ''],
        [   u'const cv.CAP_PROP_OPENNI_FRAME_MAX_DEPTH',
            u'101',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_OPENNI_BASELINE', u'102', [], [], None, ''],
        [u'const cv.CAP_PROP_OPENNI_FOCAL_LENGTH', u'103', [], [], None, ''],
        [u'const cv.CAP_PROP_OPENNI_REGISTRATION', u'104', [], [], None, ''],
        [   u'const cv.CAP_PROP_OPENNI_REGISTRATION_ON',
            u'CAP_PROP_OPENNI_REGISTRATION',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_OPENNI_APPROX_FRAME_SYNC',
            u'105',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_OPENNI_MAX_BUFFER_SIZE',
            u'106',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_OPENNI_CIRCLE_BUFFER', u'107', [], [], None, ''],
        [   u'const cv.CAP_PROP_OPENNI_MAX_TIME_DURATION',
            u'108',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_OPENNI_GENERATOR_PRESENT',
            u'109',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_OPENNI2_SYNC', u'110', [], [], None, ''],
        [u'const cv.CAP_PROP_OPENNI2_MIRROR', u'111', [], [], None, '']],
    None]
ok: CONST CAP_PROP_OPENNI_OUTPUT_MODE=100
ok: CONST CAP_PROP_OPENNI_FRAME_MAX_DEPTH=101
ok: CONST CAP_PROP_OPENNI_BASELINE=102
ok: CONST CAP_PROP_OPENNI_FOCAL_LENGTH=103
ok: CONST CAP_PROP_OPENNI_REGISTRATION=104
ok: CONST CAP_PROP_OPENNI_REGISTRATION_ON=CAP_PROP_OPENNI_REGISTRATION
ok: CONST CAP_PROP_OPENNI_APPROX_FRAME_SYNC=105
ok: CONST CAP_PROP_OPENNI_MAX_BUFFER_SIZE=106
ok: CONST CAP_PROP_OPENNI_CIRCLE_BUFFER=107
ok: CONST CAP_PROP_OPENNI_MAX_TIME_DURATION=108
ok: CONST CAP_PROP_OPENNI_GENERATOR_PRESENT=109
ok: CONST CAP_PROP_OPENNI2_SYNC=110
ok: CONST CAP_PROP_OPENNI2_MIRROR=111

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [   u'const cv.CAP_OPENNI_IMAGE_GENERATOR_PRESENT',
            u'CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE',
            u'CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_OUTPUT_MODE',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR_PRESENT',
            u'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR_BASELINE',
            u'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_BASELINE',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH',
            u'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_FOCAL_LENGTH',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION',
            u'CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_REGISTRATION',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON',
            u'CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_OPENNI_IR_GENERATOR_PRESENT',
            u'CAP_OPENNI_IR_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_OPENNI_IMAGE_GENERATOR_PRESENT=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT
ok: CONST CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_OUTPUT_MODE
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_PRESENT=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_BASELINE=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_BASELINE
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_FOCAL_LENGTH
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_REGISTRATION
ok: CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON=CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION
ok: CONST CAP_OPENNI_IR_GENERATOR_PRESENT=CAP_OPENNI_IR_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_OPENNI_DEPTH_MAP', u'0', [], [], None, ''],
        [u'const cv.CAP_OPENNI_POINT_CLOUD_MAP', u'1', [], [], None, ''],
        [u'const cv.CAP_OPENNI_DISPARITY_MAP', u'2', [], [], None, ''],
        [u'const cv.CAP_OPENNI_DISPARITY_MAP_32F', u'3', [], [], None, ''],
        [u'const cv.CAP_OPENNI_VALID_DEPTH_MASK', u'4', [], [], None, ''],
        [u'const cv.CAP_OPENNI_BGR_IMAGE', u'5', [], [], None, ''],
        [u'const cv.CAP_OPENNI_GRAY_IMAGE', u'6', [], [], None, ''],
        [u'const cv.CAP_OPENNI_IR_IMAGE', u'7', [], [], None, '']],
    None]
ok: CONST CAP_OPENNI_DEPTH_MAP=0
ok: CONST CAP_OPENNI_POINT_CLOUD_MAP=1
ok: CONST CAP_OPENNI_DISPARITY_MAP=2
ok: CONST CAP_OPENNI_DISPARITY_MAP_32F=3
ok: CONST CAP_OPENNI_VALID_DEPTH_MASK=4
ok: CONST CAP_OPENNI_BGR_IMAGE=5
ok: CONST CAP_OPENNI_GRAY_IMAGE=6
ok: CONST CAP_OPENNI_IR_IMAGE=7

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_OPENNI_VGA_30HZ', u'0', [], [], None, ''],
        [u'const cv.CAP_OPENNI_SXGA_15HZ', u'1', [], [], None, ''],
        [u'const cv.CAP_OPENNI_SXGA_30HZ', u'2', [], [], None, ''],
        [u'const cv.CAP_OPENNI_QVGA_30HZ', u'3', [], [], None, ''],
        [u'const cv.CAP_OPENNI_QVGA_60HZ', u'4', [], [], None, '']],
    None]
ok: CONST CAP_OPENNI_VGA_30HZ=0
ok: CONST CAP_OPENNI_SXGA_15HZ=1
ok: CONST CAP_OPENNI_SXGA_30HZ=2
ok: CONST CAP_OPENNI_QVGA_30HZ=3
ok: CONST CAP_OPENNI_QVGA_60HZ=4

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [[   u'const cv.CAP_PROP_GSTREAMER_QUEUE_LENGTH',
            u'200',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_PROP_GSTREAMER_QUEUE_LENGTH=200

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_PVAPI_MULTICASTIP', u'300', [], [], None, ''],
        [   u'const cv.CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE',
            u'301',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_PVAPI_DECIMATIONHORIZONTAL',
            u'302',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_PVAPI_DECIMATIONVERTICAL',
            u'303',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_PVAPI_BINNINGX', u'304', [], [], None, ''],
        [u'const cv.CAP_PROP_PVAPI_BINNINGY', u'305', [], [], None, ''],
        [u'const cv.CAP_PROP_PVAPI_PIXELFORMAT', u'306', [], [], None, '']],
    None]
ok: CONST CAP_PROP_PVAPI_MULTICASTIP=300
ok: CONST CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE=301
ok: CONST CAP_PROP_PVAPI_DECIMATIONHORIZONTAL=302
ok: CONST CAP_PROP_PVAPI_DECIMATIONVERTICAL=303
ok: CONST CAP_PROP_PVAPI_BINNINGX=304
ok: CONST CAP_PROP_PVAPI_BINNINGY=305
ok: CONST CAP_PROP_PVAPI_PIXELFORMAT=306

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PVAPI_FSTRIGMODE_FREERUN', u'0', [], [], None, ''],
        [u'const cv.CAP_PVAPI_FSTRIGMODE_SYNCIN1', u'1', [], [], None, ''],
        [u'const cv.CAP_PVAPI_FSTRIGMODE_SYNCIN2', u'2', [], [], None, ''],
        [u'const cv.CAP_PVAPI_FSTRIGMODE_FIXEDRATE', u'3', [], [], None, ''],
        [u'const cv.CAP_PVAPI_FSTRIGMODE_SOFTWARE', u'4', [], [], None, '']],
    None]
ok: CONST CAP_PVAPI_FSTRIGMODE_FREERUN=0
ok: CONST CAP_PVAPI_FSTRIGMODE_SYNCIN1=1
ok: CONST CAP_PVAPI_FSTRIGMODE_SYNCIN2=2
ok: CONST CAP_PVAPI_FSTRIGMODE_FIXEDRATE=3
ok: CONST CAP_PVAPI_FSTRIGMODE_SOFTWARE=4

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PVAPI_DECIMATION_OFF', u'1', [], [], None, ''],
        [u'const cv.CAP_PVAPI_DECIMATION_2OUTOF4', u'2', [], [], None, ''],
        [u'const cv.CAP_PVAPI_DECIMATION_2OUTOF8', u'4', [], [], None, ''],
        [u'const cv.CAP_PVAPI_DECIMATION_2OUTOF16', u'8', [], [], None, '']],
    None]
ok: CONST CAP_PVAPI_DECIMATION_OFF=1
ok: CONST CAP_PVAPI_DECIMATION_2OUTOF4=2
ok: CONST CAP_PVAPI_DECIMATION_2OUTOF8=4
ok: CONST CAP_PVAPI_DECIMATION_2OUTOF16=8

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PVAPI_PIXELFORMAT_MONO8', u'1', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_MONO16', u'2', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_BAYER8', u'3', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_BAYER16', u'4', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_RGB24', u'5', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_BGR24', u'6', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_RGBA32', u'7', [], [], None, ''],
        [u'const cv.CAP_PVAPI_PIXELFORMAT_BGRA32', u'8', [], [], None, '']],
    None]
ok: CONST CAP_PVAPI_PIXELFORMAT_MONO8=1
ok: CONST CAP_PVAPI_PIXELFORMAT_MONO16=2
ok: CONST CAP_PVAPI_PIXELFORMAT_BAYER8=3
ok: CONST CAP_PVAPI_PIXELFORMAT_BAYER16=4
ok: CONST CAP_PVAPI_PIXELFORMAT_RGB24=5
ok: CONST CAP_PVAPI_PIXELFORMAT_BGR24=6
ok: CONST CAP_PVAPI_PIXELFORMAT_RGBA32=7
ok: CONST CAP_PVAPI_PIXELFORMAT_BGRA32=8

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_XI_DOWNSAMPLING', u'400', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DATA_FORMAT', u'401', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_OFFSET_X', u'402', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_OFFSET_Y', u'403', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TRG_SOURCE', u'404', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TRG_SOFTWARE', u'405', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GPI_SELECTOR', u'406', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GPI_MODE', u'407', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GPI_LEVEL', u'408', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GPO_SELECTOR', u'409', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GPO_MODE', u'410', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LED_SELECTOR', u'411', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LED_MODE', u'412', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_MANUAL_WB', u'413', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AUTO_WB', u'414', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG', u'415', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_EXP_PRIORITY', u'416', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AE_MAX_LIMIT', u'417', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AG_MAX_LIMIT', u'418', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG_LEVEL', u'419', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TIMEOUT', u'420', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_EXPOSURE', u'421', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_EXPOSURE_BURST_COUNT',
            u'422',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_GAIN_SELECTOR', u'423', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GAIN', u'424', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DOWNSAMPLING_TYPE', u'426', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_BINNING_SELECTOR', u'427', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_BINNING_VERTICAL', u'428', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_BINNING_HORIZONTAL',
            u'429',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_BINNING_PATTERN', u'430', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_DECIMATION_SELECTOR',
            u'431',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_DECIMATION_VERTICAL',
            u'432',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_DECIMATION_HORIZONTAL',
            u'433',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_DECIMATION_PATTERN',
            u'434',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR',
            u'587',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_TEST_PATTERN', u'588', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_IMAGE_DATA_FORMAT', u'435', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_SHUTTER_TYPE', u'436', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_SENSOR_TAPS', u'437', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG_ROI_OFFSET_X', u'439', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG_ROI_OFFSET_Y', u'440', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG_ROI_WIDTH', u'441', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_AEAG_ROI_HEIGHT', u'442', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_BPC', u'445', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_WB_KR', u'448', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_WB_KG', u'449', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_WB_KB', u'450', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_WIDTH', u'451', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_HEIGHT', u'452', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_REGION_SELECTOR', u'589', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_REGION_MODE', u'595', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LIMIT_BANDWIDTH', u'459', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH',
            u'460',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH',
            u'461',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH',
            u'462',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_OUTPUT_DATA_PACKING',
            u'463',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE',
            u'464',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_IS_COOLED', u'465', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_COOLING', u'466', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TARGET_TEMP', u'467', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CHIP_TEMP', u'468', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_HOUS_TEMP', u'469', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_HOUS_BACK_SIDE_TEMP',
            u'590',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_SENSOR_BOARD_TEMP', u'596', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CMS', u'470', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_APPLY_CMS', u'471', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_IMAGE_IS_COLOR', u'474', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_COLOR_FILTER_ARRAY',
            u'475',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_GAMMAY', u'476', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_GAMMAC', u'477', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_SHARPNESS', u'478', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_00', u'479', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_01', u'480', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_02', u'481', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_03', u'482', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_10', u'483', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_11', u'484', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_12', u'485', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_13', u'486', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_20', u'487', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_21', u'488', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_22', u'489', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_23', u'490', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_30', u'491', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_31', u'492', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_32', u'493', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_CC_MATRIX_33', u'494', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEFAULT_CC_MATRIX', u'495', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TRG_SELECTOR', u'498', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_ACQ_FRAME_BURST_COUNT',
            u'499',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_DEBOUNCE_EN', u'507', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEBOUNCE_T0', u'508', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEBOUNCE_T1', u'509', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEBOUNCE_POL', u'510', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LENS_MODE', u'511', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_LENS_APERTURE_VALUE',
            u'512',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE',
            u'513',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_LENS_FOCUS_MOVE', u'514', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_LENS_FOCUS_DISTANCE',
            u'515',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_LENS_FOCAL_LENGTH', u'516', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_LENS_FEATURE_SELECTOR',
            u'517',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_LENS_FEATURE', u'518', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEVICE_MODEL_ID', u'521', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEVICE_SN', u'522', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA',
            u'529',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_IMAGE_PAYLOAD_SIZE',
            u'530',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT',
            u'531',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ',
            u'532',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX',
            u'533',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT',
            u'534',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_FRAMERATE', u'535', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_COUNTER_SELECTOR', u'536', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_COUNTER_VALUE', u'537', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_ACQ_TIMING_MODE', u'538', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_AVAILABLE_BANDWIDTH',
            u'539',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_BUFFER_POLICY', u'540', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LUT_EN', u'541', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LUT_INDEX', u'542', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_LUT_VALUE', u'543', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TRG_DELAY', u'544', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TS_RST_MODE', u'545', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_TS_RST_SOURCE', u'546', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_IS_DEVICE_EXIST', u'547', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_ACQ_BUFFER_SIZE', u'548', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT',
            u'549',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE',
            u'550',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_BUFFERS_QUEUE_SIZE',
            u'551',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT',
            u'552',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_RECENT_FRAME', u'553', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEVICE_RESET', u'554', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_COLUMN_FPN_CORRECTION',
            u'555',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_ROW_FPN_CORRECTION',
            u'591',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_SENSOR_MODE', u'558', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_HDR', u'559', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_HDR_KNEEPOINT_COUNT',
            u'560',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_HDR_T1', u'561', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_HDR_T2', u'562', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_KNEEPOINT1', u'563', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_KNEEPOINT2', u'564', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_IMAGE_BLACK_LEVEL', u'565', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_HW_REVISION', u'571', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_DEBUG_LEVEL', u'572', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION',
            u'573',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_XI_FFS_FILE_ID', u'594', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_FFS_FILE_SIZE', u'580', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_FREE_FFS_SIZE', u'581', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_USED_FFS_SIZE', u'582', [], [], None, ''],
        [u'const cv.CAP_PROP_XI_FFS_ACCESS_KEY', u'583', [], [], None, ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_FEATURE_SELECTOR',
            u'585',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_XI_SENSOR_FEATURE_VALUE',
            u'586',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_PROP_XI_DOWNSAMPLING=400
ok: CONST CAP_PROP_XI_DATA_FORMAT=401
ok: CONST CAP_PROP_XI_OFFSET_X=402
ok: CONST CAP_PROP_XI_OFFSET_Y=403
ok: CONST CAP_PROP_XI_TRG_SOURCE=404
ok: CONST CAP_PROP_XI_TRG_SOFTWARE=405
ok: CONST CAP_PROP_XI_GPI_SELECTOR=406
ok: CONST CAP_PROP_XI_GPI_MODE=407
ok: CONST CAP_PROP_XI_GPI_LEVEL=408
ok: CONST CAP_PROP_XI_GPO_SELECTOR=409
ok: CONST CAP_PROP_XI_GPO_MODE=410
ok: CONST CAP_PROP_XI_LED_SELECTOR=411
ok: CONST CAP_PROP_XI_LED_MODE=412
ok: CONST CAP_PROP_XI_MANUAL_WB=413
ok: CONST CAP_PROP_XI_AUTO_WB=414
ok: CONST CAP_PROP_XI_AEAG=415
ok: CONST CAP_PROP_XI_EXP_PRIORITY=416
ok: CONST CAP_PROP_XI_AE_MAX_LIMIT=417
ok: CONST CAP_PROP_XI_AG_MAX_LIMIT=418
ok: CONST CAP_PROP_XI_AEAG_LEVEL=419
ok: CONST CAP_PROP_XI_TIMEOUT=420
ok: CONST CAP_PROP_XI_EXPOSURE=421
ok: CONST CAP_PROP_XI_EXPOSURE_BURST_COUNT=422
ok: CONST CAP_PROP_XI_GAIN_SELECTOR=423
ok: CONST CAP_PROP_XI_GAIN=424
ok: CONST CAP_PROP_XI_DOWNSAMPLING_TYPE=426
ok: CONST CAP_PROP_XI_BINNING_SELECTOR=427
ok: CONST CAP_PROP_XI_BINNING_VERTICAL=428
ok: CONST CAP_PROP_XI_BINNING_HORIZONTAL=429
ok: CONST CAP_PROP_XI_BINNING_PATTERN=430
ok: CONST CAP_PROP_XI_DECIMATION_SELECTOR=431
ok: CONST CAP_PROP_XI_DECIMATION_VERTICAL=432
ok: CONST CAP_PROP_XI_DECIMATION_HORIZONTAL=433
ok: CONST CAP_PROP_XI_DECIMATION_PATTERN=434
ok: CONST CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR=587
ok: CONST CAP_PROP_XI_TEST_PATTERN=588
ok: CONST CAP_PROP_XI_IMAGE_DATA_FORMAT=435
ok: CONST CAP_PROP_XI_SHUTTER_TYPE=436
ok: CONST CAP_PROP_XI_SENSOR_TAPS=437
ok: CONST CAP_PROP_XI_AEAG_ROI_OFFSET_X=439
ok: CONST CAP_PROP_XI_AEAG_ROI_OFFSET_Y=440
ok: CONST CAP_PROP_XI_AEAG_ROI_WIDTH=441
ok: CONST CAP_PROP_XI_AEAG_ROI_HEIGHT=442
ok: CONST CAP_PROP_XI_BPC=445
ok: CONST CAP_PROP_XI_WB_KR=448
ok: CONST CAP_PROP_XI_WB_KG=449
ok: CONST CAP_PROP_XI_WB_KB=450
ok: CONST CAP_PROP_XI_WIDTH=451
ok: CONST CAP_PROP_XI_HEIGHT=452
ok: CONST CAP_PROP_XI_REGION_SELECTOR=589
ok: CONST CAP_PROP_XI_REGION_MODE=595
ok: CONST CAP_PROP_XI_LIMIT_BANDWIDTH=459
ok: CONST CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH=460
ok: CONST CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH=461
ok: CONST CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH=462
ok: CONST CAP_PROP_XI_OUTPUT_DATA_PACKING=463
ok: CONST CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE=464
ok: CONST CAP_PROP_XI_IS_COOLED=465
ok: CONST CAP_PROP_XI_COOLING=466
ok: CONST CAP_PROP_XI_TARGET_TEMP=467
ok: CONST CAP_PROP_XI_CHIP_TEMP=468
ok: CONST CAP_PROP_XI_HOUS_TEMP=469
ok: CONST CAP_PROP_XI_HOUS_BACK_SIDE_TEMP=590
ok: CONST CAP_PROP_XI_SENSOR_BOARD_TEMP=596
ok: CONST CAP_PROP_XI_CMS=470
ok: CONST CAP_PROP_XI_APPLY_CMS=471
ok: CONST CAP_PROP_XI_IMAGE_IS_COLOR=474
ok: CONST CAP_PROP_XI_COLOR_FILTER_ARRAY=475
ok: CONST CAP_PROP_XI_GAMMAY=476
ok: CONST CAP_PROP_XI_GAMMAC=477
ok: CONST CAP_PROP_XI_SHARPNESS=478
ok: CONST CAP_PROP_XI_CC_MATRIX_00=479
ok: CONST CAP_PROP_XI_CC_MATRIX_01=480
ok: CONST CAP_PROP_XI_CC_MATRIX_02=481
ok: CONST CAP_PROP_XI_CC_MATRIX_03=482
ok: CONST CAP_PROP_XI_CC_MATRIX_10=483
ok: CONST CAP_PROP_XI_CC_MATRIX_11=484
ok: CONST CAP_PROP_XI_CC_MATRIX_12=485
ok: CONST CAP_PROP_XI_CC_MATRIX_13=486
ok: CONST CAP_PROP_XI_CC_MATRIX_20=487
ok: CONST CAP_PROP_XI_CC_MATRIX_21=488
ok: CONST CAP_PROP_XI_CC_MATRIX_22=489
ok: CONST CAP_PROP_XI_CC_MATRIX_23=490
ok: CONST CAP_PROP_XI_CC_MATRIX_30=491
ok: CONST CAP_PROP_XI_CC_MATRIX_31=492
ok: CONST CAP_PROP_XI_CC_MATRIX_32=493
ok: CONST CAP_PROP_XI_CC_MATRIX_33=494
ok: CONST CAP_PROP_XI_DEFAULT_CC_MATRIX=495
ok: CONST CAP_PROP_XI_TRG_SELECTOR=498
ok: CONST CAP_PROP_XI_ACQ_FRAME_BURST_COUNT=499
ok: CONST CAP_PROP_XI_DEBOUNCE_EN=507
ok: CONST CAP_PROP_XI_DEBOUNCE_T0=508
ok: CONST CAP_PROP_XI_DEBOUNCE_T1=509
ok: CONST CAP_PROP_XI_DEBOUNCE_POL=510
ok: CONST CAP_PROP_XI_LENS_MODE=511
ok: CONST CAP_PROP_XI_LENS_APERTURE_VALUE=512
ok: CONST CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE=513
ok: CONST CAP_PROP_XI_LENS_FOCUS_MOVE=514
ok: CONST CAP_PROP_XI_LENS_FOCUS_DISTANCE=515
ok: CONST CAP_PROP_XI_LENS_FOCAL_LENGTH=516
ok: CONST CAP_PROP_XI_LENS_FEATURE_SELECTOR=517
ok: CONST CAP_PROP_XI_LENS_FEATURE=518
ok: CONST CAP_PROP_XI_DEVICE_MODEL_ID=521
ok: CONST CAP_PROP_XI_DEVICE_SN=522
ok: CONST CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA=529
ok: CONST CAP_PROP_XI_IMAGE_PAYLOAD_SIZE=530
ok: CONST CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT=531
ok: CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ=532
ok: CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX=533
ok: CONST CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT=534
ok: CONST CAP_PROP_XI_FRAMERATE=535
ok: CONST CAP_PROP_XI_COUNTER_SELECTOR=536
ok: CONST CAP_PROP_XI_COUNTER_VALUE=537
ok: CONST CAP_PROP_XI_ACQ_TIMING_MODE=538
ok: CONST CAP_PROP_XI_AVAILABLE_BANDWIDTH=539
ok: CONST CAP_PROP_XI_BUFFER_POLICY=540
ok: CONST CAP_PROP_XI_LUT_EN=541
ok: CONST CAP_PROP_XI_LUT_INDEX=542
ok: CONST CAP_PROP_XI_LUT_VALUE=543
ok: CONST CAP_PROP_XI_TRG_DELAY=544
ok: CONST CAP_PROP_XI_TS_RST_MODE=545
ok: CONST CAP_PROP_XI_TS_RST_SOURCE=546
ok: CONST CAP_PROP_XI_IS_DEVICE_EXIST=547
ok: CONST CAP_PROP_XI_ACQ_BUFFER_SIZE=548
ok: CONST CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT=549
ok: CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE=550
ok: CONST CAP_PROP_XI_BUFFERS_QUEUE_SIZE=551
ok: CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT=552
ok: CONST CAP_PROP_XI_RECENT_FRAME=553
ok: CONST CAP_PROP_XI_DEVICE_RESET=554
ok: CONST CAP_PROP_XI_COLUMN_FPN_CORRECTION=555
ok: CONST CAP_PROP_XI_ROW_FPN_CORRECTION=591
ok: CONST CAP_PROP_XI_SENSOR_MODE=558
ok: CONST CAP_PROP_XI_HDR=559
ok: CONST CAP_PROP_XI_HDR_KNEEPOINT_COUNT=560
ok: CONST CAP_PROP_XI_HDR_T1=561
ok: CONST CAP_PROP_XI_HDR_T2=562
ok: CONST CAP_PROP_XI_KNEEPOINT1=563
ok: CONST CAP_PROP_XI_KNEEPOINT2=564
ok: CONST CAP_PROP_XI_IMAGE_BLACK_LEVEL=565
ok: CONST CAP_PROP_XI_HW_REVISION=571
ok: CONST CAP_PROP_XI_DEBUG_LEVEL=572
ok: CONST CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION=573
ok: CONST CAP_PROP_XI_FFS_FILE_ID=594
ok: CONST CAP_PROP_XI_FFS_FILE_SIZE=580
ok: CONST CAP_PROP_XI_FREE_FFS_SIZE=581
ok: CONST CAP_PROP_XI_USED_FFS_SIZE=582
ok: CONST CAP_PROP_XI_FFS_ACCESS_KEY=583
ok: CONST CAP_PROP_XI_SENSOR_FEATURE_SELECTOR=585
ok: CONST CAP_PROP_XI_SENSOR_FEATURE_VALUE=586

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [[u'const cv.CAP_PROP_ARAVIS_AUTOTRIGGER', u'600', [], [], None, '']],
    None]
ok: CONST CAP_PROP_ARAVIS_AUTOTRIGGER=600

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_IOS_DEVICE_FOCUS', u'9001', [], [], None, ''],
        [u'const cv.CAP_PROP_IOS_DEVICE_EXPOSURE', u'9002', [], [], None, ''],
        [u'const cv.CAP_PROP_IOS_DEVICE_FLASH', u'9003', [], [], None, ''],
        [   u'const cv.CAP_PROP_IOS_DEVICE_WHITEBALANCE',
            u'9004',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_IOS_DEVICE_TORCH', u'9005', [], [], None, '']],
    None]
ok: CONST CAP_PROP_IOS_DEVICE_FOCUS=9001
ok: CONST CAP_PROP_IOS_DEVICE_EXPOSURE=9002
ok: CONST CAP_PROP_IOS_DEVICE_FLASH=9003
ok: CONST CAP_PROP_IOS_DEVICE_WHITEBALANCE=9004
ok: CONST CAP_PROP_IOS_DEVICE_TORCH=9005

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [   u'const cv.CAP_PROP_GIGA_FRAME_OFFSET_X',
            u'10001',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GIGA_FRAME_OFFSET_Y',
            u'10002',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GIGA_FRAME_WIDTH_MAX',
            u'10003',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GIGA_FRAME_HEIGH_MAX',
            u'10004',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GIGA_FRAME_SENS_WIDTH',
            u'10005',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GIGA_FRAME_SENS_HEIGH',
            u'10006',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_PROP_GIGA_FRAME_OFFSET_X=10001
ok: CONST CAP_PROP_GIGA_FRAME_OFFSET_Y=10002
ok: CONST CAP_PROP_GIGA_FRAME_WIDTH_MAX=10003
ok: CONST CAP_PROP_GIGA_FRAME_HEIGH_MAX=10004
ok: CONST CAP_PROP_GIGA_FRAME_SENS_WIDTH=10005
ok: CONST CAP_PROP_GIGA_FRAME_SENS_HEIGH=10006

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [   u'const cv.CAP_PROP_INTELPERC_PROFILE_COUNT',
            u'11001',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_PROFILE_IDX',
            u'11002',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE',
            u'11003',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE',
            u'11004',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD',
            u'11005',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ',
            u'11006',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT',
            u'11007',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_PROP_INTELPERC_PROFILE_COUNT=11001
ok: CONST CAP_PROP_INTELPERC_PROFILE_IDX=11002
ok: CONST CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE=11003
ok: CONST CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE=11004
ok: CONST CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD=11005
ok: CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ=11006
ok: CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT=11007

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [   u'const cv.CAP_INTELPERC_DEPTH_GENERATOR',
            u'1 << 29',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_INTELPERC_IMAGE_GENERATOR',
            u'1 << 28',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_INTELPERC_IR_GENERATOR',
            u'1 << 27',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_INTELPERC_GENERATORS_MASK',
            u'CAP_INTELPERC_DEPTH_GENERATOR + CAP_INTELPERC_IMAGE_GENERATOR + CAP_INTELPERC_IR_GENERATOR',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CAP_INTELPERC_DEPTH_GENERATOR=1 << 29
ok: CONST CAP_INTELPERC_IMAGE_GENERATOR=1 << 28
ok: CONST CAP_INTELPERC_IR_GENERATOR=1 << 27
ok: CONST CAP_INTELPERC_GENERATORS_MASK=CAP_INTELPERC_DEPTH_GENERATOR + CAP_INTELPERC_IMAGE_GENERATOR + CAP_INTELPERC_IR_GENERATOR

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_INTELPERC_DEPTH_MAP', u'0', [], [], None, ''],
        [u'const cv.CAP_INTELPERC_UVDEPTH_MAP', u'1', [], [], None, ''],
        [u'const cv.CAP_INTELPERC_IR_MAP', u'2', [], [], None, ''],
        [u'const cv.CAP_INTELPERC_IMAGE', u'3', [], [], None, '']],
    None]
ok: CONST CAP_INTELPERC_DEPTH_MAP=0
ok: CONST CAP_INTELPERC_UVDEPTH_MAP=1
ok: CONST CAP_INTELPERC_IR_MAP=2
ok: CONST CAP_INTELPERC_IMAGE=3

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_GPHOTO2_PREVIEW', u'17001', [], [], None, ''],
        [   u'const cv.CAP_PROP_GPHOTO2_WIDGET_ENUMERATE',
            u'17002',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GPHOTO2_RELOAD_CONFIG',
            u'17003',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE',
            u'17004',
            [],
            [],
            None,
            ''],
        [   u'const cv.CAP_PROP_GPHOTO2_COLLECT_MSGS',
            u'17005',
            [],
            [],
            None,
            ''],
        [u'const cv.CAP_PROP_GPHOTO2_FLUSH_MSGS', u'17006', [], [], None, ''],
        [u'const cv.CAP_PROP_SPEED', u'17007', [], [], None, ''],
        [u'const cv.CAP_PROP_APERTURE', u'17008', [], [], None, ''],
        [u'const cv.CAP_PROP_EXPOSUREPROGRAM', u'17009', [], [], None, ''],
        [u'const cv.CAP_PROP_VIEWFINDER', u'17010', [], [], None, '']],
    None]
ok: CONST CAP_PROP_GPHOTO2_PREVIEW=17001
ok: CONST CAP_PROP_GPHOTO2_WIDGET_ENUMERATE=17002
ok: CONST CAP_PROP_GPHOTO2_RELOAD_CONFIG=17003
ok: CONST CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE=17004
ok: CONST CAP_PROP_GPHOTO2_COLLECT_MSGS=17005
ok: CONST CAP_PROP_GPHOTO2_FLUSH_MSGS=17006
ok: CONST CAP_PROP_SPEED=17007
ok: CONST CAP_PROP_APERTURE=17008
ok: CONST CAP_PROP_EXPOSUREPROGRAM=17009
ok: CONST CAP_PROP_VIEWFINDER=17010

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CAP_PROP_IMAGES_BASE', u'18000', [], [], None, ''],
        [u'const cv.CAP_PROP_IMAGES_LAST', u'19000', [], [], None, '']],
    None]
ok: CONST CAP_PROP_IMAGES_BASE=18000
ok: CONST CAP_PROP_IMAGES_LAST=19000

--- Incoming ---
[u'class cv.VideoCapture', '', [], [], None]
ok: class CLASS cv::.VideoCapture : , name: VideoCapture, base: 

--- Incoming ---
[u'cv.VideoCapture.VideoCapture', '', [], [], None]
ok: FUNC < cv.VideoCapture.VideoCapture []>

--- Incoming ---
[   u'cv.VideoCapture.VideoCapture',
    u'explicit',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'apiPreference', u'CAP_ANY', []]],
    u'explicit']
ok: FUNC <explicit cv.VideoCapture.VideoCapture [ARG String filename=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[   u'cv.VideoCapture.VideoCapture',
    u'explicit',
    [],
    [[u'int', u'index', u'', []], [u'int', u'apiPreference', u'CAP_ANY', []]],
    u'explicit']
ok: FUNC <explicit cv.VideoCapture.VideoCapture [ARG int index=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[   u'cv.VideoCapture.open',
    u'bool',
    ['/V'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'apiPreference', u'CAP_ANY', []]],
    u'bool']
ok: FUNC <bool cv.VideoCapture.open [ARG String filename=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[   u'cv.VideoCapture.open',
    u'bool',
    ['/V'],
    [[u'int', u'index', u'', []], [u'int', u'apiPreference', u'CAP_ANY', []]],
    u'bool']
ok: FUNC <bool cv.VideoCapture.open [ARG int index=, ARG int apiPreference=CAP_ANY]>

--- Incoming ---
[u'cv.VideoCapture.isOpened', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.VideoCapture.isOpened []>

--- Incoming ---
[u'cv.VideoCapture.release', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.VideoCapture.release []>

--- Incoming ---
[u'cv.VideoCapture.grab', u'bool', ['/V'], [], u'bool']
ok: FUNC <bool cv.VideoCapture.grab []>

--- Incoming ---
[   u'cv.VideoCapture.retrieve',
    u'bool',
    ['/V'],
    [['Mat', u'image', '', ['/O']], [u'int', u'flag', u'0', []]],
    u'bool']
ok: FUNC <bool cv.VideoCapture.retrieve [ARG Mat image=, ARG int flag=0]>

--- Incoming ---
[   u'cv.VideoCapture.read',
    u'bool',
    ['/V'],
    [['Mat', u'image', '', ['/O']]],
    u'bool']
ok: FUNC <bool cv.VideoCapture.read [ARG Mat image=]>

--- Incoming ---
[   u'cv.VideoCapture.set',
    u'bool',
    ['/V'],
    [[u'int', u'propId', u'', []], [u'double', u'value', u'', []]],
    u'bool']
ok: FUNC <bool cv.VideoCapture.set [ARG int propId=, ARG double value=]>

--- Incoming ---
[   u'cv.VideoCapture.get',
    u'double',
    ['/C', '/V'],
    [[u'int', u'propId', u'', []]],
    u'double']
ok: FUNC <double cv.VideoCapture.get [ARG int propId=]>

--- Incoming ---
[u'cv.VideoCapture.getBackendName', u'String', ['/C'], [], u'String']
ok: FUNC <String cv.VideoCapture.getBackendName []>

--- Incoming ---
[   u'cv.VideoCapture.setExceptionMode',
    u'void',
    [],
    [[u'bool', u'enable', u'', []]],
    u'void']
ok: FUNC <void cv.VideoCapture.setExceptionMode [ARG bool enable=]>

--- Incoming ---
[u'cv.VideoCapture.getExceptionMode', u'bool', [], [], u'bool']
ok: FUNC <bool cv.VideoCapture.getExceptionMode []>

--- Incoming ---
[u'class cv.VideoWriter', '', [], [], None]
ok: class CLASS cv::.VideoWriter : , name: VideoWriter, base: 

--- Incoming ---
[u'cv.VideoWriter.VideoWriter', '', [], [], None]
ok: FUNC < cv.VideoWriter.VideoWriter []>

--- Incoming ---
[   u'cv.VideoWriter.VideoWriter',
    '',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'fourcc', u'', []],
        [u'double', u'fps', u'', []],
        [u'Size', u'frameSize', u'', []],
        [u'bool', u'isColor', u'true', []]],
    None]
ok: FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[   u'cv.VideoWriter.VideoWriter',
    '',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'apiPreference', u'', []],
        [u'int', u'fourcc', u'', []],
        [u'double', u'fps', u'', []],
        [u'Size', u'frameSize', u'', []],
        [u'bool', u'isColor', u'true', []]],
    None]
ok: FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[   u'cv.VideoWriter.open',
    u'bool',
    ['/V'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'fourcc', u'', []],
        [u'double', u'fps', u'', []],
        [u'Size', u'frameSize', u'', []],
        [u'bool', u'isColor', u'true', []]],
    u'bool']
ok: FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[   u'cv.VideoWriter.open',
    u'bool',
    [],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'int', u'apiPreference', u'', []],
        [u'int', u'fourcc', u'', []],
        [u'double', u'fps', u'', []],
        [u'Size', u'frameSize', u'', []],
        [u'bool', u'isColor', u'true', []]],
    u'bool']
ok: FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>

--- Incoming ---
[u'cv.VideoWriter.isOpened', u'bool', ['/C', '/V'], [], u'bool']
ok: FUNC <bool cv.VideoWriter.isOpened []>

--- Incoming ---
[u'cv.VideoWriter.release', u'void', ['/V'], [], u'void']
ok: FUNC <void cv.VideoWriter.release []>

--- Incoming ---
[   u'cv.VideoWriter.write',
    u'void',
    ['/V'],
    [['Mat', u'image', '', []]],
    u'void']
ok: FUNC <void cv.VideoWriter.write [ARG Mat image=]>

--- Incoming ---
[   u'cv.VideoWriter.set',
    u'bool',
    ['/V'],
    [[u'int', u'propId', u'', []], [u'double', u'value', u'', []]],
    u'bool']
ok: FUNC <bool cv.VideoWriter.set [ARG int propId=, ARG double value=]>

--- Incoming ---
[   u'cv.VideoWriter.get',
    u'double',
    ['/C', '/V'],
    [[u'int', u'propId', u'', []]],
    u'double']
ok: FUNC <double cv.VideoWriter.get [ARG int propId=]>

--- Incoming ---
[   u'cv.VideoWriter.fourcc',
    u'int',
    ['/S'],
    [   [u'char', u'c1', u'', []],
        [u'char', u'c2', u'', []],
        [u'char', u'c3', u'', []],
        [u'char', u'c4', u'', []]],
    u'int']
ok: FUNC <int cv.VideoWriter.fourcc [ARG char c1=, ARG char c2=, ARG char c3=, ARG char c4=]>

--- Incoming ---
[u'cv.VideoWriter.getBackendName', u'String', ['/C'], [], u'String']
ok: FUNC <String cv.VideoWriter.getBackendName []>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio/registry.hpp =====
Namespaces: set(['', u'cv.videoio_registry', u'cv', u'cv.internal'])

--- Incoming ---
[   u'cv.videoio_registry.getBackendName',
    u'String',
    [],
    [[u'VideoCaptureAPIs', u'api', u'', []]],
    u'cv::String']
ok: FUNC <String cv.videoio_registry..getBackendName [ARG VideoCaptureAPIs api=]>

--- Incoming ---
[   u'cv.videoio_registry.getBackends',
    u'vector_VideoCaptureAPIs',
    [],
    [],
    u'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getBackends []>

--- Incoming ---
[   u'cv.videoio_registry.getCameraBackends',
    u'vector_VideoCaptureAPIs',
    [],
    [],
    u'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getCameraBackends []>

--- Incoming ---
[   u'cv.videoio_registry.getStreamBackends',
    u'vector_VideoCaptureAPIs',
    [],
    [],
    u'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getStreamBackends []>

--- Incoming ---
[   u'cv.videoio_registry.getWriterBackends',
    u'vector_VideoCaptureAPIs',
    [],
    [],
    u'std::vector<VideoCaptureAPIs>']
ok: FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getWriterBackends []>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio/videoio.hpp =====
Namespaces: set(['', u'cv.videoio_registry', u'cv', u'cv.internal'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/videoio/include/opencv2/videoio/videoio.hpp


===== Generating... =====
CLASS cv::.VideoWriter : 
FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java:  VideoWriter(String filename, int apiPreference, int fourcc, double fps, Size frameSize, boolean isColor)
java:  VideoWriter(String filename, int apiPreference, int fourcc, double fps, Size frameSize)
FUNC < cv.VideoWriter.VideoWriter [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java:  VideoWriter(String filename, int fourcc, double fps, Size frameSize, boolean isColor)
java:  VideoWriter(String filename, int fourcc, double fps, Size frameSize)
FUNC < cv.VideoWriter.VideoWriter []>
java:  VideoWriter()
FUNC <String cv.VideoWriter.getBackendName []>
java: String getBackendName()
FUNC <bool cv.VideoWriter.isOpened []>
java: boolean isOpened()
FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int apiPreference=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java: boolean open(String filename, int apiPreference, int fourcc, double fps, Size frameSize, boolean isColor)
java: boolean open(String filename, int apiPreference, int fourcc, double fps, Size frameSize)
FUNC <bool cv.VideoWriter.open [ARG String filename=, ARG int fourcc=, ARG double fps=, ARG Size frameSize=, ARG bool isColor=true]>
java: boolean open(String filename, int fourcc, double fps, Size frameSize, boolean isColor)
java: boolean open(String filename, int fourcc, double fps, Size frameSize)
FUNC <bool cv.VideoWriter.set [ARG int propId=, ARG double value=]>
java: boolean set(int propId, double value)
FUNC <double cv.VideoWriter.get [ARG int propId=]>
java: double get(int propId)
FUNC <int cv.VideoWriter.fourcc [ARG char c1=, ARG char c2=, ARG char c3=, ARG char c4=]>
java: int fourcc(char c1, char c2, char c3, char c4)
FUNC <void cv.VideoWriter.release []>
java: void release()
FUNC <void cv.VideoWriter.write [ARG Mat image=]>
java: void write(Mat image)
CLASS ::.Videoio : 
[CONST VIDEOWRITER_PROP_QUALITY=1, CONST VIDEOWRITER_PROP_FRAMEBYTES=2, CONST VIDEOWRITER_PROP_NSTRIPES=3]
[CONST CAP_PROP_POS_MSEC=0, CONST CAP_PROP_POS_FRAMES=1, CONST CAP_PROP_POS_AVI_RATIO=2, CONST CAP_PROP_FRAME_WIDTH=3, CONST CAP_PROP_FRAME_HEIGHT=4, CONST CAP_PROP_FPS=5, CONST CAP_PROP_FOURCC=6, CONST CAP_PROP_FRAME_COUNT=7, CONST CAP_PROP_FORMAT=8, CONST CAP_PROP_MODE=9, CONST CAP_PROP_BRIGHTNESS=10, CONST CAP_PROP_CONTRAST=11, CONST CAP_PROP_SATURATION=12, CONST CAP_PROP_HUE=13, CONST CAP_PROP_GAIN=14, CONST CAP_PROP_EXPOSURE=15, CONST CAP_PROP_CONVERT_RGB=16, CONST CAP_PROP_WHITE_BALANCE_BLUE_U=17, CONST CAP_PROP_RECTIFICATION=18, CONST CAP_PROP_MONOCHROME=19, CONST CAP_PROP_SHARPNESS=20, CONST CAP_PROP_AUTO_EXPOSURE=21, CONST CAP_PROP_GAMMA=22, CONST CAP_PROP_TEMPERATURE=23, CONST CAP_PROP_TRIGGER=24, CONST CAP_PROP_TRIGGER_DELAY=25, CONST CAP_PROP_WHITE_BALANCE_RED_V=26, CONST CAP_PROP_ZOOM=27, CONST CAP_PROP_FOCUS=28, CONST CAP_PROP_GUID=29, CONST CAP_PROP_ISO_SPEED=30, CONST CAP_PROP_BACKLIGHT=32, CONST CAP_PROP_PAN=33, CONST CAP_PROP_TILT=34, CONST CAP_PROP_ROLL=35, CONST CAP_PROP_IRIS=36, CONST CAP_PROP_SETTINGS=37, CONST CAP_PROP_BUFFERSIZE=38, CONST CAP_PROP_AUTOFOCUS=39, CONST CAP_PROP_SAR_NUM=40, CONST CAP_PROP_SAR_DEN=41, CONST CAP_PROP_BACKEND=42, CONST CAP_PROP_CHANNEL=43, CONST CAP_PROP_AUTO_WB=44, CONST CAP_PROP_WB_TEMPERATURE=45, CONST CAP_PROP_CODEC_PIXEL_FORMAT=46, CONST CAP_PROP_BITRATE=47]
[CONST CAP_ANY=0, CONST CAP_VFW=200, CONST CAP_V4L=200, CONST CAP_V4L2=CAP_V4L, CONST CAP_FIREWIRE=300, CONST CAP_FIREWARE=CAP_FIREWIRE, CONST CAP_IEEE1394=CAP_FIREWIRE, CONST CAP_DC1394=CAP_FIREWIRE, CONST CAP_CMU1394=CAP_FIREWIRE, CONST CAP_QT=500, CONST CAP_UNICAP=600, CONST CAP_DSHOW=700, CONST CAP_PVAPI=800, CONST CAP_OPENNI=900, CONST CAP_OPENNI_ASUS=910, CONST CAP_ANDROID=1000, CONST CAP_XIAPI=1100, CONST CAP_AVFOUNDATION=1200, CONST CAP_GIGANETIX=1300, CONST CAP_MSMF=1400, CONST CAP_WINRT=1410, CONST CAP_INTELPERC=1500, CONST CAP_REALSENSE=1500, CONST CAP_OPENNI2=1600, CONST CAP_OPENNI2_ASUS=1610, CONST CAP_GPHOTO2=1700, CONST CAP_GSTREAMER=1800, CONST CAP_FFMPEG=1900, CONST CAP_IMAGES=2000, CONST CAP_ARAVIS=2100, CONST CAP_OPENCV_MJPEG=2200, CONST CAP_INTEL_MFX=2300, CONST CAP_XINE=2400]
[CONST CAP_PROP_DC1394_OFF=-4, CONST CAP_PROP_DC1394_MODE_MANUAL=-3, CONST CAP_PROP_DC1394_MODE_AUTO=-2, CONST CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO=-1, CONST CAP_PROP_DC1394_MAX=31, CONST CAP_OPENNI_DEPTH_GENERATOR=1 << 31, CONST CAP_OPENNI_IMAGE_GENERATOR=1 << 30, CONST CAP_OPENNI_IR_GENERATOR=1 << 29, CONST CAP_OPENNI_GENERATORS_MASK=CAP_OPENNI_DEPTH_GENERATOR + CAP_OPENNI_IMAGE_GENERATOR + CAP_OPENNI_IR_GENERATOR, CONST CAP_PROP_OPENNI_OUTPUT_MODE=100, CONST CAP_PROP_OPENNI_FRAME_MAX_DEPTH=101, CONST CAP_PROP_OPENNI_BASELINE=102, CONST CAP_PROP_OPENNI_FOCAL_LENGTH=103, CONST CAP_PROP_OPENNI_REGISTRATION=104, CONST CAP_PROP_OPENNI_REGISTRATION_ON=CAP_PROP_OPENNI_REGISTRATION, CONST CAP_PROP_OPENNI_APPROX_FRAME_SYNC=105, CONST CAP_PROP_OPENNI_MAX_BUFFER_SIZE=106, CONST CAP_PROP_OPENNI_CIRCLE_BUFFER=107, CONST CAP_PROP_OPENNI_MAX_TIME_DURATION=108, CONST CAP_PROP_OPENNI_GENERATOR_PRESENT=109, CONST CAP_PROP_OPENNI2_SYNC=110, CONST CAP_PROP_OPENNI2_MIRROR=111, CONST CAP_OPENNI_IMAGE_GENERATOR_PRESENT=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT, CONST CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE=CAP_OPENNI_IMAGE_GENERATOR + CAP_PROP_OPENNI_OUTPUT_MODE, CONST CAP_OPENNI_DEPTH_GENERATOR_PRESENT=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT, CONST CAP_OPENNI_DEPTH_GENERATOR_BASELINE=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_BASELINE, CONST CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_FOCAL_LENGTH, CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION=CAP_OPENNI_DEPTH_GENERATOR + CAP_PROP_OPENNI_REGISTRATION, CONST CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON=CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION, CONST CAP_OPENNI_IR_GENERATOR_PRESENT=CAP_OPENNI_IR_GENERATOR + CAP_PROP_OPENNI_GENERATOR_PRESENT, CONST CAP_OPENNI_DEPTH_MAP=0, CONST CAP_OPENNI_POINT_CLOUD_MAP=1, CONST CAP_OPENNI_DISPARITY_MAP=2, CONST CAP_OPENNI_DISPARITY_MAP_32F=3, CONST CAP_OPENNI_VALID_DEPTH_MASK=4, CONST CAP_OPENNI_BGR_IMAGE=5, CONST CAP_OPENNI_GRAY_IMAGE=6, CONST CAP_OPENNI_IR_IMAGE=7, CONST CAP_OPENNI_VGA_30HZ=0, CONST CAP_OPENNI_SXGA_15HZ=1, CONST CAP_OPENNI_SXGA_30HZ=2, CONST CAP_OPENNI_QVGA_30HZ=3, CONST CAP_OPENNI_QVGA_60HZ=4, CONST CAP_PROP_GSTREAMER_QUEUE_LENGTH=200, CONST CAP_PROP_PVAPI_MULTICASTIP=300, CONST CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE=301, CONST CAP_PROP_PVAPI_DECIMATIONHORIZONTAL=302, CONST CAP_PROP_PVAPI_DECIMATIONVERTICAL=303, CONST CAP_PROP_PVAPI_BINNINGX=304, CONST CAP_PROP_PVAPI_BINNINGY=305, CONST CAP_PROP_PVAPI_PIXELFORMAT=306, CONST CAP_PVAPI_FSTRIGMODE_FREERUN=0, CONST CAP_PVAPI_FSTRIGMODE_SYNCIN1=1, CONST CAP_PVAPI_FSTRIGMODE_SYNCIN2=2, CONST CAP_PVAPI_FSTRIGMODE_FIXEDRATE=3, CONST CAP_PVAPI_FSTRIGMODE_SOFTWARE=4, CONST CAP_PVAPI_DECIMATION_OFF=1, CONST CAP_PVAPI_DECIMATION_2OUTOF4=2, CONST CAP_PVAPI_DECIMATION_2OUTOF8=4, CONST CAP_PVAPI_DECIMATION_2OUTOF16=8, CONST CAP_PVAPI_PIXELFORMAT_MONO8=1, CONST CAP_PVAPI_PIXELFORMAT_MONO16=2, CONST CAP_PVAPI_PIXELFORMAT_BAYER8=3, CONST CAP_PVAPI_PIXELFORMAT_BAYER16=4, CONST CAP_PVAPI_PIXELFORMAT_RGB24=5, CONST CAP_PVAPI_PIXELFORMAT_BGR24=6, CONST CAP_PVAPI_PIXELFORMAT_RGBA32=7, CONST CAP_PVAPI_PIXELFORMAT_BGRA32=8, CONST CAP_PROP_XI_DOWNSAMPLING=400, CONST CAP_PROP_XI_DATA_FORMAT=401, CONST CAP_PROP_XI_OFFSET_X=402, CONST CAP_PROP_XI_OFFSET_Y=403, CONST CAP_PROP_XI_TRG_SOURCE=404, CONST CAP_PROP_XI_TRG_SOFTWARE=405, CONST CAP_PROP_XI_GPI_SELECTOR=406, CONST CAP_PROP_XI_GPI_MODE=407, CONST CAP_PROP_XI_GPI_LEVEL=408, CONST CAP_PROP_XI_GPO_SELECTOR=409, CONST CAP_PROP_XI_GPO_MODE=410, CONST CAP_PROP_XI_LED_SELECTOR=411, CONST CAP_PROP_XI_LED_MODE=412, CONST CAP_PROP_XI_MANUAL_WB=413, CONST CAP_PROP_XI_AUTO_WB=414, CONST CAP_PROP_XI_AEAG=415, CONST CAP_PROP_XI_EXP_PRIORITY=416, CONST CAP_PROP_XI_AE_MAX_LIMIT=417, CONST CAP_PROP_XI_AG_MAX_LIMIT=418, CONST CAP_PROP_XI_AEAG_LEVEL=419, CONST CAP_PROP_XI_TIMEOUT=420, CONST CAP_PROP_XI_EXPOSURE=421, CONST CAP_PROP_XI_EXPOSURE_BURST_COUNT=422, CONST CAP_PROP_XI_GAIN_SELECTOR=423, CONST CAP_PROP_XI_GAIN=424, CONST CAP_PROP_XI_DOWNSAMPLING_TYPE=426, CONST CAP_PROP_XI_BINNING_SELECTOR=427, CONST CAP_PROP_XI_BINNING_VERTICAL=428, CONST CAP_PROP_XI_BINNING_HORIZONTAL=429, CONST CAP_PROP_XI_BINNING_PATTERN=430, CONST CAP_PROP_XI_DECIMATION_SELECTOR=431, CONST CAP_PROP_XI_DECIMATION_VERTICAL=432, CONST CAP_PROP_XI_DECIMATION_HORIZONTAL=433, CONST CAP_PROP_XI_DECIMATION_PATTERN=434, CONST CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR=587, CONST CAP_PROP_XI_TEST_PATTERN=588, CONST CAP_PROP_XI_IMAGE_DATA_FORMAT=435, CONST CAP_PROP_XI_SHUTTER_TYPE=436, CONST CAP_PROP_XI_SENSOR_TAPS=437, CONST CAP_PROP_XI_AEAG_ROI_OFFSET_X=439, CONST CAP_PROP_XI_AEAG_ROI_OFFSET_Y=440, CONST CAP_PROP_XI_AEAG_ROI_WIDTH=441, CONST CAP_PROP_XI_AEAG_ROI_HEIGHT=442, CONST CAP_PROP_XI_BPC=445, CONST CAP_PROP_XI_WB_KR=448, CONST CAP_PROP_XI_WB_KG=449, CONST CAP_PROP_XI_WB_KB=450, CONST CAP_PROP_XI_WIDTH=451, CONST CAP_PROP_XI_HEIGHT=452, CONST CAP_PROP_XI_REGION_SELECTOR=589, CONST CAP_PROP_XI_REGION_MODE=595, CONST CAP_PROP_XI_LIMIT_BANDWIDTH=459, CONST CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH=460, CONST CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH=461, CONST CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH=462, CONST CAP_PROP_XI_OUTPUT_DATA_PACKING=463, CONST CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE=464, CONST CAP_PROP_XI_IS_COOLED=465, CONST CAP_PROP_XI_COOLING=466, CONST CAP_PROP_XI_TARGET_TEMP=467, CONST CAP_PROP_XI_CHIP_TEMP=468, CONST CAP_PROP_XI_HOUS_TEMP=469, CONST CAP_PROP_XI_HOUS_BACK_SIDE_TEMP=590, CONST CAP_PROP_XI_SENSOR_BOARD_TEMP=596, CONST CAP_PROP_XI_CMS=470, CONST CAP_PROP_XI_APPLY_CMS=471, CONST CAP_PROP_XI_IMAGE_IS_COLOR=474, CONST CAP_PROP_XI_COLOR_FILTER_ARRAY=475, CONST CAP_PROP_XI_GAMMAY=476, CONST CAP_PROP_XI_GAMMAC=477, CONST CAP_PROP_XI_SHARPNESS=478, CONST CAP_PROP_XI_CC_MATRIX_00=479, CONST CAP_PROP_XI_CC_MATRIX_01=480, CONST CAP_PROP_XI_CC_MATRIX_02=481, CONST CAP_PROP_XI_CC_MATRIX_03=482, CONST CAP_PROP_XI_CC_MATRIX_10=483, CONST CAP_PROP_XI_CC_MATRIX_11=484, CONST CAP_PROP_XI_CC_MATRIX_12=485, CONST CAP_PROP_XI_CC_MATRIX_13=486, CONST CAP_PROP_XI_CC_MATRIX_20=487, CONST CAP_PROP_XI_CC_MATRIX_21=488, CONST CAP_PROP_XI_CC_MATRIX_22=489, CONST CAP_PROP_XI_CC_MATRIX_23=490, CONST CAP_PROP_XI_CC_MATRIX_30=491, CONST CAP_PROP_XI_CC_MATRIX_31=492, CONST CAP_PROP_XI_CC_MATRIX_32=493, CONST CAP_PROP_XI_CC_MATRIX_33=494, CONST CAP_PROP_XI_DEFAULT_CC_MATRIX=495, CONST CAP_PROP_XI_TRG_SELECTOR=498, CONST CAP_PROP_XI_ACQ_FRAME_BURST_COUNT=499, CONST CAP_PROP_XI_DEBOUNCE_EN=507, CONST CAP_PROP_XI_DEBOUNCE_T0=508, CONST CAP_PROP_XI_DEBOUNCE_T1=509, CONST CAP_PROP_XI_DEBOUNCE_POL=510, CONST CAP_PROP_XI_LENS_MODE=511, CONST CAP_PROP_XI_LENS_APERTURE_VALUE=512, CONST CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE=513, CONST CAP_PROP_XI_LENS_FOCUS_MOVE=514, CONST CAP_PROP_XI_LENS_FOCUS_DISTANCE=515, CONST CAP_PROP_XI_LENS_FOCAL_LENGTH=516, CONST CAP_PROP_XI_LENS_FEATURE_SELECTOR=517, CONST CAP_PROP_XI_LENS_FEATURE=518, CONST CAP_PROP_XI_DEVICE_MODEL_ID=521, CONST CAP_PROP_XI_DEVICE_SN=522, CONST CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA=529, CONST CAP_PROP_XI_IMAGE_PAYLOAD_SIZE=530, CONST CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT=531, CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ=532, CONST CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX=533, CONST CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT=534, CONST CAP_PROP_XI_FRAMERATE=535, CONST CAP_PROP_XI_COUNTER_SELECTOR=536, CONST CAP_PROP_XI_COUNTER_VALUE=537, CONST CAP_PROP_XI_ACQ_TIMING_MODE=538, CONST CAP_PROP_XI_AVAILABLE_BANDWIDTH=539, CONST CAP_PROP_XI_BUFFER_POLICY=540, CONST CAP_PROP_XI_LUT_EN=541, CONST CAP_PROP_XI_LUT_INDEX=542, CONST CAP_PROP_XI_LUT_VALUE=543, CONST CAP_PROP_XI_TRG_DELAY=544, CONST CAP_PROP_XI_TS_RST_MODE=545, CONST CAP_PROP_XI_TS_RST_SOURCE=546, CONST CAP_PROP_XI_IS_DEVICE_EXIST=547, CONST CAP_PROP_XI_ACQ_BUFFER_SIZE=548, CONST CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT=549, CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE=550, CONST CAP_PROP_XI_BUFFERS_QUEUE_SIZE=551, CONST CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT=552, CONST CAP_PROP_XI_RECENT_FRAME=553, CONST CAP_PROP_XI_DEVICE_RESET=554, CONST CAP_PROP_XI_COLUMN_FPN_CORRECTION=555, CONST CAP_PROP_XI_ROW_FPN_CORRECTION=591, CONST CAP_PROP_XI_SENSOR_MODE=558, CONST CAP_PROP_XI_HDR=559, CONST CAP_PROP_XI_HDR_KNEEPOINT_COUNT=560, CONST CAP_PROP_XI_HDR_T1=561, CONST CAP_PROP_XI_HDR_T2=562, CONST CAP_PROP_XI_KNEEPOINT1=563, CONST CAP_PROP_XI_KNEEPOINT2=564, CONST CAP_PROP_XI_IMAGE_BLACK_LEVEL=565, CONST CAP_PROP_XI_HW_REVISION=571, CONST CAP_PROP_XI_DEBUG_LEVEL=572, CONST CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION=573, CONST CAP_PROP_XI_FFS_FILE_ID=594, CONST CAP_PROP_XI_FFS_FILE_SIZE=580, CONST CAP_PROP_XI_FREE_FFS_SIZE=581, CONST CAP_PROP_XI_USED_FFS_SIZE=582, CONST CAP_PROP_XI_FFS_ACCESS_KEY=583, CONST CAP_PROP_XI_SENSOR_FEATURE_SELECTOR=585, CONST CAP_PROP_XI_SENSOR_FEATURE_VALUE=586, CONST CAP_PROP_ARAVIS_AUTOTRIGGER=600, CONST CAP_PROP_IOS_DEVICE_FOCUS=9001, CONST CAP_PROP_IOS_DEVICE_EXPOSURE=9002, CONST CAP_PROP_IOS_DEVICE_FLASH=9003, CONST CAP_PROP_IOS_DEVICE_WHITEBALANCE=9004, CONST CAP_PROP_IOS_DEVICE_TORCH=9005, CONST CAP_PROP_GIGA_FRAME_OFFSET_X=10001, CONST CAP_PROP_GIGA_FRAME_OFFSET_Y=10002, CONST CAP_PROP_GIGA_FRAME_WIDTH_MAX=10003, CONST CAP_PROP_GIGA_FRAME_HEIGH_MAX=10004, CONST CAP_PROP_GIGA_FRAME_SENS_WIDTH=10005, CONST CAP_PROP_GIGA_FRAME_SENS_HEIGH=10006, CONST CAP_PROP_INTELPERC_PROFILE_COUNT=11001, CONST CAP_PROP_INTELPERC_PROFILE_IDX=11002, CONST CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE=11003, CONST CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE=11004, CONST CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD=11005, CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ=11006, CONST CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT=11007, CONST CAP_INTELPERC_DEPTH_GENERATOR=1 << 29, CONST CAP_INTELPERC_IMAGE_GENERATOR=1 << 28, CONST CAP_INTELPERC_IR_GENERATOR=1 << 27, CONST CAP_INTELPERC_GENERATORS_MASK=CAP_INTELPERC_DEPTH_GENERATOR + CAP_INTELPERC_IMAGE_GENERATOR + CAP_INTELPERC_IR_GENERATOR, CONST CAP_INTELPERC_DEPTH_MAP=0, CONST CAP_INTELPERC_UVDEPTH_MAP=1, CONST CAP_INTELPERC_IR_MAP=2, CONST CAP_INTELPERC_IMAGE=3, CONST CAP_PROP_GPHOTO2_PREVIEW=17001, CONST CAP_PROP_GPHOTO2_WIDGET_ENUMERATE=17002, CONST CAP_PROP_GPHOTO2_RELOAD_CONFIG=17003, CONST CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE=17004, CONST CAP_PROP_GPHOTO2_COLLECT_MSGS=17005, CONST CAP_PROP_GPHOTO2_FLUSH_MSGS=17006, CONST CAP_PROP_SPEED=17007, CONST CAP_PROP_APERTURE=17008, CONST CAP_PROP_EXPOSUREPROGRAM=17009, CONST CAP_PROP_VIEWFINDER=17010, CONST CAP_PROP_IMAGES_BASE=18000, CONST CAP_PROP_IMAGES_LAST=19000]
FUNC <String cv.videoio_registry..getBackendName [ARG VideoCaptureAPIs api=]>
java: String getBackendName(int api)
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getBackends()	 due to RET type vector_VideoCaptureAPIs
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getCameraBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getCameraBackends()	 due to RET type vector_VideoCaptureAPIs
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getStreamBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getStreamBackends()	 due to RET type vector_VideoCaptureAPIs
FUNC <vector_VideoCaptureAPIs cv.videoio_registry..getWriterBackends []>
SKIP:vector_VideoCaptureAPIs cv::videoio_registry::getWriterBackends()	 due to RET type vector_VideoCaptureAPIs
CLASS cv::.VideoCapture : 
FUNC < cv.VideoCapture.VideoCapture []>
java:  VideoCapture()
FUNC <explicit cv.VideoCapture.VideoCapture [ARG String filename=, ARG int apiPreference=CAP_ANY]>
SKIP:explicit cv::VideoCapture::VideoCapture(String filename, int apiPreference = CAP_ANY)	 due to RET type explicit
FUNC <explicit cv.VideoCapture.VideoCapture [ARG int index=, ARG int apiPreference=CAP_ANY]>
SKIP:explicit cv::VideoCapture::VideoCapture(int index, int apiPreference = CAP_ANY)	 due to RET type explicit
FUNC <String cv.VideoCapture.getBackendName []>
java: String getBackendName()
FUNC <bool cv.VideoCapture.getExceptionMode []>
java: boolean getExceptionMode()
FUNC <bool cv.VideoCapture.grab []>
java: boolean grab()
FUNC <bool cv.VideoCapture.isOpened []>
java: boolean isOpened()
FUNC <bool cv.VideoCapture.open [ARG String filename=, ARG int apiPreference=CAP_ANY]>
java: boolean open(String filename, int apiPreference)
java: boolean open(String filename)
FUNC <bool cv.VideoCapture.open [ARG int index=, ARG int apiPreference=CAP_ANY]>
java: boolean open(int index, int apiPreference)
java: boolean open(int index)
FUNC <bool cv.VideoCapture.read [ARG Mat image=]>
java: boolean read(Mat image)
FUNC <bool cv.VideoCapture.retrieve [ARG Mat image=, ARG int flag=0]>
java: boolean retrieve(Mat image, int flag)
java: boolean retrieve(Mat image)
FUNC <bool cv.VideoCapture.set [ARG int propId=, ARG double value=]>
java: boolean set(int propId, double value)
FUNC <double cv.VideoCapture.get [ARG int propId=]>
java: double get(int propId)
FUNC <void cv.VideoCapture.release []>
java: void release()
FUNC <void cv.VideoCapture.setExceptionMode [ARG bool enable=]>
java: void setExceptionMode(boolean enable)

=== MODULE: calib3d (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/calib3d) ===


Files (3):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/calib3d/include/opencv2/calib3d/calib3d_c.h',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/calib3d/include/opencv2/calib3d.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/calib3d/include/opencv2/calib3d/calib3d.hpp']

Common headers (0):
[]
ok: class CLASS ::.Calib3d : , name: Calib3d, base: 


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/calib3d/include/opencv2/calib3d/calib3d_c.h =====
Namespaces: set([''])

--- Incoming ---
[   u'enum <unnamed>',
    '',
    [],
    [   [u'const CV_ITERATIVE', u'0', [], [], None, ''],
        [u'const CV_EPNP', u'1', [], [], None, ''],
        [u'const CV_P3P', u'2', [], [], None, ''],
        [u'const CV_DLS', u'3', [], [], None, '']],
    None]
ok: CONST CV_ITERATIVE=0
ok: CONST CV_EPNP=1
ok: CONST CV_P3P=2
ok: CONST CV_DLS=3

--- Incoming ---
[   u'enum CvLevMarq.<unnamed>',
    '',
    [],
    [   [u'const CvLevMarq.DONE', u'0', [], [], None, ''],
        [u'const CvLevMarq.STARTED', u'1', [], [], None, ''],
        [u'const CvLevMarq.CALC_J', u'2', [], [], None, ''],
        [u'const CvLevMarq.CHECK_ERR', u'3', [], [], None, '']],
    None]
class not found: CONST DONE=0
ok: CONST CvLevMarq_DONE=0
class not found: CONST STARTED=1
ok: CONST CvLevMarq_STARTED=1
class not found: CONST CALC_J=2
ok: CONST CvLevMarq_CALC_J=2
class not found: CONST CHECK_ERR=3
ok: CONST CvLevMarq_CHECK_ERR=3


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/calib3d/include/opencv2/calib3d.hpp =====
Namespaces: set(['', u'cv.fisheye', u'cv'])

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.LMEDS', u'4', [], [], None, ''],
        [u'const cv.RANSAC', u'8', [], [], None, ''],
        [u'const cv.RHO', u'16', [], [], None, '']],
    None]
ok: CONST LMEDS=4
ok: CONST RANSAC=8
ok: CONST RHO=16

--- Incoming ---
[   u'enum cv.SolvePnPMethod',
    '',
    [],
    [   [u'const cv.SOLVEPNP_ITERATIVE', u'0', [], [], None, ''],
        [u'const cv.SOLVEPNP_EPNP', u'1', [], [], None, ''],
        [u'const cv.SOLVEPNP_P3P', u'2', [], [], None, ''],
        [u'const cv.SOLVEPNP_DLS', u'3', [], [], None, ''],
        [u'const cv.SOLVEPNP_UPNP', u'4', [], [], None, ''],
        [u'const cv.SOLVEPNP_AP3P', u'5', [], [], None, ''],
        [u'const cv.SOLVEPNP_IPPE', u'6', [], [], None, ''],
        [u'const cv.SOLVEPNP_IPPE_SQUARE', u'7', [], [], None, ''],
        [u'const cv.SOLVEPNP_MAX_COUNT', u'7+1', [], [], None, '']],
    None]
ok: CONST SOLVEPNP_ITERATIVE=0
ok: CONST SOLVEPNP_EPNP=1
ok: CONST SOLVEPNP_P3P=2
ok: CONST SOLVEPNP_DLS=3
ok: CONST SOLVEPNP_UPNP=4
ok: CONST SOLVEPNP_AP3P=5
ok: CONST SOLVEPNP_IPPE=6
ok: CONST SOLVEPNP_IPPE_SQUARE=7
ok: CONST SOLVEPNP_MAX_COUNT=7+1

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CALIB_CB_ADAPTIVE_THRESH', u'1', [], [], None, ''],
        [u'const cv.CALIB_CB_NORMALIZE_IMAGE', u'2', [], [], None, ''],
        [u'const cv.CALIB_CB_FILTER_QUADS', u'4', [], [], None, ''],
        [u'const cv.CALIB_CB_FAST_CHECK', u'8', [], [], None, ''],
        [u'const cv.CALIB_CB_EXHAUSTIVE', u'16', [], [], None, ''],
        [u'const cv.CALIB_CB_ACCURACY', u'32', [], [], None, ''],
        [u'const cv.CALIB_CB_LARGER', u'64', [], [], None, ''],
        [u'const cv.CALIB_CB_MARKER', u'128', [], [], None, '']],
    None]
ok: CONST CALIB_CB_ADAPTIVE_THRESH=1
ok: CONST CALIB_CB_NORMALIZE_IMAGE=2
ok: CONST CALIB_CB_FILTER_QUADS=4
ok: CONST CALIB_CB_FAST_CHECK=8
ok: CONST CALIB_CB_EXHAUSTIVE=16
ok: CONST CALIB_CB_ACCURACY=32
ok: CONST CALIB_CB_LARGER=64
ok: CONST CALIB_CB_MARKER=128

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CALIB_CB_SYMMETRIC_GRID', u'1', [], [], None, ''],
        [u'const cv.CALIB_CB_ASYMMETRIC_GRID', u'2', [], [], None, ''],
        [u'const cv.CALIB_CB_CLUSTERING', u'4', [], [], None, '']],
    None]
ok: CONST CALIB_CB_SYMMETRIC_GRID=1
ok: CONST CALIB_CB_ASYMMETRIC_GRID=2
ok: CONST CALIB_CB_CLUSTERING=4

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CALIB_NINTRINSIC', u'18', [], [], None, ''],
        [u'const cv.CALIB_USE_INTRINSIC_GUESS', u'0x00001', [], [], None, ''],
        [u'const cv.CALIB_FIX_ASPECT_RATIO', u'0x00002', [], [], None, ''],
        [u'const cv.CALIB_FIX_PRINCIPAL_POINT', u'0x00004', [], [], None, ''],
        [u'const cv.CALIB_ZERO_TANGENT_DIST', u'0x00008', [], [], None, ''],
        [u'const cv.CALIB_FIX_FOCAL_LENGTH', u'0x00010', [], [], None, ''],
        [u'const cv.CALIB_FIX_K1', u'0x00020', [], [], None, ''],
        [u'const cv.CALIB_FIX_K2', u'0x00040', [], [], None, ''],
        [u'const cv.CALIB_FIX_K3', u'0x00080', [], [], None, ''],
        [u'const cv.CALIB_FIX_K4', u'0x00800', [], [], None, ''],
        [u'const cv.CALIB_FIX_K5', u'0x01000', [], [], None, ''],
        [u'const cv.CALIB_FIX_K6', u'0x02000', [], [], None, ''],
        [u'const cv.CALIB_RATIONAL_MODEL', u'0x04000', [], [], None, ''],
        [u'const cv.CALIB_THIN_PRISM_MODEL', u'0x08000', [], [], None, ''],
        [u'const cv.CALIB_FIX_S1_S2_S3_S4', u'0x10000', [], [], None, ''],
        [u'const cv.CALIB_TILTED_MODEL', u'0x40000', [], [], None, ''],
        [u'const cv.CALIB_FIX_TAUX_TAUY', u'0x80000', [], [], None, ''],
        [u'const cv.CALIB_USE_QR', u'0x100000', [], [], None, ''],
        [u'const cv.CALIB_FIX_TANGENT_DIST', u'0x200000', [], [], None, ''],
        [u'const cv.CALIB_FIX_INTRINSIC', u'0x00100', [], [], None, ''],
        [u'const cv.CALIB_SAME_FOCAL_LENGTH', u'0x00200', [], [], None, ''],
        [u'const cv.CALIB_ZERO_DISPARITY', u'0x00400', [], [], None, ''],
        [u'const cv.CALIB_USE_LU', u'(1 << 17)', [], [], None, ''],
        [   u'const cv.CALIB_USE_EXTRINSIC_GUESS',
            u'(1 << 22)',
            [],
            [],
            None,
            '']],
    None]
ok: CONST CALIB_NINTRINSIC=18
ok: CONST CALIB_USE_INTRINSIC_GUESS=0x00001
ok: CONST CALIB_FIX_ASPECT_RATIO=0x00002
ok: CONST CALIB_FIX_PRINCIPAL_POINT=0x00004
ok: CONST CALIB_ZERO_TANGENT_DIST=0x00008
ok: CONST CALIB_FIX_FOCAL_LENGTH=0x00010
ok: CONST CALIB_FIX_K1=0x00020
ok: CONST CALIB_FIX_K2=0x00040
ok: CONST CALIB_FIX_K3=0x00080
ok: CONST CALIB_FIX_K4=0x00800
ok: CONST CALIB_FIX_K5=0x01000
ok: CONST CALIB_FIX_K6=0x02000
ok: CONST CALIB_RATIONAL_MODEL=0x04000
ok: CONST CALIB_THIN_PRISM_MODEL=0x08000
ok: CONST CALIB_FIX_S1_S2_S3_S4=0x10000
ok: CONST CALIB_TILTED_MODEL=0x40000
ok: CONST CALIB_FIX_TAUX_TAUY=0x80000
ok: CONST CALIB_USE_QR=0x100000
ok: CONST CALIB_FIX_TANGENT_DIST=0x200000
ok: CONST CALIB_FIX_INTRINSIC=0x00100
ok: CONST CALIB_SAME_FOCAL_LENGTH=0x00200
ok: CONST CALIB_ZERO_DISPARITY=0x00400
ok: CONST CALIB_USE_LU=(1 << 17)
ok: CONST CALIB_USE_EXTRINSIC_GUESS=(1 << 22)

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.FM_7POINT', u'1', [], [], None, ''],
        [u'const cv.FM_8POINT', u'2', [], [], None, ''],
        [u'const cv.FM_LMEDS', u'4', [], [], None, ''],
        [u'const cv.FM_RANSAC', u'8', [], [], None, '']],
    None]
ok: CONST FM_7POINT=1
ok: CONST FM_8POINT=2
ok: CONST FM_LMEDS=4
ok: CONST FM_RANSAC=8

--- Incoming ---
[   u'enum cv.HandEyeCalibrationMethod',
    '',
    [],
    [   [u'const cv.CALIB_HAND_EYE_TSAI', u'0', [], [], None, ''],
        [u'const cv.CALIB_HAND_EYE_PARK', u'1', [], [], None, ''],
        [u'const cv.CALIB_HAND_EYE_HORAUD', u'2', [], [], None, ''],
        [u'const cv.CALIB_HAND_EYE_ANDREFF', u'3', [], [], None, ''],
        [u'const cv.CALIB_HAND_EYE_DANIILIDIS', u'4', [], [], None, '']],
    None]
ok: CONST CALIB_HAND_EYE_TSAI=0
ok: CONST CALIB_HAND_EYE_PARK=1
ok: CONST CALIB_HAND_EYE_HORAUD=2
ok: CONST CALIB_HAND_EYE_ANDREFF=3
ok: CONST CALIB_HAND_EYE_DANIILIDIS=4

--- Incoming ---
[   u'cv.Rodrigues',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'jacobian', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv..Rodrigues [ARG Mat src=, ARG Mat dst=, ARG Mat jacobian=Mat()]>

--- Incoming ---
[   u'cv.findHomography',
    u'Mat',
    [],
    [   ['Mat', u'srcPoints', '', []],
        ['Mat', u'dstPoints', '', []],
        [u'int', u'method', u'0', []],
        [u'double', u'ransacReprojThreshold', u'3', []],
        ['Mat', u'mask', u'Mat()', ['/O']],
        [u'int', u'maxIters', u'2000', ['/C']],
        [u'double', u'confidence', u'0.995', ['/C']]],
    u'Mat']
ok: FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG int method=0, ARG double ransacReprojThreshold=3, ARG Mat mask=Mat(), ARG int maxIters=2000, ARG double confidence=0.995]>

--- Incoming ---
[   u'cv.RQDecomp3x3',
    u'Vec3d',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'mtxR', '', ['/O']],
        ['Mat', u'mtxQ', '', ['/O']],
        ['Mat', u'Qx', u'Mat()', ['/O']],
        ['Mat', u'Qy', u'Mat()', ['/O']],
        ['Mat', u'Qz', u'Mat()', ['/O']]],
    u'Vec3d']
ok: FUNC <Vec3d cv..RQDecomp3x3 [ARG Mat src=, ARG Mat mtxR=, ARG Mat mtxQ=, ARG Mat Qx=Mat(), ARG Mat Qy=Mat(), ARG Mat Qz=Mat()]>

--- Incoming ---
[   u'cv.decomposeProjectionMatrix',
    u'void',
    [],
    [   ['Mat', u'projMatrix', '', []],
        ['Mat', u'cameraMatrix', '', ['/O']],
        ['Mat', u'rotMatrix', '', ['/O']],
        ['Mat', u'transVect', '', ['/O']],
        ['Mat', u'rotMatrixX', u'Mat()', ['/O']],
        ['Mat', u'rotMatrixY', u'Mat()', ['/O']],
        ['Mat', u'rotMatrixZ', u'Mat()', ['/O']],
        ['Mat', u'eulerAngles', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv..decomposeProjectionMatrix [ARG Mat projMatrix=, ARG Mat cameraMatrix=, ARG Mat rotMatrix=, ARG Mat transVect=, ARG Mat rotMatrixX=Mat(), ARG Mat rotMatrixY=Mat(), ARG Mat rotMatrixZ=Mat(), ARG Mat eulerAngles=Mat()]>

--- Incoming ---
[   u'cv.matMulDeriv',
    u'void',
    [],
    [   ['Mat', u'A', '', []],
        ['Mat', u'B', '', []],
        ['Mat', u'dABdA', '', ['/O']],
        ['Mat', u'dABdB', '', ['/O']]],
    u'void']
ok: FUNC <void cv..matMulDeriv [ARG Mat A=, ARG Mat B=, ARG Mat dABdA=, ARG Mat dABdB=]>

--- Incoming ---
[   u'cv.composeRT',
    u'void',
    [],
    [   ['Mat', u'rvec1', '', []],
        ['Mat', u'tvec1', '', []],
        ['Mat', u'rvec2', '', []],
        ['Mat', u'tvec2', '', []],
        ['Mat', u'rvec3', '', ['/O']],
        ['Mat', u'tvec3', '', ['/O']],
        ['Mat', u'dr3dr1', u'Mat()', ['/O']],
        ['Mat', u'dr3dt1', u'Mat()', ['/O']],
        ['Mat', u'dr3dr2', u'Mat()', ['/O']],
        ['Mat', u'dr3dt2', u'Mat()', ['/O']],
        ['Mat', u'dt3dr1', u'Mat()', ['/O']],
        ['Mat', u'dt3dt1', u'Mat()', ['/O']],
        ['Mat', u'dt3dr2', u'Mat()', ['/O']],
        ['Mat', u'dt3dt2', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv..composeRT [ARG Mat rvec1=, ARG Mat tvec1=, ARG Mat rvec2=, ARG Mat tvec2=, ARG Mat rvec3=, ARG Mat tvec3=, ARG Mat dr3dr1=Mat(), ARG Mat dr3dt1=Mat(), ARG Mat dr3dr2=Mat(), ARG Mat dr3dt2=Mat(), ARG Mat dt3dr1=Mat(), ARG Mat dt3dt1=Mat(), ARG Mat dt3dr2=Mat(), ARG Mat dt3dt2=Mat()]>

--- Incoming ---
[   u'cv.projectPoints',
    u'void',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'rvec', '', []],
        ['Mat', u'tvec', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'imagePoints', '', ['/O']],
        ['Mat', u'jacobian', u'Mat()', ['/O']],
        [u'double', u'aspectRatio', u'0', []]],
    u'void']
ok: FUNC <void cv..projectPoints [ARG vector_Point3f objectPoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG vector_Point2f imagePoints=, ARG Mat jacobian=Mat(), ARG double aspectRatio=0]>

--- Incoming ---
[   u'cv.solvePnP',
    u'bool',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/O']],
        ['Mat', u'tvec', '', ['/O']],
        [u'bool', u'useExtrinsicGuess', u'false', []],
        [u'int', u'flags', u'SOLVEPNP_ITERATIVE', []]],
    u'bool']
ok: FUNC <bool cv..solvePnP [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int flags=SOLVEPNP_ITERATIVE]>

--- Incoming ---
[   u'cv.solvePnPRansac',
    u'bool',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/O']],
        ['Mat', u'tvec', '', ['/O']],
        [u'bool', u'useExtrinsicGuess', u'false', []],
        [u'int', u'iterationsCount', u'100', []],
        [u'float', u'reprojectionError', u'8.0', []],
        [u'double', u'confidence', u'0.99', []],
        ['Mat', u'inliers', u'Mat()', ['/O']],
        [u'int', u'flags', u'SOLVEPNP_ITERATIVE', []]],
    u'bool']
ok: FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int iterationsCount=100, ARG float reprojectionError=8.0, ARG double confidence=0.99, ARG Mat inliers=Mat(), ARG int flags=SOLVEPNP_ITERATIVE]>

--- Incoming ---
[   u'cv.solveP3P',
    u'int',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        [u'int', u'flags', u'', []]],
    u'int']
ok: FUNC <int cv..solveP3P [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=]>

--- Incoming ---
[   u'cv.solvePnPRefineLM',
    u'void',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/IO']],
        ['Mat', u'tvec', '', ['/IO']],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON)',
            []]],
    u'void']
ok: FUNC <void cv..solvePnPRefineLM [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON)]>

--- Incoming ---
[   u'cv.solvePnPRefineVVS',
    u'void',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', ['/IO']],
        ['Mat', u'tvec', '', ['/IO']],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON)',
            []],
        [u'double', u'VVSlambda', u'1', []]],
    u'void']
ok: FUNC <void cv..solvePnPRefineVVS [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON), ARG double VVSlambda=1]>

--- Incoming ---
[   u'cv.solvePnPGeneric',
    u'int',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        [u'bool', u'useExtrinsicGuess', u'false', []],
        [u'SolvePnPMethod', u'flags', u'SOLVEPNP_ITERATIVE', []],
        ['Mat', u'rvec', u'Mat()', []],
        ['Mat', u'tvec', u'Mat()', []],
        ['Mat', u'reprojectionError', u'Mat()', ['/O']]],
    u'int']
ok: FUNC <int cv..solvePnPGeneric [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG bool useExtrinsicGuess=false, ARG SolvePnPMethod flags=SOLVEPNP_ITERATIVE, ARG Mat rvec=Mat(), ARG Mat tvec=Mat(), ARG Mat reprojectionError=Mat()]>

--- Incoming ---
[   u'cv.initCameraMatrix2D',
    u'Mat',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'double', u'aspectRatio', u'1.0', []]],
    u'Mat']
ok: FUNC <Mat cv..initCameraMatrix2D [ARG vector_vector_Point3f objectPoints=, ARG vector_vector_Point2f imagePoints=, ARG Size imageSize=, ARG double aspectRatio=1.0]>

--- Incoming ---
[   u'cv.findChessboardCorners',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'corners', '', ['/O']],
        [   u'int',
            u'flags',
            u'CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE',
            []]],
    u'bool']
ok: FUNC <bool cv..findChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE]>

--- Incoming ---
[   u'cv.checkChessboard',
    u'bool',
    [],
    [['Mat', u'img', '', []], [u'Size', u'size', u'', []]],
    u'bool']
ok: FUNC <bool cv..checkChessboard [ARG Mat img=, ARG Size size=]>

--- Incoming ---
[   u'cv.findChessboardCornersSB',
    u'bool',
    [u'=findChessboardCornersSBWithMeta'],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'corners', '', ['/O']],
        [u'int', u'flags', u'', []],
        ['Mat', u'meta', '', ['/O']]],
    u'bool']
ok: FUNC <bool cv..findChessboardCornersSB [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG int flags=, ARG Mat meta=]>

--- Incoming ---
[   u'cv.findChessboardCornersSB',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'corners', '', ['/O']],
        [u'int', u'flags', u'0', []]],
    u'bool']
ok: FUNC <bool cv..findChessboardCornersSB [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG int flags=0]>

--- Incoming ---
[   u'cv.estimateChessboardSharpness',
    u'Scalar',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'corners', '', []],
        [u'float', u'rise_distance', u'0.8F', []],
        [u'bool', u'vertical', u'false', []],
        ['Mat', u'sharpness', u'Mat()', ['/O']]],
    u'Scalar']
ok: FUNC <Scalar cv..estimateChessboardSharpness [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG float rise_distance=0.8F, ARG bool vertical=false, ARG Mat sharpness=Mat()]>

--- Incoming ---
[   u'cv.find4QuadCornerSubpix',
    u'bool',
    [],
    [   ['Mat', u'img', '', []],
        ['Mat', u'corners', '', ['/IO']],
        [u'Size', u'region_size', u'', []]],
    u'bool']
ok: FUNC <bool cv..find4QuadCornerSubpix [ARG Mat img=, ARG Mat corners=, ARG Size region_size=]>

--- Incoming ---
[   u'cv.drawChessboardCorners',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'corners', '', []],
        [u'bool', u'patternWasFound', u'', []]],
    u'void']
ok: FUNC <void cv..drawChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG bool patternWasFound=]>

--- Incoming ---
[   u'cv.drawFrameAxes',
    u'void',
    [],
    [   ['Mat', u'image', '', ['/IO']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'rvec', '', []],
        ['Mat', u'tvec', '', []],
        [u'float', u'length', u'', []],
        [u'int', u'thickness', u'3', []]],
    u'void']
ok: FUNC <void cv..drawFrameAxes [ARG Mat image=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG float length=, ARG int thickness=3]>

--- Incoming ---
[   u'struct cv.CirclesGridFinderParameters',
    '',
    ['/Simple'],
    [   [u'Size2f', u'densityNeighborhoodSize', '', ['/RW']],
        [u'float', u'minDensity', '', ['/RW']],
        [u'int', u'kmeansAttempts', '', ['/RW']],
        [u'int', u'minDistanceToAddKeypoint', '', ['/RW']],
        [u'int', u'keypointScale', '', ['/RW']],
        [u'float', u'minGraphConfidence', '', ['/RW']],
        [u'float', u'vertexGain', '', ['/RW']],
        [u'float', u'vertexPenalty', '', ['/RW']],
        [u'float', u'existingVertexGain', '', ['/RW']],
        [u'float', u'edgeGain', '', ['/RW']],
        [u'float', u'edgePenalty', '', ['/RW']],
        [u'float', u'convexHullFactor', '', ['/RW']],
        [u'float', u'minRNGEdgeSwitchDist', '', ['/RW']],
        [u'float', u'squareSize', '', ['/RW']],
        [u'float', u'maxRectifiedDistance', '', ['/RW']]],
    None]
ignored: CLASS cv::.CirclesGridFinderParameters : 

--- Incoming ---
[   u'cv.CirclesGridFinderParameters.CirclesGridFinderParameters',
    '',
    [],
    [],
    None]
ignored: FUNC < cv.CirclesGridFinderParameters.CirclesGridFinderParameters []>

--- Incoming ---
[   u'enum cv.CirclesGridFinderParameters.GridType',
    '',
    [],
    [   [   u'const cv.CirclesGridFinderParameters.SYMMETRIC_GRID',
            '0',
            [],
            [],
            None,
            ''],
        [   u'const cv.CirclesGridFinderParameters.ASYMMETRIC_GRID',
            '1',
            [],
            [],
            None,
            '']],
    None]
class not found: CONST SYMMETRIC_GRID=0
ok: CONST CirclesGridFinderParameters_SYMMETRIC_GRID=0
class not found: CONST ASYMMETRIC_GRID=1
ok: CONST CirclesGridFinderParameters_ASYMMETRIC_GRID=1

--- Incoming ---
[   u'cv.findCirclesGrid',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'centers', '', ['/O']],
        [u'int', u'flags', u'', []],
        [u'Ptr_FeatureDetector', u'blobDetector', u'', ['/C', '/Ref']],
        [u'CirclesGridFinderParameters', u'parameters', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=, ARG Ptr_FeatureDetector blobDetector=, ARG CirclesGridFinderParameters parameters=]>

--- Incoming ---
[   u'cv.findCirclesGrid',
    u'bool',
    [],
    [   ['Mat', u'image', '', []],
        [u'Size', u'patternSize', u'', []],
        ['Mat', u'centers', '', ['/O']],
        [u'int', u'flags', u'CALIB_CB_SYMMETRIC_GRID', []],
        [   u'Ptr_FeatureDetector',
            u'blobDetector',
            u'SimpleBlobDetector::create()',
            ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=CALIB_CB_SYMMETRIC_GRID, ARG Ptr_FeatureDetector blobDetector=SimpleBlobDetector::create()]>

--- Incoming ---
[   u'cv.calibrateCamera',
    u'double',
    [u'=calibrateCameraExtended'],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        ['Mat', u'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', u'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', u'perViewErrors', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.calibrateCamera',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.calibrateCameraRO',
    u'double',
    [u'=calibrateCameraROExtended'],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'int', u'iFixedPoint', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        ['Mat', u'newObjPoints', '', ['/O']],
        ['Mat', u'stdDeviationsIntrinsics', '', ['/O']],
        ['Mat', u'stdDeviationsExtrinsics', '', ['/O']],
        ['Mat', u'stdDeviationsObjPoints', '', ['/O']],
        ['Mat', u'perViewErrors', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat stdDeviationsObjPoints=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.calibrateCameraRO',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'int', u'iFixedPoint', u'', []],
        ['Mat', u'cameraMatrix', '', ['/IO']],
        ['Mat', u'distCoeffs', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        ['Mat', u'newObjPoints', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.calibrationMatrixValues',
    u'void',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'double', u'apertureWidth', u'', []],
        [u'double', u'apertureHeight', u'', []],
        [u'double', u'fovx', u'', ['/O', '/Ref']],
        [u'double', u'fovy', u'', ['/O', '/Ref']],
        [u'double', u'focalLength', u'', ['/O', '/Ref']],
        [u'Point2d', u'principalPoint', u'', ['/O', '/Ref']],
        [u'double', u'aspectRatio', u'', ['/O', '/Ref']]],
    u'void']
ok: FUNC <void cv..calibrationMatrixValues [ARG Mat cameraMatrix=, ARG Size imageSize=, ARG double apertureWidth=, ARG double apertureHeight=, ARG double fovx=, ARG double fovy=, ARG double focalLength=, ARG Point2d principalPoint=, ARG double aspectRatio=]>

--- Incoming ---
[   u'cv.stereoCalibrate',
    u'double',
    [u'=stereoCalibrateExtended'],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints1', '', []],
        ['vector_Mat', u'imagePoints2', '', []],
        ['Mat', u'cameraMatrix1', '', ['/IO']],
        ['Mat', u'distCoeffs1', '', ['/IO']],
        ['Mat', u'cameraMatrix2', '', ['/IO']],
        ['Mat', u'distCoeffs2', '', ['/IO']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', ['/IO']],
        ['Mat', u'T', '', ['/IO']],
        ['Mat', u'E', '', ['/O']],
        ['Mat', u'F', '', ['/O']],
        ['Mat', u'perViewErrors', '', ['/O']],
        [u'int', u'flags', u'CALIB_FIX_INTRINSIC', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)',
            []]],
    u'double']
ok: FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG Mat perViewErrors=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>

--- Incoming ---
[   u'cv.stereoCalibrate',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints1', '', []],
        ['vector_Mat', u'imagePoints2', '', []],
        ['Mat', u'cameraMatrix1', '', ['/IO']],
        ['Mat', u'distCoeffs1', '', ['/IO']],
        ['Mat', u'cameraMatrix2', '', ['/IO']],
        ['Mat', u'distCoeffs2', '', ['/IO']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u'T', '', ['/O']],
        ['Mat', u'E', '', ['/O']],
        ['Mat', u'F', '', ['/O']],
        [u'int', u'flags', u'CALIB_FIX_INTRINSIC', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)',
            []]],
    u'double']
ok: FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>

--- Incoming ---
[   u'cv.stereoRectify',
    u'void',
    [],
    [   ['Mat', u'cameraMatrix1', '', []],
        ['Mat', u'distCoeffs1', '', []],
        ['Mat', u'cameraMatrix2', '', []],
        ['Mat', u'distCoeffs2', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', []],
        ['Mat', u'T', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u'P1', '', ['/O']],
        ['Mat', u'P2', '', ['/O']],
        ['Mat', u'Q', '', ['/O']],
        [u'int', u'flags', u'CALIB_ZERO_DISPARITY', []],
        [u'double', u'alpha', u'-1', []],
        [u'Size', u'newImageSize', u'Size()', []],
        [u'Rect*', u'validPixROI1', u'0', ['/O']],
        [u'Rect*', u'validPixROI2', u'0', ['/O']]],
    u'void']
ok: FUNC <void cv..stereoRectify [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=CALIB_ZERO_DISPARITY, ARG double alpha=-1, ARG Size newImageSize=Size(), ARG Rect * validPixROI1=0, ARG Rect * validPixROI2=0]>

--- Incoming ---
[   u'cv.stereoRectifyUncalibrated',
    u'bool',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'F', '', []],
        [u'Size', u'imgSize', u'', []],
        ['Mat', u'H1', '', ['/O']],
        ['Mat', u'H2', '', ['/O']],
        [u'double', u'threshold', u'5', []]],
    u'bool']
ok: FUNC <bool cv..stereoRectifyUncalibrated [ARG Mat points1=, ARG Mat points2=, ARG Mat F=, ARG Size imgSize=, ARG Mat H1=, ARG Mat H2=, ARG double threshold=5]>

--- Incoming ---
[   u'cv.rectify3Collinear',
    u'float',
    [],
    [   ['Mat', u'cameraMatrix1', '', []],
        ['Mat', u'distCoeffs1', '', []],
        ['Mat', u'cameraMatrix2', '', []],
        ['Mat', u'distCoeffs2', '', []],
        ['Mat', u'cameraMatrix3', '', []],
        ['Mat', u'distCoeffs3', '', []],
        ['vector_Mat', u'imgpt1', '', []],
        ['vector_Mat', u'imgpt3', '', []],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R12', '', []],
        ['Mat', u'T12', '', []],
        ['Mat', u'R13', '', []],
        ['Mat', u'T13', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u'R3', '', ['/O']],
        ['Mat', u'P1', '', ['/O']],
        ['Mat', u'P2', '', ['/O']],
        ['Mat', u'P3', '', ['/O']],
        ['Mat', u'Q', '', ['/O']],
        [u'double', u'alpha', u'', []],
        [u'Size', u'newImgSize', u'', []],
        [u'Rect*', u'roi1', u'', ['/O']],
        [u'Rect*', u'roi2', u'', ['/O']],
        [u'int', u'flags', u'', []]],
    u'float']
ok: FUNC <float cv..rectify3Collinear [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat cameraMatrix3=, ARG Mat distCoeffs3=, ARG vector_Mat imgpt1=, ARG vector_Mat imgpt3=, ARG Size imageSize=, ARG Mat R12=, ARG Mat T12=, ARG Mat R13=, ARG Mat T13=, ARG Mat R1=, ARG Mat R2=, ARG Mat R3=, ARG Mat P1=, ARG Mat P2=, ARG Mat P3=, ARG Mat Q=, ARG double alpha=, ARG Size newImgSize=, ARG Rect * roi1=, ARG Rect * roi2=, ARG int flags=]>

--- Incoming ---
[   u'cv.getOptimalNewCameraMatrix',
    u'Mat',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        [u'Size', u'imageSize', u'', []],
        [u'double', u'alpha', u'', []],
        [u'Size', u'newImgSize', u'Size()', []],
        [u'Rect*', u'validPixROI', u'0', ['/O']],
        [u'bool', u'centerPrincipalPoint', u'false', []]],
    u'Mat']
ok: FUNC <Mat cv..getOptimalNewCameraMatrix [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG double alpha=, ARG Size newImgSize=Size(), ARG Rect * validPixROI=0, ARG bool centerPrincipalPoint=false]>

--- Incoming ---
[   u'cv.calibrateHandEye',
    u'void',
    [],
    [   ['vector_Mat', u'R_gripper2base', '', []],
        ['vector_Mat', u't_gripper2base', '', []],
        ['vector_Mat', u'R_target2cam', '', []],
        ['vector_Mat', u't_target2cam', '', []],
        ['Mat', u'R_cam2gripper', '', ['/O']],
        ['Mat', u't_cam2gripper', '', ['/O']],
        [u'HandEyeCalibrationMethod', u'method', u'CALIB_HAND_EYE_TSAI', []]],
    u'void']
ok: FUNC <void cv..calibrateHandEye [ARG vector_Mat R_gripper2base=, ARG vector_Mat t_gripper2base=, ARG vector_Mat R_target2cam=, ARG vector_Mat t_target2cam=, ARG Mat R_cam2gripper=, ARG Mat t_cam2gripper=, ARG HandEyeCalibrationMethod method=CALIB_HAND_EYE_TSAI]>

--- Incoming ---
[   u'cv.convertPointsToHomogeneous',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..convertPointsToHomogeneous [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.convertPointsFromHomogeneous',
    u'void',
    [],
    [['Mat', u'src', '', []], ['Mat', u'dst', '', ['/O']]],
    u'void']
ok: FUNC <void cv..convertPointsFromHomogeneous [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   u'cv.findFundamentalMat',
    u'Mat',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        [u'int', u'method', u'', []],
        [u'double', u'ransacReprojThreshold', u'', []],
        [u'double', u'confidence', u'', []],
        [u'int', u'maxIters', u'', []],
        ['Mat', u'mask', u'Mat()', ['/O']]],
    u'Mat']
ok: FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=, ARG double ransacReprojThreshold=, ARG double confidence=, ARG int maxIters=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.findFundamentalMat',
    u'Mat',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        [u'int', u'method', u'FM_RANSAC', []],
        [u'double', u'ransacReprojThreshold', u'3.', []],
        [u'double', u'confidence', u'0.99', []],
        ['Mat', u'mask', u'Mat()', ['/O']]],
    u'Mat']
ok: FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=FM_RANSAC, ARG double ransacReprojThreshold=3., ARG double confidence=0.99, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.findEssentialMat',
    u'Mat',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'cameraMatrix', '', []],
        [u'int', u'method', u'RANSAC', []],
        [u'double', u'prob', u'0.999', []],
        [u'double', u'threshold', u'1.0', []],
        ['Mat', u'mask', u'Mat()', ['/O']]],
    u'Mat']
ok: FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.findEssentialMat',
    u'Mat',
    [],
    [   ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        [u'double', u'focal', u'1.0', []],
        [u'Point2d', u'pp', u'Point2d(0, 0)', []],
        [u'int', u'method', u'RANSAC', []],
        [u'double', u'prob', u'0.999', []],
        [u'double', u'threshold', u'1.0', []],
        ['Mat', u'mask', u'Mat()', ['/O']]],
    u'Mat']
ok: FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.decomposeEssentialMat',
    u'void',
    [],
    [   ['Mat', u'E', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u't', '', ['/O']]],
    u'void']
ok: FUNC <void cv..decomposeEssentialMat [ARG Mat E=, ARG Mat R1=, ARG Mat R2=, ARG Mat t=]>

--- Incoming ---
[   u'cv.recoverPose',
    u'int',
    [],
    [   ['Mat', u'E', '', []],
        ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u't', '', ['/O']],
        ['Mat', u'mask', u'Mat()', ['/IO']]],
    u'int']
ok: FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.recoverPose',
    u'int',
    [],
    [   ['Mat', u'E', '', []],
        ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u't', '', ['/O']],
        [u'double', u'focal', u'1.0', []],
        [u'Point2d', u'pp', u'Point2d(0, 0)', []],
        ['Mat', u'mask', u'Mat()', ['/IO']]],
    u'int']
ok: FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat R=, ARG Mat t=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG Mat mask=Mat()]>

--- Incoming ---
[   u'cv.recoverPose',
    u'int',
    [],
    [   ['Mat', u'E', '', []],
        ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u't', '', ['/O']],
        [u'double', u'distanceThresh', u'', []],
        ['Mat', u'mask', u'Mat()', ['/IO']],
        ['Mat', u'triangulatedPoints', u'Mat()', ['/O']]],
    u'int']
ok: FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG double distanceThresh=, ARG Mat mask=Mat(), ARG Mat triangulatedPoints=Mat()]>

--- Incoming ---
[   u'cv.computeCorrespondEpilines',
    u'void',
    [],
    [   ['Mat', u'points', '', []],
        [u'int', u'whichImage', u'', []],
        ['Mat', u'F', '', []],
        ['Mat', u'lines', '', ['/O']]],
    u'void']
ok: FUNC <void cv..computeCorrespondEpilines [ARG Mat points=, ARG int whichImage=, ARG Mat F=, ARG Mat lines=]>

--- Incoming ---
[   u'cv.triangulatePoints',
    u'void',
    [],
    [   ['Mat', u'projMatr1', '', []],
        ['Mat', u'projMatr2', '', []],
        ['Mat', u'projPoints1', '', []],
        ['Mat', u'projPoints2', '', []],
        ['Mat', u'points4D', '', ['/O']]],
    u'void']
ok: FUNC <void cv..triangulatePoints [ARG Mat projMatr1=, ARG Mat projMatr2=, ARG Mat projPoints1=, ARG Mat projPoints2=, ARG Mat points4D=]>

--- Incoming ---
[   u'cv.correctMatches',
    u'void',
    [],
    [   ['Mat', u'F', '', []],
        ['Mat', u'points1', '', []],
        ['Mat', u'points2', '', []],
        ['Mat', u'newPoints1', '', ['/O']],
        ['Mat', u'newPoints2', '', ['/O']]],
    u'void']
ok: FUNC <void cv..correctMatches [ARG Mat F=, ARG Mat points1=, ARG Mat points2=, ARG Mat newPoints1=, ARG Mat newPoints2=]>

--- Incoming ---
[   u'cv.filterSpeckles',
    u'void',
    [],
    [   ['Mat', u'img', '', ['/IO']],
        [u'double', u'newVal', u'', []],
        [u'int', u'maxSpeckleSize', u'', []],
        [u'double', u'maxDiff', u'', []],
        ['Mat', u'buf', u'Mat()', ['/IO']]],
    u'void']
ok: FUNC <void cv..filterSpeckles [ARG Mat img=, ARG double newVal=, ARG int maxSpeckleSize=, ARG double maxDiff=, ARG Mat buf=Mat()]>

--- Incoming ---
[   u'cv.getValidDisparityROI',
    u'Rect',
    [],
    [   [u'Rect', u'roi1', u'', []],
        [u'Rect', u'roi2', u'', []],
        [u'int', u'minDisparity', u'', []],
        [u'int', u'numberOfDisparities', u'', []],
        [u'int', u'blockSize', u'', []]],
    u'Rect']
ok: FUNC <Rect cv..getValidDisparityROI [ARG Rect roi1=, ARG Rect roi2=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int blockSize=]>

--- Incoming ---
[   u'cv.validateDisparity',
    u'void',
    [],
    [   ['Mat', u'disparity', '', ['/IO']],
        ['Mat', u'cost', '', []],
        [u'int', u'minDisparity', u'', []],
        [u'int', u'numberOfDisparities', u'', []],
        [u'int', u'disp12MaxDisp', u'1', []]],
    u'void']
ok: FUNC <void cv..validateDisparity [ARG Mat disparity=, ARG Mat cost=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int disp12MaxDisp=1]>

--- Incoming ---
[   u'cv.reprojectImageTo3D',
    u'void',
    [],
    [   ['Mat', u'disparity', '', []],
        ['Mat', u'_3dImage', '', ['/O']],
        ['Mat', u'Q', '', []],
        [u'bool', u'handleMissingValues', u'false', []],
        [u'int', u'ddepth', u'-1', []]],
    u'void']
ok: FUNC <void cv..reprojectImageTo3D [ARG Mat disparity=, ARG Mat _3dImage=, ARG Mat Q=, ARG bool handleMissingValues=false, ARG int ddepth=-1]>

--- Incoming ---
[   u'cv.sampsonDistance',
    u'double',
    [],
    [['Mat', u'pt1', '', []], ['Mat', u'pt2', '', []], ['Mat', u'F', '', []]],
    u'double']
ok: FUNC <double cv..sampsonDistance [ARG Mat pt1=, ARG Mat pt2=, ARG Mat F=]>

--- Incoming ---
[   u'cv.estimateAffine3D',
    u'int',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', []],
        ['Mat', u'out', '', ['/O']],
        ['Mat', u'inliers', '', ['/O']],
        [u'double', u'ransacThreshold', u'3', []],
        [u'double', u'confidence', u'0.99', []]],
    u'int']
ok: FUNC <int cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>

--- Incoming ---
[   u'cv.estimateAffine2D',
    u'Mat',
    [],
    [   ['Mat', u'from', '', []],
        ['Mat', u'to', '', []],
        ['Mat', u'inliers', u'Mat()', ['/O']],
        [u'int', u'method', u'RANSAC', []],
        [u'double', u'ransacReprojThreshold', u'3', []],
        [u'size_t', u'maxIters', u'2000', []],
        [u'double', u'confidence', u'0.99', []],
        [u'size_t', u'refineIters', u'10', []]],
    u'cv::Mat']
ok: FUNC <Mat cv..estimateAffine2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>

--- Incoming ---
[   u'cv.estimateAffinePartial2D',
    u'Mat',
    [],
    [   ['Mat', u'from', '', []],
        ['Mat', u'to', '', []],
        ['Mat', u'inliers', u'Mat()', ['/O']],
        [u'int', u'method', u'RANSAC', []],
        [u'double', u'ransacReprojThreshold', u'3', []],
        [u'size_t', u'maxIters', u'2000', []],
        [u'double', u'confidence', u'0.99', []],
        [u'size_t', u'refineIters', u'10', []]],
    u'cv::Mat']
ok: FUNC <Mat cv..estimateAffinePartial2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>

--- Incoming ---
[   u'cv.decomposeHomographyMat',
    u'int',
    [],
    [   ['Mat', u'H', '', []],
        ['Mat', u'K', '', []],
        ['vector_Mat', u'rotations', '', ['/O']],
        ['vector_Mat', u'translations', '', ['/O']],
        ['vector_Mat', u'normals', '', ['/O']]],
    u'int']
ok: FUNC <int cv..decomposeHomographyMat [ARG Mat H=, ARG Mat K=, ARG vector_Mat rotations=, ARG vector_Mat translations=, ARG vector_Mat normals=]>

--- Incoming ---
[   u'cv.filterHomographyDecompByVisibleRefpoints',
    u'void',
    [],
    [   ['vector_Mat', u'rotations', '', []],
        ['vector_Mat', u'normals', '', []],
        ['Mat', u'beforePoints', '', []],
        ['Mat', u'afterPoints', '', []],
        ['Mat', u'possibleSolutions', '', ['/O']],
        ['Mat', u'pointsMask', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..filterHomographyDecompByVisibleRefpoints [ARG vector_Mat rotations=, ARG vector_Mat normals=, ARG Mat beforePoints=, ARG Mat afterPoints=, ARG Mat possibleSolutions=, ARG Mat pointsMask=Mat()]>

--- Incoming ---
[u'class cv.StereoMatcher', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.StereoMatcher : Algorithm, name: StereoMatcher, base: Algorithm

--- Incoming ---
[   u'enum cv.StereoMatcher.<unnamed>',
    '',
    [],
    [   [u'const cv.StereoMatcher.DISP_SHIFT', u'4', [], [], None, ''],
        [   u'const cv.StereoMatcher.DISP_SCALE',
            u'(1 << DISP_SHIFT)',
            [],
            [],
            None,
            '']],
    None]
ok: CONST DISP_SHIFT=4
ok: CONST DISP_SCALE=(1 << DISP_SHIFT)

--- Incoming ---
[   u'cv.StereoMatcher.compute',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'left', '', []],
        ['Mat', u'right', '', []],
        ['Mat', u'disparity', '', ['/O']]],
    u'void']
ok: FUNC <void cv.StereoMatcher.compute [ARG Mat left=, ARG Mat right=, ARG Mat disparity=]>

--- Incoming ---
[u'cv.StereoMatcher.getMinDisparity', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoMatcher.getMinDisparity []>

--- Incoming ---
[   u'cv.StereoMatcher.setMinDisparity',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'minDisparity', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setMinDisparity [ARG int minDisparity=]>

--- Incoming ---
[   u'cv.StereoMatcher.getNumDisparities',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.StereoMatcher.getNumDisparities []>

--- Incoming ---
[   u'cv.StereoMatcher.setNumDisparities',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'numDisparities', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setNumDisparities [ARG int numDisparities=]>

--- Incoming ---
[u'cv.StereoMatcher.getBlockSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoMatcher.getBlockSize []>

--- Incoming ---
[   u'cv.StereoMatcher.setBlockSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'blockSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setBlockSize [ARG int blockSize=]>

--- Incoming ---
[   u'cv.StereoMatcher.getSpeckleWindowSize',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.StereoMatcher.getSpeckleWindowSize []>

--- Incoming ---
[   u'cv.StereoMatcher.setSpeckleWindowSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'speckleWindowSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setSpeckleWindowSize [ARG int speckleWindowSize=]>

--- Incoming ---
[u'cv.StereoMatcher.getSpeckleRange', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoMatcher.getSpeckleRange []>

--- Incoming ---
[   u'cv.StereoMatcher.setSpeckleRange',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'speckleRange', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setSpeckleRange [ARG int speckleRange=]>

--- Incoming ---
[u'cv.StereoMatcher.getDisp12MaxDiff', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoMatcher.getDisp12MaxDiff []>

--- Incoming ---
[   u'cv.StereoMatcher.setDisp12MaxDiff',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'disp12MaxDiff', u'', []]],
    u'void']
ok: FUNC <void cv.StereoMatcher.setDisp12MaxDiff [ARG int disp12MaxDiff=]>

--- Incoming ---
[u'class cv.StereoBM', u': cv::StereoMatcher', [], [], None]
ok: class CLASS cv::.StereoBM : StereoMatcher, name: StereoBM, base: StereoMatcher

--- Incoming ---
[   u'enum cv.StereoBM.<unnamed>',
    '',
    [],
    [   [   u'const cv.StereoBM.PREFILTER_NORMALIZED_RESPONSE',
            u'0',
            [],
            [],
            None,
            ''],
        [u'const cv.StereoBM.PREFILTER_XSOBEL', u'1', [], [], None, '']],
    None]
ok: CONST PREFILTER_NORMALIZED_RESPONSE=0
ok: CONST PREFILTER_XSOBEL=1

--- Incoming ---
[u'cv.StereoBM.getPreFilterType', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getPreFilterType []>

--- Incoming ---
[   u'cv.StereoBM.setPreFilterType',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'preFilterType', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setPreFilterType [ARG int preFilterType=]>

--- Incoming ---
[u'cv.StereoBM.getPreFilterSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getPreFilterSize []>

--- Incoming ---
[   u'cv.StereoBM.setPreFilterSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'preFilterSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setPreFilterSize [ARG int preFilterSize=]>

--- Incoming ---
[u'cv.StereoBM.getPreFilterCap', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getPreFilterCap []>

--- Incoming ---
[   u'cv.StereoBM.setPreFilterCap',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'preFilterCap', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setPreFilterCap [ARG int preFilterCap=]>

--- Incoming ---
[u'cv.StereoBM.getTextureThreshold', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getTextureThreshold []>

--- Incoming ---
[   u'cv.StereoBM.setTextureThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'textureThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setTextureThreshold [ARG int textureThreshold=]>

--- Incoming ---
[u'cv.StereoBM.getUniquenessRatio', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getUniquenessRatio []>

--- Incoming ---
[   u'cv.StereoBM.setUniquenessRatio',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'uniquenessRatio', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setUniquenessRatio [ARG int uniquenessRatio=]>

--- Incoming ---
[u'cv.StereoBM.getSmallerBlockSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoBM.getSmallerBlockSize []>

--- Incoming ---
[   u'cv.StereoBM.setSmallerBlockSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'blockSize', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setSmallerBlockSize [ARG int blockSize=]>

--- Incoming ---
[u'cv.StereoBM.getROI1', u'Rect', ['/C', '/V', '/PV'], [], u'Rect']
ok: FUNC <Rect cv.StereoBM.getROI1 []>

--- Incoming ---
[   u'cv.StereoBM.setROI1',
    u'void',
    ['/V', '/PV'],
    [[u'Rect', u'roi1', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setROI1 [ARG Rect roi1=]>

--- Incoming ---
[u'cv.StereoBM.getROI2', u'Rect', ['/C', '/V', '/PV'], [], u'Rect']
ok: FUNC <Rect cv.StereoBM.getROI2 []>

--- Incoming ---
[   u'cv.StereoBM.setROI2',
    u'void',
    ['/V', '/PV'],
    [[u'Rect', u'roi2', u'', []]],
    u'void']
ok: FUNC <void cv.StereoBM.setROI2 [ARG Rect roi2=]>

--- Incoming ---
[   u'cv.StereoBM.create',
    u'Ptr_StereoBM',
    ['/S'],
    [[u'int', u'numDisparities', u'0', []], [u'int', u'blockSize', u'21', []]],
    u'Ptr<StereoBM>']
ok: FUNC <Ptr_StereoBM cv.StereoBM.create [ARG int numDisparities=0, ARG int blockSize=21]>

--- Incoming ---
[u'class cv.StereoSGBM', u': cv::StereoMatcher', [], [], None]
ok: class CLASS cv::.StereoSGBM : StereoMatcher, name: StereoSGBM, base: StereoMatcher

--- Incoming ---
[   u'enum cv.StereoSGBM.<unnamed>',
    '',
    [],
    [   [u'const cv.StereoSGBM.MODE_SGBM', u'0', [], [], None, ''],
        [u'const cv.StereoSGBM.MODE_HH', u'1', [], [], None, ''],
        [u'const cv.StereoSGBM.MODE_SGBM_3WAY', u'2', [], [], None, ''],
        [u'const cv.StereoSGBM.MODE_HH4', u'3', [], [], None, '']],
    None]
ok: CONST MODE_SGBM=0
ok: CONST MODE_HH=1
ok: CONST MODE_SGBM_3WAY=2
ok: CONST MODE_HH4=3

--- Incoming ---
[u'cv.StereoSGBM.getPreFilterCap', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoSGBM.getPreFilterCap []>

--- Incoming ---
[   u'cv.StereoSGBM.setPreFilterCap',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'preFilterCap', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setPreFilterCap [ARG int preFilterCap=]>

--- Incoming ---
[u'cv.StereoSGBM.getUniquenessRatio', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoSGBM.getUniquenessRatio []>

--- Incoming ---
[   u'cv.StereoSGBM.setUniquenessRatio',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'uniquenessRatio', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setUniquenessRatio [ARG int uniquenessRatio=]>

--- Incoming ---
[u'cv.StereoSGBM.getP1', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoSGBM.getP1 []>

--- Incoming ---
[   u'cv.StereoSGBM.setP1',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'P1', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setP1 [ARG int P1=]>

--- Incoming ---
[u'cv.StereoSGBM.getP2', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoSGBM.getP2 []>

--- Incoming ---
[   u'cv.StereoSGBM.setP2',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'P2', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setP2 [ARG int P2=]>

--- Incoming ---
[u'cv.StereoSGBM.getMode', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.StereoSGBM.getMode []>

--- Incoming ---
[   u'cv.StereoSGBM.setMode',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'mode', u'', []]],
    u'void']
ok: FUNC <void cv.StereoSGBM.setMode [ARG int mode=]>

--- Incoming ---
[   u'cv.StereoSGBM.create',
    u'Ptr_StereoSGBM',
    ['/S'],
    [   [u'int', u'minDisparity', u'0', []],
        [u'int', u'numDisparities', u'16', []],
        [u'int', u'blockSize', u'3', []],
        [u'int', u'P1', u'0', []],
        [u'int', u'P2', u'0', []],
        [u'int', u'disp12MaxDiff', u'0', []],
        [u'int', u'preFilterCap', u'0', []],
        [u'int', u'uniquenessRatio', u'0', []],
        [u'int', u'speckleWindowSize', u'0', []],
        [u'int', u'speckleRange', u'0', []],
        [u'int', u'mode', u'StereoSGBM::MODE_SGBM', []]],
    u'Ptr<StereoSGBM>']
ok: FUNC <Ptr_StereoSGBM cv.StereoSGBM.create [ARG int minDisparity=0, ARG int numDisparities=16, ARG int blockSize=3, ARG int P1=0, ARG int P2=0, ARG int disp12MaxDiff=0, ARG int preFilterCap=0, ARG int uniquenessRatio=0, ARG int speckleWindowSize=0, ARG int speckleRange=0, ARG int mode=StereoSGBM::MODE_SGBM]>

--- Incoming ---
[   u'enum cv.UndistortTypes',
    '',
    [],
    [   [u'const cv.PROJ_SPHERICAL_ORTHO', u'0', [], [], None, ''],
        [u'const cv.PROJ_SPHERICAL_EQRECT', u'1', [], [], None, '']],
    None]
ok: CONST PROJ_SPHERICAL_ORTHO=0
ok: CONST PROJ_SPHERICAL_EQRECT=1

--- Incoming ---
[   u'cv.undistort',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'newCameraMatrix', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..undistort [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat newCameraMatrix=Mat()]>

--- Incoming ---
[   u'cv.initUndistortRectifyMap',
    u'void',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'R', '', []],
        ['Mat', u'newCameraMatrix', '', []],
        [u'Size', u'size', u'', []],
        [u'int', u'm1type', u'', []],
        ['Mat', u'map1', '', ['/O']],
        ['Mat', u'map2', '', ['/O']]],
    u'void']
ok: FUNC <void cv..initUndistortRectifyMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat newCameraMatrix=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>

--- Incoming ---
[   u'cv.getDefaultNewCameraMatrix',
    u'Mat',
    [],
    [   ['Mat', u'cameraMatrix', '', []],
        [u'Size', u'imgsize', u'Size()', []],
        [u'bool', u'centerPrincipalPoint', u'false', []]],
    u'Mat']
ok: FUNC <Mat cv..getDefaultNewCameraMatrix [ARG Mat cameraMatrix=, ARG Size imgsize=Size(), ARG bool centerPrincipalPoint=false]>

--- Incoming ---
[   u'cv.undistortPoints',
    u'void',
    [],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'R', u'Mat()', []],
        ['Mat', u'P', u'Mat()', []]],
    u'void']
ok: FUNC <void cv..undistortPoints [ARG vector_Point2f src=, ARG vector_Point2f dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=Mat(), ARG Mat P=Mat()]>

--- Incoming ---
[   u'cv.undistortPoints',
    u'void',
    [u'=undistortPointsIter'],
    [   ['Mat', u'src', '', []],
        ['Mat', u'dst', '', ['/O']],
        ['Mat', u'cameraMatrix', '', []],
        ['Mat', u'distCoeffs', '', []],
        ['Mat', u'R', '', []],
        ['Mat', u'P', '', []],
        [u'TermCriteria', u'criteria', u'', []]],
    u'void']
ok: FUNC <void cv..undistortPoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat P=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'enum cv.fisheye.<unnamed>',
    '',
    [],
    [   [   u'const cv.fisheye.CALIB_USE_INTRINSIC_GUESS',
            u'1 << 0',
            [],
            [],
            None,
            ''],
        [   u'const cv.fisheye.CALIB_RECOMPUTE_EXTRINSIC',
            u'1 << 1',
            [],
            [],
            None,
            ''],
        [u'const cv.fisheye.CALIB_CHECK_COND', u'1 << 2', [], [], None, ''],
        [u'const cv.fisheye.CALIB_FIX_SKEW', u'1 << 3', [], [], None, ''],
        [u'const cv.fisheye.CALIB_FIX_K1', u'1 << 4', [], [], None, ''],
        [u'const cv.fisheye.CALIB_FIX_K2', u'1 << 5', [], [], None, ''],
        [u'const cv.fisheye.CALIB_FIX_K3', u'1 << 6', [], [], None, ''],
        [u'const cv.fisheye.CALIB_FIX_K4', u'1 << 7', [], [], None, ''],
        [   u'const cv.fisheye.CALIB_FIX_INTRINSIC',
            u'1 << 8',
            [],
            [],
            None,
            ''],
        [   u'const cv.fisheye.CALIB_FIX_PRINCIPAL_POINT',
            u'1 << 9',
            [],
            [],
            None,
            '']],
    None]
ok: CONST fisheye_CALIB_USE_INTRINSIC_GUESS=1 << 0
ok: CONST fisheye_CALIB_RECOMPUTE_EXTRINSIC=1 << 1
ok: CONST fisheye_CALIB_CHECK_COND=1 << 2
ok: CONST fisheye_CALIB_FIX_SKEW=1 << 3
ok: CONST fisheye_CALIB_FIX_K1=1 << 4
ok: CONST fisheye_CALIB_FIX_K2=1 << 5
ok: CONST fisheye_CALIB_FIX_K3=1 << 6
ok: CONST fisheye_CALIB_FIX_K4=1 << 7
ok: CONST fisheye_CALIB_FIX_INTRINSIC=1 << 8
ok: CONST fisheye_CALIB_FIX_PRINCIPAL_POINT=1 << 9

--- Incoming ---
[   u'cv.fisheye.projectPoints',
    u'void',
    [],
    [   ['Mat', u'objectPoints', '', []],
        ['Mat', u'imagePoints', '', ['/O']],
        ['Mat', u'rvec', '', []],
        ['Mat', u'tvec', '', []],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        [u'double', u'alpha', u'0', []],
        ['Mat', u'jacobian', u'Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.fisheye..projectPoints [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat K=, ARG Mat D=, ARG double alpha=0, ARG Mat jacobian=Mat()]>

--- Incoming ---
[   u'cv.fisheye.distortPoints',
    u'void',
    [],
    [   ['Mat', u'undistorted', '', []],
        ['Mat', u'distorted', '', ['/O']],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        [u'double', u'alpha', u'0', []]],
    u'void']
ok: FUNC <void cv.fisheye..distortPoints [ARG Mat undistorted=, ARG Mat distorted=, ARG Mat K=, ARG Mat D=, ARG double alpha=0]>

--- Incoming ---
[   u'cv.fisheye.undistortPoints',
    u'void',
    [],
    [   ['Mat', u'distorted', '', []],
        ['Mat', u'undistorted', '', ['/O']],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        ['Mat', u'R', u'Mat()', []],
        ['Mat', u'P', u'Mat()', []]],
    u'void']
ok: FUNC <void cv.fisheye..undistortPoints [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat R=Mat(), ARG Mat P=Mat()]>

--- Incoming ---
[   u'cv.fisheye.initUndistortRectifyMap',
    u'void',
    [],
    [   ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        ['Mat', u'R', '', []],
        ['Mat', u'P', '', []],
        [u'Size', u'size', u'', ['/C', '/Ref']],
        [u'int', u'm1type', u'', []],
        ['Mat', u'map1', '', ['/O']],
        ['Mat', u'map2', '', ['/O']]],
    u'void']
ok: FUNC <void cv.fisheye..initUndistortRectifyMap [ARG Mat K=, ARG Mat D=, ARG Mat R=, ARG Mat P=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>

--- Incoming ---
[   u'cv.fisheye.undistortImage',
    u'void',
    [],
    [   ['Mat', u'distorted', '', []],
        ['Mat', u'undistorted', '', ['/O']],
        ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        ['Mat', u'Knew', u'cv::Mat()', []],
        [u'Size', u'new_size', u'Size()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.fisheye..undistortImage [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat Knew=cv::Mat(), ARG Size new_size=Size()]>

--- Incoming ---
[   u'cv.fisheye.estimateNewCameraMatrixForUndistortRectify',
    u'void',
    [],
    [   ['Mat', u'K', '', []],
        ['Mat', u'D', '', []],
        [u'Size', u'image_size', u'', ['/C', '/Ref']],
        ['Mat', u'R', '', []],
        ['Mat', u'P', '', ['/O']],
        [u'double', u'balance', u'0.0', []],
        [u'Size', u'new_size', u'Size()', ['/C', '/Ref']],
        [u'double', u'fov_scale', u'1.0', []]],
    u'void']
ok: FUNC <void cv.fisheye..estimateNewCameraMatrixForUndistortRectify [ARG Mat K=, ARG Mat D=, ARG Size image_size=, ARG Mat R=, ARG Mat P=, ARG double balance=0.0, ARG Size new_size=Size(), ARG double fov_scale=1.0]>

--- Incoming ---
[   u'cv.fisheye.calibrate',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints', '', []],
        [u'Size', u'image_size', u'', ['/C', '/Ref']],
        ['Mat', u'K', '', ['/IO']],
        ['Mat', u'D', '', ['/IO']],
        ['vector_Mat', u'rvecs', '', ['/O']],
        ['vector_Mat', u'tvecs', '', ['/O']],
        [u'int', u'flags', u'0', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv.fisheye..calibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size image_size=, ARG Mat K=, ARG Mat D=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>

--- Incoming ---
[   u'cv.fisheye.stereoRectify',
    u'void',
    [],
    [   ['Mat', u'K1', '', []],
        ['Mat', u'D1', '', []],
        ['Mat', u'K2', '', []],
        ['Mat', u'D2', '', []],
        [u'Size', u'imageSize', u'', ['/C', '/Ref']],
        ['Mat', u'R', '', []],
        ['Mat', u'tvec', '', []],
        ['Mat', u'R1', '', ['/O']],
        ['Mat', u'R2', '', ['/O']],
        ['Mat', u'P1', '', ['/O']],
        ['Mat', u'P2', '', ['/O']],
        ['Mat', u'Q', '', ['/O']],
        [u'int', u'flags', u'', []],
        [u'Size', u'newImageSize', u'Size()', ['/C', '/Ref']],
        [u'double', u'balance', u'0.0', []],
        [u'double', u'fov_scale', u'1.0', []]],
    u'void']
ok: FUNC <void cv.fisheye..stereoRectify [ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat tvec=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=, ARG Size newImageSize=Size(), ARG double balance=0.0, ARG double fov_scale=1.0]>

--- Incoming ---
[   u'cv.fisheye.stereoCalibrate',
    u'double',
    [],
    [   ['vector_Mat', u'objectPoints', '', []],
        ['vector_Mat', u'imagePoints1', '', []],
        ['vector_Mat', u'imagePoints2', '', []],
        ['Mat', u'K1', '', ['/IO']],
        ['Mat', u'D1', '', ['/IO']],
        ['Mat', u'K2', '', ['/IO']],
        ['Mat', u'D2', '', ['/IO']],
        [u'Size', u'imageSize', u'', []],
        ['Mat', u'R', '', ['/O']],
        ['Mat', u'T', '', ['/O']],
        [u'int', u'flags', u'fisheye::CALIB_FIX_INTRINSIC', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)',
            []]],
    u'double']
ok: FUNC <double cv.fisheye..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG int flags=fisheye::CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/calib3d/include/opencv2/calib3d/calib3d.hpp =====
Namespaces: set(['', u'cv.fisheye', u'cv'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/calib3d/include/opencv2/calib3d/calib3d.hpp


===== Generating... =====
CLASS cv::.StereoSGBM : StereoMatcher
[CONST MODE_SGBM=0, CONST MODE_HH=1, CONST MODE_SGBM_3WAY=2, CONST MODE_HH4=3]
FUNC <Ptr_StereoSGBM cv.StereoSGBM.create [ARG int minDisparity=0, ARG int numDisparities=16, ARG int blockSize=3, ARG int P1=0, ARG int P2=0, ARG int disp12MaxDiff=0, ARG int preFilterCap=0, ARG int uniquenessRatio=0, ARG int speckleWindowSize=0, ARG int speckleRange=0, ARG int mode=StereoSGBM::MODE_SGBM]>
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize, int speckleRange, int mode)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize, int speckleRange)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1, int P2)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize, int P1)
java: StereoSGBM create(int minDisparity, int numDisparities, int blockSize)
java: StereoSGBM create(int minDisparity, int numDisparities)
java: StereoSGBM create(int minDisparity)
java: StereoSGBM create()
FUNC <int cv.StereoSGBM.getMode []>
java: int getMode()
FUNC <int cv.StereoSGBM.getP1 []>
java: int getP1()
FUNC <int cv.StereoSGBM.getP2 []>
java: int getP2()
FUNC <int cv.StereoSGBM.getPreFilterCap []>
java: int getPreFilterCap()
FUNC <int cv.StereoSGBM.getUniquenessRatio []>
java: int getUniquenessRatio()
FUNC <void cv.StereoSGBM.setMode [ARG int mode=]>
java: void setMode(int mode)
FUNC <void cv.StereoSGBM.setP1 [ARG int P1=]>
java: void setP1(int P1)
FUNC <void cv.StereoSGBM.setP2 [ARG int P2=]>
java: void setP2(int P2)
FUNC <void cv.StereoSGBM.setPreFilterCap [ARG int preFilterCap=]>
java: void setPreFilterCap(int preFilterCap)
FUNC <void cv.StereoSGBM.setUniquenessRatio [ARG int uniquenessRatio=]>
java: void setUniquenessRatio(int uniquenessRatio)
CLASS cv::.StereoBM : StereoMatcher
[CONST PREFILTER_NORMALIZED_RESPONSE=0, CONST PREFILTER_XSOBEL=1]
FUNC <Ptr_StereoBM cv.StereoBM.create [ARG int numDisparities=0, ARG int blockSize=21]>
java: StereoBM create(int numDisparities, int blockSize)
java: StereoBM create(int numDisparities)
java: StereoBM create()
FUNC <Rect cv.StereoBM.getROI1 []>
java: Rect getROI1()
FUNC <Rect cv.StereoBM.getROI2 []>
java: Rect getROI2()
FUNC <int cv.StereoBM.getPreFilterCap []>
java: int getPreFilterCap()
FUNC <int cv.StereoBM.getPreFilterSize []>
java: int getPreFilterSize()
FUNC <int cv.StereoBM.getPreFilterType []>
java: int getPreFilterType()
FUNC <int cv.StereoBM.getSmallerBlockSize []>
java: int getSmallerBlockSize()
FUNC <int cv.StereoBM.getTextureThreshold []>
java: int getTextureThreshold()
FUNC <int cv.StereoBM.getUniquenessRatio []>
java: int getUniquenessRatio()
FUNC <void cv.StereoBM.setPreFilterCap [ARG int preFilterCap=]>
java: void setPreFilterCap(int preFilterCap)
FUNC <void cv.StereoBM.setPreFilterSize [ARG int preFilterSize=]>
java: void setPreFilterSize(int preFilterSize)
FUNC <void cv.StereoBM.setPreFilterType [ARG int preFilterType=]>
java: void setPreFilterType(int preFilterType)
FUNC <void cv.StereoBM.setROI1 [ARG Rect roi1=]>
java: void setROI1(Rect roi1)
FUNC <void cv.StereoBM.setROI2 [ARG Rect roi2=]>
java: void setROI2(Rect roi2)
FUNC <void cv.StereoBM.setSmallerBlockSize [ARG int blockSize=]>
java: void setSmallerBlockSize(int blockSize)
FUNC <void cv.StereoBM.setTextureThreshold [ARG int textureThreshold=]>
java: void setTextureThreshold(int textureThreshold)
FUNC <void cv.StereoBM.setUniquenessRatio [ARG int uniquenessRatio=]>
java: void setUniquenessRatio(int uniquenessRatio)
CLASS cv::.StereoMatcher : Algorithm
[CONST DISP_SHIFT=4, CONST DISP_SCALE=(1 << DISP_SHIFT)]
FUNC <int cv.StereoMatcher.getBlockSize []>
java: int getBlockSize()
FUNC <int cv.StereoMatcher.getDisp12MaxDiff []>
java: int getDisp12MaxDiff()
FUNC <int cv.StereoMatcher.getMinDisparity []>
java: int getMinDisparity()
FUNC <int cv.StereoMatcher.getNumDisparities []>
java: int getNumDisparities()
FUNC <int cv.StereoMatcher.getSpeckleRange []>
java: int getSpeckleRange()
FUNC <int cv.StereoMatcher.getSpeckleWindowSize []>
java: int getSpeckleWindowSize()
FUNC <void cv.StereoMatcher.compute [ARG Mat left=, ARG Mat right=, ARG Mat disparity=]>
java: void compute(Mat left, Mat right, Mat disparity)
FUNC <void cv.StereoMatcher.setBlockSize [ARG int blockSize=]>
java: void setBlockSize(int blockSize)
FUNC <void cv.StereoMatcher.setDisp12MaxDiff [ARG int disp12MaxDiff=]>
java: void setDisp12MaxDiff(int disp12MaxDiff)
FUNC <void cv.StereoMatcher.setMinDisparity [ARG int minDisparity=]>
java: void setMinDisparity(int minDisparity)
FUNC <void cv.StereoMatcher.setNumDisparities [ARG int numDisparities=]>
java: void setNumDisparities(int numDisparities)
FUNC <void cv.StereoMatcher.setSpeckleRange [ARG int speckleRange=]>
java: void setSpeckleRange(int speckleRange)
FUNC <void cv.StereoMatcher.setSpeckleWindowSize [ARG int speckleWindowSize=]>
java: void setSpeckleWindowSize(int speckleWindowSize)
CLASS ::.Calib3d : 
[CONST CV_ITERATIVE=0, CONST CV_EPNP=1, CONST CV_P3P=2, CONST CV_DLS=3, CONST CvLevMarq_DONE=0, CONST CvLevMarq_STARTED=1, CONST CvLevMarq_CALC_J=2, CONST CvLevMarq_CHECK_ERR=3, CONST LMEDS=4, CONST RANSAC=8, CONST RHO=16, CONST CALIB_CB_ADAPTIVE_THRESH=1, CONST CALIB_CB_NORMALIZE_IMAGE=2, CONST CALIB_CB_FILTER_QUADS=4, CONST CALIB_CB_FAST_CHECK=8, CONST CALIB_CB_EXHAUSTIVE=16, CONST CALIB_CB_ACCURACY=32, CONST CALIB_CB_LARGER=64, CONST CALIB_CB_MARKER=128, CONST CALIB_CB_SYMMETRIC_GRID=1, CONST CALIB_CB_ASYMMETRIC_GRID=2, CONST CALIB_CB_CLUSTERING=4, CONST CALIB_NINTRINSIC=18, CONST CALIB_USE_INTRINSIC_GUESS=0x00001, CONST CALIB_FIX_ASPECT_RATIO=0x00002, CONST CALIB_FIX_PRINCIPAL_POINT=0x00004, CONST CALIB_ZERO_TANGENT_DIST=0x00008, CONST CALIB_FIX_FOCAL_LENGTH=0x00010, CONST CALIB_FIX_K1=0x00020, CONST CALIB_FIX_K2=0x00040, CONST CALIB_FIX_K3=0x00080, CONST CALIB_FIX_K4=0x00800, CONST CALIB_FIX_K5=0x01000, CONST CALIB_FIX_K6=0x02000, CONST CALIB_RATIONAL_MODEL=0x04000, CONST CALIB_THIN_PRISM_MODEL=0x08000, CONST CALIB_FIX_S1_S2_S3_S4=0x10000, CONST CALIB_TILTED_MODEL=0x40000, CONST CALIB_FIX_TAUX_TAUY=0x80000, CONST CALIB_USE_QR=0x100000, CONST CALIB_FIX_TANGENT_DIST=0x200000, CONST CALIB_FIX_INTRINSIC=0x00100, CONST CALIB_SAME_FOCAL_LENGTH=0x00200, CONST CALIB_ZERO_DISPARITY=0x00400, CONST CALIB_USE_LU=(1 << 17), CONST CALIB_USE_EXTRINSIC_GUESS=(1 << 22), CONST FM_7POINT=1, CONST FM_8POINT=2, CONST FM_LMEDS=4, CONST FM_RANSAC=8, CONST fisheye_CALIB_USE_INTRINSIC_GUESS=1 << 0, CONST fisheye_CALIB_RECOMPUTE_EXTRINSIC=1 << 1, CONST fisheye_CALIB_CHECK_COND=1 << 2, CONST fisheye_CALIB_FIX_SKEW=1 << 3, CONST fisheye_CALIB_FIX_K1=1 << 4, CONST fisheye_CALIB_FIX_K2=1 << 5, CONST fisheye_CALIB_FIX_K3=1 << 6, CONST fisheye_CALIB_FIX_K4=1 << 7, CONST fisheye_CALIB_FIX_INTRINSIC=1 << 8, CONST fisheye_CALIB_FIX_PRINCIPAL_POINT=1 << 9]
[CONST PROJ_SPHERICAL_ORTHO=0, CONST PROJ_SPHERICAL_EQRECT=1]
[CONST SOLVEPNP_ITERATIVE=0, CONST SOLVEPNP_EPNP=1, CONST SOLVEPNP_P3P=2, CONST SOLVEPNP_DLS=3, CONST SOLVEPNP_UPNP=4, CONST SOLVEPNP_AP3P=5, CONST SOLVEPNP_IPPE=6, CONST SOLVEPNP_IPPE_SQUARE=7, CONST SOLVEPNP_MAX_COUNT=7+1]
[CONST CALIB_HAND_EYE_TSAI=0, CONST CALIB_HAND_EYE_PARK=1, CONST CALIB_HAND_EYE_HORAUD=2, CONST CALIB_HAND_EYE_ANDREFF=3, CONST CALIB_HAND_EYE_DANIILIDIS=4]
[CONST CirclesGridFinderParameters_SYMMETRIC_GRID=0, CONST CirclesGridFinderParameters_ASYMMETRIC_GRID=1]
FUNC <Mat cv..estimateAffine2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence, long refineIters)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers, int method)
java: Mat estimateAffine2D(Mat from, Mat to, Mat inliers)
java: Mat estimateAffine2D(Mat from, Mat to)
FUNC <Mat cv..estimateAffinePartial2D [ARG Mat from=, ARG Mat to=, ARG Mat inliers=Mat(), ARG int method=RANSAC, ARG double ransacReprojThreshold=3, ARG size_t maxIters=2000, ARG double confidence=0.99, ARG size_t refineIters=10]>
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence, long refineIters)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters, double confidence)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold, long maxIters)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method, double ransacReprojThreshold)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers, int method)
java: Mat estimateAffinePartial2D(Mat from, Mat to, Mat inliers)
java: Mat estimateAffinePartial2D(Mat from, Mat to)
FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob, double threshold, Mat mask)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob, double threshold)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method, double prob)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix, int method)
java: Mat findEssentialMat(Mat points1, Mat points2, Mat cameraMatrix)
FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob, double threshold, Mat mask)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob, double threshold)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method, double prob)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp, int method)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal, Point pp)
java: Mat findEssentialMat(Mat points1, Mat points2, double focal)
java: Mat findEssentialMat(Mat points1, Mat points2)
FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=, ARG double ransacReprojThreshold=, ARG double confidence=, ARG int maxIters=, ARG Mat mask=Mat()]>
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence, int maxIters, Mat mask)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence, int maxIters)
FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=FM_RANSAC, ARG double ransacReprojThreshold=3., ARG double confidence=0.99, ARG Mat mask=Mat()]>
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence, Mat mask)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold, double confidence)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method, double ransacReprojThreshold)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2, int method)
java: Mat findFundamentalMat(MatOfPoint2f points1, MatOfPoint2f points2)
FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG int method=0, ARG double ransacReprojThreshold=3, ARG Mat mask=Mat(), ARG int maxIters=2000, ARG double confidence=0.995]>
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask, int maxIters, double confidence)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask, int maxIters)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold, Mat mask)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method, double ransacReprojThreshold)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints, int method)
java: Mat findHomography(MatOfPoint2f srcPoints, MatOfPoint2f dstPoints)
FUNC <Mat cv..getDefaultNewCameraMatrix [ARG Mat cameraMatrix=, ARG Size imgsize=Size(), ARG bool centerPrincipalPoint=false]>
java: Mat getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize, boolean centerPrincipalPoint)
java: Mat getDefaultNewCameraMatrix(Mat cameraMatrix, Size imgsize)
java: Mat getDefaultNewCameraMatrix(Mat cameraMatrix)
FUNC <Mat cv..getOptimalNewCameraMatrix [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG double alpha=, ARG Size newImgSize=Size(), ARG Rect * validPixROI=0, ARG bool centerPrincipalPoint=false]>
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect validPixROI, boolean centerPrincipalPoint)
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect validPixROI)
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha, Size newImgSize)
java: Mat getOptimalNewCameraMatrix(Mat cameraMatrix, Mat distCoeffs, Size imageSize, double alpha)
FUNC <Mat cv..initCameraMatrix2D [ARG vector_vector_Point3f objectPoints=, ARG vector_vector_Point2f imagePoints=, ARG Size imageSize=, ARG double aspectRatio=1.0]>
java: Mat initCameraMatrix2D(List<MatOfPoint3f> objectPoints, List<MatOfPoint2f> imagePoints, Size imageSize, double aspectRatio)
java: Mat initCameraMatrix2D(List<MatOfPoint3f> objectPoints, List<MatOfPoint2f> imagePoints, Size imageSize)
FUNC <Rect cv..getValidDisparityROI [ARG Rect roi1=, ARG Rect roi2=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int blockSize=]>
java: Rect getValidDisparityROI(Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int blockSize)
FUNC <Scalar cv..estimateChessboardSharpness [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG float rise_distance=0.8F, ARG bool vertical=false, ARG Mat sharpness=Mat()]>
java: Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners, float rise_distance, boolean vertical, Mat sharpness)
java: Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners, float rise_distance, boolean vertical)
java: Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners, float rise_distance)
java: Scalar estimateChessboardSharpness(Mat image, Size patternSize, Mat corners)
FUNC <Vec3d cv..RQDecomp3x3 [ARG Mat src=, ARG Mat mtxR=, ARG Mat mtxQ=, ARG Mat Qx=Mat(), ARG Mat Qy=Mat(), ARG Mat Qz=Mat()]>
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx, Mat Qy, Mat Qz)
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx, Mat Qy)
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ, Mat Qx)
java: double[] RQDecomp3x3(Mat src, Mat mtxR, Mat mtxQ)
FUNC <bool cv..checkChessboard [ARG Mat img=, ARG Size size=]>
java: boolean checkChessboard(Mat img, Size size)
FUNC <bool cv..find4QuadCornerSubpix [ARG Mat img=, ARG Mat corners=, ARG Size region_size=]>
java: boolean find4QuadCornerSubpix(Mat img, Mat corners, Size region_size)
FUNC <bool cv..findChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE]>
java: boolean findChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners, int flags)
java: boolean findChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners)
FUNC <bool cv..findChessboardCornersSB [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG int flags=, ARG Mat meta=]>
java: boolean findChessboardCornersSBWithMeta(Mat image, Size patternSize, Mat corners, int flags, Mat meta)
FUNC <bool cv..findChessboardCornersSB [ARG Mat image=, ARG Size patternSize=, ARG Mat corners=, ARG int flags=0]>
java: boolean findChessboardCornersSB(Mat image, Size patternSize, Mat corners, int flags)
java: boolean findChessboardCornersSB(Mat image, Size patternSize, Mat corners)
FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=, ARG Ptr_FeatureDetector blobDetector=, ARG CirclesGridFinderParameters parameters=]>
SKIP:bool cv::findCirclesGrid(Mat image, Size patternSize, Mat& centers, int flags, Ptr_FeatureDetector blobDetector, CirclesGridFinderParameters parameters)	 due to ARG type Ptr_FeatureDetector/I
FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=CALIB_CB_SYMMETRIC_GRID, ARG Ptr_FeatureDetector blobDetector=SimpleBlobDetector::create()]>
java: boolean findCirclesGrid(Mat image, Size patternSize, Mat centers, int flags)
java: boolean findCirclesGrid(Mat image, Size patternSize, Mat centers, int flags)
java: boolean findCirclesGrid(Mat image, Size patternSize, Mat centers)
FUNC <bool cv..solvePnP [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int flags=SOLVEPNP_ITERATIVE]>
java: boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int flags)
java: boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: boolean solvePnP(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec)
FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int iterationsCount=100, ARG float reprojectionError=8.0, ARG double confidence=0.99, ARG Mat inliers=Mat(), ARG int flags=SOLVEPNP_ITERATIVE]>
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence, Mat inliers, int flags)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence, Mat inliers)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError, double confidence)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount, float reprojectionError)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess, int iterationsCount)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec, boolean useExtrinsicGuess)
java: boolean solvePnPRansac(MatOfPoint3f objectPoints, MatOfPoint2f imagePoints, Mat cameraMatrix, MatOfDouble distCoeffs, Mat rvec, Mat tvec)
FUNC <bool cv..stereoRectifyUncalibrated [ARG Mat points1=, ARG Mat points2=, ARG Mat F=, ARG Size imgSize=, ARG Mat H1=, ARG Mat H2=, ARG double threshold=5]>
java: boolean stereoRectifyUncalibrated(Mat points1, Mat points2, Mat F, Size imgSize, Mat H1, Mat H2, double threshold)
java: boolean stereoRectifyUncalibrated(Mat points1, Mat points2, Mat F, Size imgSize, Mat H1, Mat H2)
FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors, int flags)
java: double calibrateCameraExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat perViewErrors)
FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCamera(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double calibrateCamera(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double calibrateCamera(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs)
FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG Mat stdDeviationsIntrinsics=, ARG Mat stdDeviationsExtrinsics=, ARG Mat stdDeviationsObjPoints=, ARG Mat perViewErrors=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraROExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors, int flags, TermCriteria criteria)
java: double calibrateCameraROExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors, int flags)
java: double calibrateCameraROExtended(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, Mat stdDeviationsIntrinsics, Mat stdDeviationsExtrinsics, Mat stdDeviationsObjPoints, Mat perViewErrors)
FUNC <double cv..calibrateCameraRO [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG int iFixedPoint=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG Mat newObjPoints=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
java: double calibrateCameraRO(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, int flags, TermCriteria criteria)
java: double calibrateCameraRO(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints, int flags)
java: double calibrateCameraRO(List<Mat> objectPoints, List<Mat> imagePoints, Size imageSize, int iFixedPoint, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, Mat newObjPoints)
FUNC <double cv..sampsonDistance [ARG Mat pt1=, ARG Mat pt2=, ARG Mat F=]>
java: double sampsonDistance(Mat pt1, Mat pt2, Mat F)
FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG Mat perViewErrors=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>
java: double stereoCalibrateExtended(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors, int flags, TermCriteria criteria)
java: double stereoCalibrateExtended(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors, int flags)
java: double stereoCalibrateExtended(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, Mat perViewErrors)
FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, int flags, TermCriteria criteria)
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F, int flags)
java: double stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat E, Mat F)
FUNC <double cv.fisheye..calibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size image_size=, ARG Mat K=, ARG Mat D=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>
java: double fisheye_calibrate(List<Mat> objectPoints, List<Mat> imagePoints, Size image_size, Mat K, Mat D, List<Mat> rvecs, List<Mat> tvecs, int flags, TermCriteria criteria)
java: double fisheye_calibrate(List<Mat> objectPoints, List<Mat> imagePoints, Size image_size, Mat K, Mat D, List<Mat> rvecs, List<Mat> tvecs, int flags)
java: double fisheye_calibrate(List<Mat> objectPoints, List<Mat> imagePoints, Size image_size, Mat K, Mat D, List<Mat> rvecs, List<Mat> tvecs)
FUNC <double cv.fisheye..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG int flags=fisheye::CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON)]>
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T, int flags, TermCriteria criteria)
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T, int flags)
java: double fisheye_stereoCalibrate(List<Mat> objectPoints, List<Mat> imagePoints1, List<Mat> imagePoints2, Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat T)
FUNC <float cv..rectify3Collinear [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat cameraMatrix3=, ARG Mat distCoeffs3=, ARG vector_Mat imgpt1=, ARG vector_Mat imgpt3=, ARG Size imageSize=, ARG Mat R12=, ARG Mat T12=, ARG Mat R13=, ARG Mat T13=, ARG Mat R1=, ARG Mat R2=, ARG Mat R3=, ARG Mat P1=, ARG Mat P2=, ARG Mat P3=, ARG Mat Q=, ARG double alpha=, ARG Size newImgSize=, ARG Rect * roi1=, ARG Rect * roi2=, ARG int flags=]>
java: float rectify3Collinear(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat cameraMatrix3, Mat distCoeffs3, List<Mat> imgpt1, List<Mat> imgpt3, Size imageSize, Mat R12, Mat T12, Mat R13, Mat T13, Mat R1, Mat R2, Mat R3, Mat P1, Mat P2, Mat P3, Mat Q, double alpha, Size newImgSize, Rect roi1, Rect roi2, int flags)
FUNC <int cv..decomposeHomographyMat [ARG Mat H=, ARG Mat K=, ARG vector_Mat rotations=, ARG vector_Mat translations=, ARG vector_Mat normals=]>
java: int decomposeHomographyMat(Mat H, Mat K, List<Mat> rotations, List<Mat> translations, List<Mat> normals)
FUNC <int cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>
java: int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold, double confidence)
java: int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers, double ransacThreshold)
java: int estimateAffine3D(Mat src, Mat dst, Mat out, Mat inliers)
FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat R=, ARG Mat t=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG Mat mask=Mat()]>
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal, Point pp, Mat mask)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal, Point pp)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t, double focal)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat R, Mat t)
FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG Mat mask=Mat()]>
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, Mat mask)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t)
FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat cameraMatrix=, ARG Mat R=, ARG Mat t=, ARG double distanceThresh=, ARG Mat mask=Mat(), ARG Mat triangulatedPoints=Mat()]>
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh, Mat mask, Mat triangulatedPoints)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh, Mat mask)
java: int recoverPose(Mat E, Mat points1, Mat points2, Mat cameraMatrix, Mat R, Mat t, double distanceThresh)
FUNC <int cv..solveP3P [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=]>
java: int solveP3P(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, int flags)
FUNC <int cv..solvePnPGeneric [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG bool useExtrinsicGuess=false, ARG SolvePnPMethod flags=SOLVEPNP_ITERATIVE, ARG Mat rvec=Mat(), ARG Mat tvec=Mat(), ARG Mat reprojectionError=Mat()]>
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags, Mat rvec, Mat tvec, Mat reprojectionError)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags, Mat rvec, Mat tvec)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags, Mat rvec)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess, int flags)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs, boolean useExtrinsicGuess)
java: int solvePnPGeneric(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, List<Mat> rvecs, List<Mat> tvecs)
FUNC <void cv..Rodrigues [ARG Mat src=, ARG Mat dst=, ARG Mat jacobian=Mat()]>
java: void Rodrigues(Mat src, Mat dst, Mat jacobian)
java: void Rodrigues(Mat src, Mat dst)
FUNC <void cv..calibrateHandEye [ARG vector_Mat R_gripper2base=, ARG vector_Mat t_gripper2base=, ARG vector_Mat R_target2cam=, ARG vector_Mat t_target2cam=, ARG Mat R_cam2gripper=, ARG Mat t_cam2gripper=, ARG HandEyeCalibrationMethod method=CALIB_HAND_EYE_TSAI]>
java: void calibrateHandEye(List<Mat> R_gripper2base, List<Mat> t_gripper2base, List<Mat> R_target2cam, List<Mat> t_target2cam, Mat R_cam2gripper, Mat t_cam2gripper, int method)
java: void calibrateHandEye(List<Mat> R_gripper2base, List<Mat> t_gripper2base, List<Mat> R_target2cam, List<Mat> t_target2cam, Mat R_cam2gripper, Mat t_cam2gripper)
FUNC <void cv..calibrationMatrixValues [ARG Mat cameraMatrix=, ARG Size imageSize=, ARG double apertureWidth=, ARG double apertureHeight=, ARG double fovx=, ARG double fovy=, ARG double focalLength=, ARG Point2d principalPoint=, ARG double aspectRatio=]>
java: void calibrationMatrixValues(Mat cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double[] fovx, double[] fovy, double[] focalLength, Point principalPoint, double[] aspectRatio)
FUNC <void cv..composeRT [ARG Mat rvec1=, ARG Mat tvec1=, ARG Mat rvec2=, ARG Mat tvec2=, ARG Mat rvec3=, ARG Mat tvec3=, ARG Mat dr3dr1=Mat(), ARG Mat dr3dt1=Mat(), ARG Mat dr3dr2=Mat(), ARG Mat dr3dt2=Mat(), ARG Mat dt3dr1=Mat(), ARG Mat dt3dt1=Mat(), ARG Mat dt3dr2=Mat(), ARG Mat dt3dt2=Mat()]>
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1, Mat dt3dr2, Mat dt3dt2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1, Mat dt3dr2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1, Mat dt3dt1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2, Mat dt3dr1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2, Mat dr3dt2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1, Mat dr3dr2)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1, Mat dr3dt1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3, Mat dr3dr1)
java: void composeRT(Mat rvec1, Mat tvec1, Mat rvec2, Mat tvec2, Mat rvec3, Mat tvec3)
FUNC <void cv..computeCorrespondEpilines [ARG Mat points=, ARG int whichImage=, ARG Mat F=, ARG Mat lines=]>
java: void computeCorrespondEpilines(Mat points, int whichImage, Mat F, Mat lines)
FUNC <void cv..convertPointsFromHomogeneous [ARG Mat src=, ARG Mat dst=]>
java: void convertPointsFromHomogeneous(Mat src, Mat dst)
FUNC <void cv..convertPointsToHomogeneous [ARG Mat src=, ARG Mat dst=]>
java: void convertPointsToHomogeneous(Mat src, Mat dst)
FUNC <void cv..correctMatches [ARG Mat F=, ARG Mat points1=, ARG Mat points2=, ARG Mat newPoints1=, ARG Mat newPoints2=]>
java: void correctMatches(Mat F, Mat points1, Mat points2, Mat newPoints1, Mat newPoints2)
FUNC <void cv..decomposeEssentialMat [ARG Mat E=, ARG Mat R1=, ARG Mat R2=, ARG Mat t=]>
java: void decomposeEssentialMat(Mat E, Mat R1, Mat R2, Mat t)
FUNC <void cv..decomposeProjectionMatrix [ARG Mat projMatrix=, ARG Mat cameraMatrix=, ARG Mat rotMatrix=, ARG Mat transVect=, ARG Mat rotMatrixX=Mat(), ARG Mat rotMatrixY=Mat(), ARG Mat rotMatrixZ=Mat(), ARG Mat eulerAngles=Mat()]>
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY, Mat rotMatrixZ, Mat eulerAngles)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY, Mat rotMatrixZ)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX, Mat rotMatrixY)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect, Mat rotMatrixX)
java: void decomposeProjectionMatrix(Mat projMatrix, Mat cameraMatrix, Mat rotMatrix, Mat transVect)
FUNC <void cv..drawChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG bool patternWasFound=]>
java: void drawChessboardCorners(Mat image, Size patternSize, MatOfPoint2f corners, boolean patternWasFound)
FUNC <void cv..drawFrameAxes [ARG Mat image=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG float length=, ARG int thickness=3]>
java: void drawFrameAxes(Mat image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length, int thickness)
java: void drawFrameAxes(Mat image, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, float length)
FUNC <void cv..filterHomographyDecompByVisibleRefpoints [ARG vector_Mat rotations=, ARG vector_Mat normals=, ARG Mat beforePoints=, ARG Mat afterPoints=, ARG Mat possibleSolutions=, ARG Mat pointsMask=Mat()]>
java: void filterHomographyDecompByVisibleRefpoints(List<Mat> rotations, List<Mat> normals, Mat beforePoints, Mat afterPoints, Mat possibleSolutions, Mat pointsMask)
java: void filterHomographyDecompByVisibleRefpoints(List<Mat> rotations, List<Mat> normals, Mat beforePoints, Mat afterPoints, Mat possibleSolutions)
FUNC <void cv..filterSpeckles [ARG Mat img=, ARG double newVal=, ARG int maxSpeckleSize=, ARG double maxDiff=, ARG Mat buf=Mat()]>
java: void filterSpeckles(Mat img, double newVal, int maxSpeckleSize, double maxDiff, Mat buf)
java: void filterSpeckles(Mat img, double newVal, int maxSpeckleSize, double maxDiff)
FUNC <void cv..initUndistortRectifyMap [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat newCameraMatrix=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>
java: void initUndistortRectifyMap(Mat cameraMatrix, Mat distCoeffs, Mat R, Mat newCameraMatrix, Size size, int m1type, Mat map1, Mat map2)
FUNC <void cv..matMulDeriv [ARG Mat A=, ARG Mat B=, ARG Mat dABdA=, ARG Mat dABdB=]>
java: void matMulDeriv(Mat A, Mat B, Mat dABdA, Mat dABdB)
FUNC <void cv..projectPoints [ARG vector_Point3f objectPoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG vector_Point2f imagePoints=, ARG Mat jacobian=Mat(), ARG double aspectRatio=0]>
java: void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints, Mat jacobian, double aspectRatio)
java: void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints, Mat jacobian)
java: void projectPoints(MatOfPoint3f objectPoints, Mat rvec, Mat tvec, Mat cameraMatrix, MatOfDouble distCoeffs, MatOfPoint2f imagePoints)
FUNC <void cv..reprojectImageTo3D [ARG Mat disparity=, ARG Mat _3dImage=, ARG Mat Q=, ARG bool handleMissingValues=false, ARG int ddepth=-1]>
java: void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q, boolean handleMissingValues, int ddepth)
java: void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q, boolean handleMissingValues)
java: void reprojectImageTo3D(Mat disparity, Mat _3dImage, Mat Q)
FUNC <void cv..solvePnPRefineLM [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON)]>
java: void solvePnPRefineLM(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria)
java: void solvePnPRefineLM(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <void cv..solvePnPRefineVVS [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON), ARG double VVSlambda=1]>
java: void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria, double VVSlambda)
java: void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec, TermCriteria criteria)
java: void solvePnPRefineVVS(Mat objectPoints, Mat imagePoints, Mat cameraMatrix, Mat distCoeffs, Mat rvec, Mat tvec)
FUNC <void cv..stereoRectify [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=CALIB_ZERO_DISPARITY, ARG double alpha=-1, ARG Size newImageSize=Size(), ARG Rect * validPixROI1=0, ARG Rect * validPixROI2=0]>
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize, Rect validPixROI1, Rect validPixROI2)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize, Rect validPixROI1)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha, Size newImageSize)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, double alpha)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags)
java: void stereoRectify(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Size imageSize, Mat R, Mat T, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q)
FUNC <void cv..triangulatePoints [ARG Mat projMatr1=, ARG Mat projMatr2=, ARG Mat projPoints1=, ARG Mat projPoints2=, ARG Mat points4D=]>
java: void triangulatePoints(Mat projMatr1, Mat projMatr2, Mat projPoints1, Mat projPoints2, Mat points4D)
FUNC <void cv..undistort [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat newCameraMatrix=Mat()]>
java: void undistort(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, Mat newCameraMatrix)
java: void undistort(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs)
FUNC <void cv..undistortPoints [ARG Mat src=, ARG Mat dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=, ARG Mat P=, ARG TermCriteria criteria=]>
java: void undistortPointsIter(Mat src, Mat dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P, TermCriteria criteria)
FUNC <void cv..undistortPoints [ARG vector_Point2f src=, ARG vector_Point2f dst=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Mat R=Mat(), ARG Mat P=Mat()]>
java: void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs, Mat R, Mat P)
java: void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs, Mat R)
java: void undistortPoints(MatOfPoint2f src, MatOfPoint2f dst, Mat cameraMatrix, Mat distCoeffs)
FUNC <void cv..validateDisparity [ARG Mat disparity=, ARG Mat cost=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int disp12MaxDisp=1]>
java: void validateDisparity(Mat disparity, Mat cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp)
java: void validateDisparity(Mat disparity, Mat cost, int minDisparity, int numberOfDisparities)
FUNC <void cv.fisheye..distortPoints [ARG Mat undistorted=, ARG Mat distorted=, ARG Mat K=, ARG Mat D=, ARG double alpha=0]>
java: void fisheye_distortPoints(Mat undistorted, Mat distorted, Mat K, Mat D, double alpha)
java: void fisheye_distortPoints(Mat undistorted, Mat distorted, Mat K, Mat D)
FUNC <void cv.fisheye..estimateNewCameraMatrixForUndistortRectify [ARG Mat K=, ARG Mat D=, ARG Size image_size=, ARG Mat R=, ARG Mat P=, ARG double balance=0.0, ARG Size new_size=Size(), ARG double fov_scale=1.0]>
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance, Size new_size, double fov_scale)
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance, Size new_size)
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P, double balance)
java: void fisheye_estimateNewCameraMatrixForUndistortRectify(Mat K, Mat D, Size image_size, Mat R, Mat P)
FUNC <void cv.fisheye..initUndistortRectifyMap [ARG Mat K=, ARG Mat D=, ARG Mat R=, ARG Mat P=, ARG Size size=, ARG int m1type=, ARG Mat map1=, ARG Mat map2=]>
java: void fisheye_initUndistortRectifyMap(Mat K, Mat D, Mat R, Mat P, Size size, int m1type, Mat map1, Mat map2)
FUNC <void cv.fisheye..projectPoints [ARG Mat objectPoints=, ARG Mat imagePoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat K=, ARG Mat D=, ARG double alpha=0, ARG Mat jacobian=Mat()]>
java: void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D, double alpha, Mat jacobian)
java: void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D, double alpha)
java: void fisheye_projectPoints(Mat objectPoints, Mat imagePoints, Mat rvec, Mat tvec, Mat K, Mat D)
FUNC <void cv.fisheye..stereoRectify [ARG Mat K1=, ARG Mat D1=, ARG Mat K2=, ARG Mat D2=, ARG Size imageSize=, ARG Mat R=, ARG Mat tvec=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=, ARG Size newImageSize=Size(), ARG double balance=0.0, ARG double fov_scale=1.0]>
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize, double balance, double fov_scale)
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize, double balance)
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags, Size newImageSize)
java: void fisheye_stereoRectify(Mat K1, Mat D1, Mat K2, Mat D2, Size imageSize, Mat R, Mat tvec, Mat R1, Mat R2, Mat P1, Mat P2, Mat Q, int flags)
FUNC <void cv.fisheye..undistortImage [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat Knew=cv::Mat(), ARG Size new_size=Size()]>
java: void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D, Mat Knew, Size new_size)
java: void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D, Mat Knew)
java: void fisheye_undistortImage(Mat distorted, Mat undistorted, Mat K, Mat D)
FUNC <void cv.fisheye..undistortPoints [ARG Mat distorted=, ARG Mat undistorted=, ARG Mat K=, ARG Mat D=, ARG Mat R=Mat(), ARG Mat P=Mat()]>
java: void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D, Mat R, Mat P)
java: void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D, Mat R)
java: void fisheye_undistortPoints(Mat distorted, Mat undistorted, Mat K, Mat D)

=== MODULE: highgui (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/highgui) ===


Files (0):
[]

Common headers (0):
[]
No generated code for module: highgui

=== MODULE: objdetect (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/objdetect) ===


Files (3):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/objdetect/include/opencv2/objdetect.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/objdetect/include/opencv2/objdetect/detection_based_tracker.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/objdetect/include/opencv2/objdetect/objdetect.hpp']

Common headers (0):
[]
ok: class CLASS ::.Objdetect : , name: Objdetect, base: 


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/objdetect/include/opencv2/objdetect.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'cv.groupRectangles',
    u'void',
    [],
    [   [u'vector_Rect', u'rectList', u'', ['/IO', '/Ref']],
        [u'vector_int', u'weights', u'', ['/O', '/Ref']],
        [u'int', u'groupThreshold', u'', []],
        [u'double', u'eps', u'0.2', []]],
    u'void']
ok: FUNC <void cv..groupRectangles [ARG vector_Rect rectList=, ARG vector_int weights=, ARG int groupThreshold=, ARG double eps=0.2]>

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.CASCADE_DO_CANNY_PRUNING', u'1', [], [], None, ''],
        [u'const cv.CASCADE_SCALE_IMAGE', u'2', [], [], None, ''],
        [u'const cv.CASCADE_FIND_BIGGEST_OBJECT', u'4', [], [], None, ''],
        [u'const cv.CASCADE_DO_ROUGH_SEARCH', u'8', [], [], None, '']],
    None]
ok: CONST CASCADE_DO_CANNY_PRUNING=1
ok: CONST CASCADE_SCALE_IMAGE=2
ok: CONST CASCADE_FIND_BIGGEST_OBJECT=4
ok: CONST CASCADE_DO_ROUGH_SEARCH=8

--- Incoming ---
[u'class cv.BaseCascadeClassifier', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.BaseCascadeClassifier : Algorithm, name: BaseCascadeClassifier, base: Algorithm

--- Incoming ---
[u'class cv.CascadeClassifier', '', [], [], None]
ok: class CLASS cv::.CascadeClassifier : , name: CascadeClassifier, base: 

--- Incoming ---
[u'cv.CascadeClassifier.CascadeClassifier', '', [], [], None]
ok: FUNC < cv.CascadeClassifier.CascadeClassifier []>

--- Incoming ---
[   u'cv.CascadeClassifier.CascadeClassifier',
    '',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.CascadeClassifier.CascadeClassifier [ARG String filename=]>

--- Incoming ---
[u'cv.CascadeClassifier.empty', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.CascadeClassifier.empty []>

--- Incoming ---
[   u'cv.CascadeClassifier.load',
    u'bool',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.CascadeClassifier.load [ARG String filename=]>

--- Incoming ---
[   u'cv.CascadeClassifier.read',
    u'bool',
    [],
    [[u'FileNode', u'node', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.CascadeClassifier.read [ARG FileNode node=]>

--- Incoming ---
[   u'cv.CascadeClassifier.detectMultiScale',
    u'void',
    [],
    [   ['Mat', u'image', '', []],
        [u'vector_Rect', u'objects', u'', ['/O', '/Ref']],
        [u'double', u'scaleFactor', u'1.1', []],
        [u'int', u'minNeighbors', u'3', []],
        [u'int', u'flags', u'0', []],
        [u'Size', u'minSize', u'Size()', []],
        [u'Size', u'maxSize', u'Size()', []]],
    u'void']
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>

--- Incoming ---
[   u'cv.CascadeClassifier.detectMultiScale',
    u'void',
    [u'=detectMultiScale2'],
    [   ['Mat', u'image', '', []],
        [u'vector_Rect', u'objects', u'', ['/O', '/Ref']],
        [u'vector_int', u'numDetections', u'', ['/O', '/Ref']],
        [u'double', u'scaleFactor', u'1.1', []],
        [u'int', u'minNeighbors', u'3', []],
        [u'int', u'flags', u'0', []],
        [u'Size', u'minSize', u'Size()', []],
        [u'Size', u'maxSize', u'Size()', []]],
    u'void']
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int numDetections=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>

--- Incoming ---
[   u'cv.CascadeClassifier.detectMultiScale',
    u'void',
    [u'=detectMultiScale3'],
    [   ['Mat', u'image', '', []],
        [u'vector_Rect', u'objects', u'', ['/O', '/Ref']],
        [u'vector_int', u'rejectLevels', u'', ['/O', '/Ref']],
        [u'vector_double', u'levelWeights', u'', ['/O', '/Ref']],
        [u'double', u'scaleFactor', u'1.1', []],
        [u'int', u'minNeighbors', u'3', []],
        [u'int', u'flags', u'0', []],
        [u'Size', u'minSize', u'Size()', []],
        [u'Size', u'maxSize', u'Size()', []],
        [u'bool', u'outputRejectLevels', u'false', []]],
    u'void']
ok: FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int rejectLevels=, ARG vector_double levelWeights=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size(), ARG bool outputRejectLevels=false]>

--- Incoming ---
[u'cv.CascadeClassifier.isOldFormatCascade', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.CascadeClassifier.isOldFormatCascade []>

--- Incoming ---
[u'cv.CascadeClassifier.getOriginalWindowSize', u'Size', ['/C'], [], u'Size']
ok: FUNC <Size cv.CascadeClassifier.getOriginalWindowSize []>

--- Incoming ---
[u'cv.CascadeClassifier.getFeatureType', u'int', ['/C'], [], u'int']
ok: FUNC <int cv.CascadeClassifier.getFeatureType []>

--- Incoming ---
[   u'cv.CascadeClassifier.convert',
    u'bool',
    ['/S'],
    [   [u'String', u'oldcascade', u'', ['/C', '/Ref']],
        [u'String', u'newcascade', u'', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.CascadeClassifier.convert [ARG String oldcascade=, ARG String newcascade=]>

--- Incoming ---
[   u'struct cv.HOGDescriptor',
    '',
    [],
    [   [u'Size', u'winSize', '', []],
        [u'Size', u'blockSize', '', []],
        [u'Size', u'blockStride', '', []],
        [u'Size', u'cellSize', '', []],
        [u'int', u'nbins', '', []],
        [u'int', u'derivAperture', '', []],
        [u'double', u'winSigma', '', []],
        [u'HOGDescriptor_HistogramNormType', u'histogramNormType', '', []],
        [u'double', u'L2HysThreshold', '', []],
        [u'bool', u'gammaCorrection', '', []],
        [u'vector_float', u'svmDetector', '', []],
        [u'int', u'nlevels', '', []],
        [u'bool', u'signedGradient', '', []]],
    None]
ok: class CLASS cv::.HOGDescriptor : , name: HOGDescriptor, base: 

--- Incoming ---
[   u'enum cv.HOGDescriptor.HistogramNormType',
    '',
    [],
    [[u'const cv.HOGDescriptor.L2Hys', u'0', [], [], None, '']],
    None]
ok: CONST L2Hys=0

--- Incoming ---
[   u'enum cv.HOGDescriptor.<unnamed>',
    '',
    [],
    [[u'const cv.HOGDescriptor.DEFAULT_NLEVELS', u'64', [], [], None, '']],
    None]
ok: CONST DEFAULT_NLEVELS=64

--- Incoming ---
[   u'enum cv.HOGDescriptor.DescriptorStorageFormat',
    '',
    [],
    [   [   u'const cv.HOGDescriptor.DESCR_FORMAT_COL_BY_COL',
            '0',
            [],
            [],
            None,
            ''],
        [   u'const cv.HOGDescriptor.DESCR_FORMAT_ROW_BY_ROW',
            '1',
            [],
            [],
            None,
            '']],
    None]
ok: CONST DESCR_FORMAT_COL_BY_COL=0
ok: CONST DESCR_FORMAT_ROW_BY_ROW=1

--- Incoming ---
[u'cv.HOGDescriptor.HOGDescriptor', '', [], [], None]
ok: FUNC < cv.HOGDescriptor.HOGDescriptor []>

--- Incoming ---
[   u'cv.HOGDescriptor.HOGDescriptor',
    '',
    [],
    [   [u'Size', u'_winSize', u'', []],
        [u'Size', u'_blockSize', u'', []],
        [u'Size', u'_blockStride', u'', []],
        [u'Size', u'_cellSize', u'', []],
        [u'int', u'_nbins', u'', []],
        [u'int', u'_derivAperture', u'1', []],
        [u'double', u'_winSigma', u'-1', []],
        [   u'HOGDescriptor_HistogramNormType',
            u'_histogramNormType',
            u'HOGDescriptor::L2Hys',
            []],
        [u'double', u'_L2HysThreshold', u'0.2', []],
        [u'bool', u'_gammaCorrection', u'false', []],
        [u'int', u'_nlevels', u'HOGDescriptor::DEFAULT_NLEVELS', []],
        [u'bool', u'_signedGradient', u'false', []]],
    None]
ok: FUNC < cv.HOGDescriptor.HOGDescriptor [ARG Size _winSize=, ARG Size _blockSize=, ARG Size _blockStride=, ARG Size _cellSize=, ARG int _nbins=, ARG int _derivAperture=1, ARG double _winSigma=-1, ARG HOGDescriptor_HistogramNormType _histogramNormType=HOGDescriptor::L2Hys, ARG double _L2HysThreshold=0.2, ARG bool _gammaCorrection=false, ARG int _nlevels=HOGDescriptor::DEFAULT_NLEVELS, ARG bool _signedGradient=false]>

--- Incoming ---
[   u'cv.HOGDescriptor.HOGDescriptor',
    '',
    [],
    [[u'String', u'filename', u'', ['/C', '/Ref']]],
    None]
ok: FUNC < cv.HOGDescriptor.HOGDescriptor [ARG String filename=]>

--- Incoming ---
[u'cv.HOGDescriptor.getDescriptorSize', u'size_t', ['/C'], [], u'size_t']
ok: FUNC <size_t cv.HOGDescriptor.getDescriptorSize []>

--- Incoming ---
[u'cv.HOGDescriptor.checkDetectorSize', u'bool', ['/C'], [], u'bool']
ok: FUNC <bool cv.HOGDescriptor.checkDetectorSize []>

--- Incoming ---
[u'cv.HOGDescriptor.getWinSigma', u'double', ['/C'], [], u'double']
ok: FUNC <double cv.HOGDescriptor.getWinSigma []>

--- Incoming ---
[   u'cv.HOGDescriptor.setSVMDetector',
    u'void',
    ['/V'],
    [['Mat', u'svmdetector', '', []]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.setSVMDetector [ARG Mat svmdetector=]>

--- Incoming ---
[   u'cv.HOGDescriptor.load',
    u'bool',
    ['/V'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'String', u'objname', u'String()', ['/C', '/Ref']]],
    u'bool']
ok: FUNC <bool cv.HOGDescriptor.load [ARG String filename=, ARG String objname=String()]>

--- Incoming ---
[   u'cv.HOGDescriptor.save',
    u'void',
    ['/C', '/V'],
    [   [u'String', u'filename', u'', ['/C', '/Ref']],
        [u'String', u'objname', u'String()', ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.save [ARG String filename=, ARG String objname=String()]>

--- Incoming ---
[   u'cv.HOGDescriptor.compute',
    u'void',
    ['/C', '/V'],
    [   ['Mat', u'img', '', []],
        [u'vector_float', u'descriptors', u'', ['/O', '/Ref']],
        [u'Size', u'winStride', u'Size()', []],
        [u'Size', u'padding', u'Size()', []],
        [   u'vector_Point',
            u'locations',
            u'std::vector<Point>()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.compute [ARG Mat img=, ARG vector_float descriptors=, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point locations=std::vector<Point>()]>

--- Incoming ---
[   u'cv.HOGDescriptor.detect',
    u'void',
    ['/C', '/V'],
    [   ['Mat', u'img', '', []],
        [u'vector_Point', u'foundLocations', u'', ['/O', '/Ref']],
        [u'vector_double', u'weights', u'', ['/O', '/Ref']],
        [u'double', u'hitThreshold', u'0', []],
        [u'Size', u'winStride', u'Size()', []],
        [u'Size', u'padding', u'Size()', []],
        [   u'vector_Point',
            u'searchLocations',
            u'std::vector<Point>()',
            ['/C', '/Ref']]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.detect [ARG Mat img=, ARG vector_Point foundLocations=, ARG vector_double weights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point searchLocations=std::vector<Point>()]>

--- Incoming ---
[   u'cv.HOGDescriptor.detectMultiScale',
    u'void',
    ['/C', '/V'],
    [   ['Mat', u'img', '', []],
        [u'vector_Rect', u'foundLocations', u'', ['/O', '/Ref']],
        [u'vector_double', u'foundWeights', u'', ['/O', '/Ref']],
        [u'double', u'hitThreshold', u'0', []],
        [u'Size', u'winStride', u'Size()', []],
        [u'Size', u'padding', u'Size()', []],
        [u'double', u'scale', u'1.05', []],
        [u'double', u'finalThreshold', u'2.0', []],
        [u'bool', u'useMeanshiftGrouping', u'false', []]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.detectMultiScale [ARG Mat img=, ARG vector_Rect foundLocations=, ARG vector_double foundWeights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG double scale=1.05, ARG double finalThreshold=2.0, ARG bool useMeanshiftGrouping=false]>

--- Incoming ---
[   u'cv.HOGDescriptor.computeGradient',
    u'void',
    ['/C', '/V'],
    [   ['Mat', u'img', '', []],
        ['Mat', u'grad', '', ['/IO']],
        ['Mat', u'angleOfs', '', ['/IO']],
        [u'Size', u'paddingTL', u'Size()', []],
        [u'Size', u'paddingBR', u'Size()', []]],
    u'void']
ok: FUNC <void cv.HOGDescriptor.computeGradient [ARG Mat img=, ARG Mat grad=, ARG Mat angleOfs=, ARG Size paddingTL=Size(), ARG Size paddingBR=Size()]>

--- Incoming ---
[   u'cv.HOGDescriptor.getDefaultPeopleDetector',
    u'vector_float',
    ['/S'],
    [],
    u'std::vector<float>']
ok: FUNC <vector_float cv.HOGDescriptor.getDefaultPeopleDetector []>

--- Incoming ---
[   u'cv.HOGDescriptor.getDaimlerPeopleDetector',
    u'vector_float',
    ['/S'],
    [],
    u'std::vector<float>']
ok: FUNC <vector_float cv.HOGDescriptor.getDaimlerPeopleDetector []>

--- Incoming ---
[u'class cv.QRCodeDetector', '', [], [], None]
ok: class CLASS cv::.QRCodeDetector : , name: QRCodeDetector, base: 

--- Incoming ---
[u'cv.QRCodeDetector.QRCodeDetector', '', [], [], None]
ok: FUNC < cv.QRCodeDetector.QRCodeDetector []>

--- Incoming ---
[   u'cv.QRCodeDetector.setEpsX',
    u'void',
    [],
    [[u'double', u'epsX', u'', []]],
    u'void']
ok: FUNC <void cv.QRCodeDetector.setEpsX [ARG double epsX=]>

--- Incoming ---
[   u'cv.QRCodeDetector.setEpsY',
    u'void',
    [],
    [[u'double', u'epsY', u'', []]],
    u'void']
ok: FUNC <void cv.QRCodeDetector.setEpsY [ARG double epsY=]>

--- Incoming ---
[   u'cv.QRCodeDetector.detect',
    u'bool',
    ['/C'],
    [['Mat', u'img', '', []], ['Mat', u'points', '', ['/O']]],
    u'bool']
ok: FUNC <bool cv.QRCodeDetector.detect [ARG Mat img=, ARG Mat points=]>

--- Incoming ---
[   u'cv.QRCodeDetector.decode',
    u'string',
    [],
    [   ['Mat', u'img', '', []],
        ['Mat', u'points', '', []],
        ['Mat', u'straight_qrcode', u'Mat()', ['/O']]],
    u'std::string']
ok: FUNC <string cv.QRCodeDetector.decode [ARG Mat img=, ARG Mat points=, ARG Mat straight_qrcode=Mat()]>

--- Incoming ---
[   u'cv.QRCodeDetector.detectAndDecode',
    u'string',
    [],
    [   ['Mat', u'img', '', []],
        ['Mat', u'points', u'Mat()', ['/O']],
        ['Mat', u'straight_qrcode', u'Mat()', ['/O']]],
    u'std::string']
ok: FUNC <string cv.QRCodeDetector.detectAndDecode [ARG Mat img=, ARG Mat points=Mat(), ARG Mat straight_qrcode=Mat()]>

--- Incoming ---
[   u'cv.QRCodeDetector.detectMulti',
    u'bool',
    ['/C'],
    [['Mat', u'img', '', []], ['Mat', u'points', '', ['/O']]],
    u'bool']
ok: FUNC <bool cv.QRCodeDetector.detectMulti [ARG Mat img=, ARG Mat points=]>

--- Incoming ---
[   u'cv.QRCodeDetector.decodeMulti',
    u'bool',
    ['/C'],
    [   ['Mat', u'img', '', []],
        ['Mat', u'points', '', []],
        [u'vector_string', u'decoded_info', u'', ['/O', '/Ref']],
        ['vector_Mat', u'straight_qrcode', u'vector_Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv.QRCodeDetector.decodeMulti [ARG Mat img=, ARG Mat points=, ARG vector_string decoded_info=, ARG vector_Mat straight_qrcode=vector_Mat()]>

--- Incoming ---
[   u'cv.QRCodeDetector.detectAndDecodeMulti',
    u'bool',
    ['/C'],
    [   ['Mat', u'img', '', []],
        [u'vector_string', u'decoded_info', u'', ['/O', '/Ref']],
        ['Mat', u'points', u'Mat()', ['/O']],
        ['vector_Mat', u'straight_qrcode', u'vector_Mat()', ['/O']]],
    u'bool']
ok: FUNC <bool cv.QRCodeDetector.detectAndDecodeMulti [ARG Mat img=, ARG vector_string decoded_info=, ARG Mat points=Mat(), ARG vector_Mat straight_qrcode=vector_Mat()]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/objdetect/include/opencv2/objdetect/detection_based_tracker.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'enum cv.DetectionBasedTracker.ObjectStatus',
    '',
    [],
    [   [   u'const cv.DetectionBasedTracker.DETECTED_NOT_SHOWN_YET',
            '0',
            [],
            [],
            None,
            ''],
        [u'const cv.DetectionBasedTracker.DETECTED', '1', [], [], None, ''],
        [   u'const cv.DetectionBasedTracker.DETECTED_TEMPORARY_LOST',
            '2',
            [],
            [],
            None,
            ''],
        [   u'const cv.DetectionBasedTracker.WRONG_OBJECT',
            '3',
            [],
            [],
            None,
            '']],
    None]
class not found: CONST DETECTED_NOT_SHOWN_YET=0
ok: CONST DetectionBasedTracker_DETECTED_NOT_SHOWN_YET=0
class not found: CONST DETECTED=1
ok: CONST DetectionBasedTracker_DETECTED=1
class not found: CONST DETECTED_TEMPORARY_LOST=2
ok: CONST DetectionBasedTracker_DETECTED_TEMPORARY_LOST=2
class not found: CONST WRONG_OBJECT=3
ok: CONST DetectionBasedTracker_WRONG_OBJECT=3


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/objdetect/include/opencv2/objdetect/objdetect.hpp =====
Namespaces: set([u'cv'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/objdetect/include/opencv2/objdetect/objdetect.hpp


===== Generating... =====
CLASS cv::.HOGDescriptor : 
[CONST DESCR_FORMAT_COL_BY_COL=0, CONST DESCR_FORMAT_ROW_BY_ROW=1]
[CONST L2Hys=0]
[CONST DEFAULT_NLEVELS=64]
FUNC < cv.HOGDescriptor.HOGDescriptor [ARG Size _winSize=, ARG Size _blockSize=, ARG Size _blockStride=, ARG Size _cellSize=, ARG int _nbins=, ARG int _derivAperture=1, ARG double _winSigma=-1, ARG HOGDescriptor_HistogramNormType _histogramNormType=HOGDescriptor::L2Hys, ARG double _L2HysThreshold=0.2, ARG bool _gammaCorrection=false, ARG int _nlevels=HOGDescriptor::DEFAULT_NLEVELS, ARG bool _signedGradient=false]>
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection, int _nlevels, boolean _signedGradient)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection, int _nlevels)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold, boolean _gammaCorrection)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType, double _L2HysThreshold)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma, int _histogramNormType)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture, double _winSigma)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins, int _derivAperture)
java:  HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size _cellSize, int _nbins)
FUNC < cv.HOGDescriptor.HOGDescriptor [ARG String filename=]>
java:  HOGDescriptor(String filename)
FUNC < cv.HOGDescriptor.HOGDescriptor []>
java:  HOGDescriptor()
FUNC <bool cv.HOGDescriptor.checkDetectorSize []>
java: boolean checkDetectorSize()
FUNC <bool cv.HOGDescriptor.load [ARG String filename=, ARG String objname=String()]>
java: boolean load(String filename, String objname)
java: boolean load(String filename)
FUNC <double cv.HOGDescriptor.getWinSigma []>
java: double getWinSigma()
FUNC <size_t cv.HOGDescriptor.getDescriptorSize []>
java: long getDescriptorSize()
FUNC <vector_float cv.HOGDescriptor.getDaimlerPeopleDetector []>
java: MatOfFloat getDaimlerPeopleDetector()
FUNC <vector_float cv.HOGDescriptor.getDefaultPeopleDetector []>
java: MatOfFloat getDefaultPeopleDetector()
FUNC <void cv.HOGDescriptor.compute [ARG Mat img=, ARG vector_float descriptors=, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point locations=std::vector<Point>()]>
java: void compute(Mat img, MatOfFloat descriptors, Size winStride, Size padding, MatOfPoint locations)
java: void compute(Mat img, MatOfFloat descriptors, Size winStride, Size padding)
java: void compute(Mat img, MatOfFloat descriptors, Size winStride)
java: void compute(Mat img, MatOfFloat descriptors)
FUNC <void cv.HOGDescriptor.computeGradient [ARG Mat img=, ARG Mat grad=, ARG Mat angleOfs=, ARG Size paddingTL=Size(), ARG Size paddingBR=Size()]>
java: void computeGradient(Mat img, Mat grad, Mat angleOfs, Size paddingTL, Size paddingBR)
java: void computeGradient(Mat img, Mat grad, Mat angleOfs, Size paddingTL)
java: void computeGradient(Mat img, Mat grad, Mat angleOfs)
FUNC <void cv.HOGDescriptor.detect [ARG Mat img=, ARG vector_Point foundLocations=, ARG vector_double weights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG vector_Point searchLocations=std::vector<Point>()]>
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold, Size winStride, Size padding, MatOfPoint searchLocations)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold, Size winStride, Size padding)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold, Size winStride)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights, double hitThreshold)
java: void detect(Mat img, MatOfPoint foundLocations, MatOfDouble weights)
FUNC <void cv.HOGDescriptor.detectMultiScale [ARG Mat img=, ARG vector_Rect foundLocations=, ARG vector_double foundWeights=, ARG double hitThreshold=0, ARG Size winStride=Size(), ARG Size padding=Size(), ARG double scale=1.05, ARG double finalThreshold=2.0, ARG bool useMeanshiftGrouping=false]>
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding, double scale, double finalThreshold, boolean useMeanshiftGrouping)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding, double scale, double finalThreshold)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding, double scale)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride, Size padding)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold, Size winStride)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights, double hitThreshold)
java: void detectMultiScale(Mat img, MatOfRect foundLocations, MatOfDouble foundWeights)
FUNC <void cv.HOGDescriptor.save [ARG String filename=, ARG String objname=String()]>
java: void save(String filename, String objname)
java: void save(String filename)
FUNC <void cv.HOGDescriptor.setSVMDetector [ARG Mat svmdetector=]>
java: void setSVMDetector(Mat svmdetector)
FUNC <Size cv.HOGDescriptor.get_winSize []>
java: Size get_winSize()
FUNC <Size cv.HOGDescriptor.get_blockSize []>
java: Size get_blockSize()
FUNC <Size cv.HOGDescriptor.get_blockStride []>
java: Size get_blockStride()
FUNC <Size cv.HOGDescriptor.get_cellSize []>
java: Size get_cellSize()
FUNC <int cv.HOGDescriptor.get_nbins []>
java: int get_nbins()
FUNC <int cv.HOGDescriptor.get_derivAperture []>
java: int get_derivAperture()
FUNC <double cv.HOGDescriptor.get_winSigma []>
java: double get_winSigma()
FUNC <HOGDescriptor_HistogramNormType cv.HOGDescriptor.get_histogramNormType []>
java: int get_histogramNormType()
FUNC <double cv.HOGDescriptor.get_L2HysThreshold []>
java: double get_L2HysThreshold()
FUNC <bool cv.HOGDescriptor.get_gammaCorrection []>
java: boolean get_gammaCorrection()
FUNC <vector_float cv.HOGDescriptor.get_svmDetector []>
java: MatOfFloat get_svmDetector()
FUNC <int cv.HOGDescriptor.get_nlevels []>
java: int get_nlevels()
FUNC <bool cv.HOGDescriptor.get_signedGradient []>
java: boolean get_signedGradient()
CLASS cv::.QRCodeDetector : 
FUNC < cv.QRCodeDetector.QRCodeDetector []>
java:  QRCodeDetector()
FUNC <bool cv.QRCodeDetector.decodeMulti [ARG Mat img=, ARG Mat points=, ARG vector_string decoded_info=, ARG vector_Mat straight_qrcode=vector_Mat()]>
java: boolean decodeMulti(Mat img, Mat points, List<String> decoded_info, List<Mat> straight_qrcode)
java: boolean decodeMulti(Mat img, Mat points, List<String> decoded_info)
FUNC <bool cv.QRCodeDetector.detect [ARG Mat img=, ARG Mat points=]>
java: boolean detect(Mat img, Mat points)
FUNC <bool cv.QRCodeDetector.detectAndDecodeMulti [ARG Mat img=, ARG vector_string decoded_info=, ARG Mat points=Mat(), ARG vector_Mat straight_qrcode=vector_Mat()]>
java: boolean detectAndDecodeMulti(Mat img, List<String> decoded_info, Mat points, List<Mat> straight_qrcode)
java: boolean detectAndDecodeMulti(Mat img, List<String> decoded_info, Mat points)
java: boolean detectAndDecodeMulti(Mat img, List<String> decoded_info)
FUNC <bool cv.QRCodeDetector.detectMulti [ARG Mat img=, ARG Mat points=]>
java: boolean detectMulti(Mat img, Mat points)
FUNC <string cv.QRCodeDetector.decode [ARG Mat img=, ARG Mat points=, ARG Mat straight_qrcode=Mat()]>
java: String decode(Mat img, Mat points, Mat straight_qrcode)
java: String decode(Mat img, Mat points)
FUNC <string cv.QRCodeDetector.detectAndDecode [ARG Mat img=, ARG Mat points=Mat(), ARG Mat straight_qrcode=Mat()]>
java: String detectAndDecode(Mat img, Mat points, Mat straight_qrcode)
java: String detectAndDecode(Mat img, Mat points)
java: String detectAndDecode(Mat img)
FUNC <void cv.QRCodeDetector.setEpsX [ARG double epsX=]>
java: void setEpsX(double epsX)
FUNC <void cv.QRCodeDetector.setEpsY [ARG double epsY=]>
java: void setEpsY(double epsY)
CLASS cv::.CascadeClassifier : 
FUNC < cv.CascadeClassifier.CascadeClassifier [ARG String filename=]>
java:  CascadeClassifier(String filename)
FUNC < cv.CascadeClassifier.CascadeClassifier []>
java:  CascadeClassifier()
FUNC <Size cv.CascadeClassifier.getOriginalWindowSize []>
java: Size getOriginalWindowSize()
FUNC <bool cv.CascadeClassifier.convert [ARG String oldcascade=, ARG String newcascade=]>
java: boolean convert(String oldcascade, String newcascade)
FUNC <bool cv.CascadeClassifier.empty []>
java: boolean empty()
FUNC <bool cv.CascadeClassifier.isOldFormatCascade []>
java: boolean isOldFormatCascade()
FUNC <bool cv.CascadeClassifier.load [ARG String filename=]>
java: boolean load(String filename)
FUNC <bool cv.CascadeClassifier.read [ARG FileNode node=]>
SKIP:bool cv::CascadeClassifier::read(FileNode node)	 due to ARG type FileNode/I
FUNC <int cv.CascadeClassifier.getFeatureType []>
java: int getFeatureType()
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors, int flags, Size minSize)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors, int flags)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor, int minNeighbors)
java: void detectMultiScale(Mat image, MatOfRect objects, double scaleFactor)
java: void detectMultiScale(Mat image, MatOfRect objects)
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int numDetections=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size()]>
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors, int flags, Size minSize)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors, int flags)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor, int minNeighbors)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections, double scaleFactor)
java: void detectMultiScale2(Mat image, MatOfRect objects, MatOfInt numDetections)
FUNC <void cv.CascadeClassifier.detectMultiScale [ARG Mat image=, ARG vector_Rect objects=, ARG vector_int rejectLevels=, ARG vector_double levelWeights=, ARG double scaleFactor=1.1, ARG int minNeighbors=3, ARG int flags=0, ARG Size minSize=Size(), ARG Size maxSize=Size(), ARG bool outputRejectLevels=false]>
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize, boolean outputRejectLevels)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors, int flags)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor, int minNeighbors)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights, double scaleFactor)
java: void detectMultiScale3(Mat image, MatOfRect objects, MatOfInt rejectLevels, MatOfDouble levelWeights)
CLASS cv::.BaseCascadeClassifier : Algorithm
CLASS ::.Objdetect : 
[CONST DetectionBasedTracker_DETECTED_NOT_SHOWN_YET=0, CONST DetectionBasedTracker_DETECTED=1, CONST DetectionBasedTracker_DETECTED_TEMPORARY_LOST=2, CONST DetectionBasedTracker_WRONG_OBJECT=3]
[CONST CASCADE_DO_CANNY_PRUNING=1, CONST CASCADE_SCALE_IMAGE=2, CONST CASCADE_FIND_BIGGEST_OBJECT=4, CONST CASCADE_DO_ROUGH_SEARCH=8]
FUNC <void cv..groupRectangles [ARG vector_Rect rectList=, ARG vector_int weights=, ARG int groupThreshold=, ARG double eps=0.2]>
java: void groupRectangles(MatOfRect rectList, MatOfInt weights, int groupThreshold, double eps)
java: void groupRectangles(MatOfRect rectList, MatOfInt weights, int groupThreshold)

=== MODULE: video (/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/video) ===


Files (4):
[u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/video/include/opencv2/video.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/video/include/opencv2/video/tracking.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/video/include/opencv2/video/background_segm.hpp',
 u'/Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/video/include/opencv2/video/video.hpp']

Common headers (0):
[]
ok: class CLASS ::.Video : , name: Video, base: 


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/video/include/opencv2/video.hpp =====
Namespaces: set([])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/video/include/opencv2/video.hpp


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/video/include/opencv2/video/tracking.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.OPTFLOW_USE_INITIAL_FLOW', u'4', [], [], None, ''],
        [u'const cv.OPTFLOW_LK_GET_MIN_EIGENVALS', u'8', [], [], None, ''],
        [u'const cv.OPTFLOW_FARNEBACK_GAUSSIAN', u'256', [], [], None, '']],
    None]
ok: CONST OPTFLOW_USE_INITIAL_FLOW=4
ok: CONST OPTFLOW_LK_GET_MIN_EIGENVALS=8
ok: CONST OPTFLOW_FARNEBACK_GAUSSIAN=256

--- Incoming ---
[   u'cv.CamShift',
    u'RotatedRect',
    [],
    [   ['Mat', u'probImage', '', []],
        [u'Rect', u'window', u'', ['/IO', '/Ref']],
        [u'TermCriteria', u'criteria', u'', []]],
    u'RotatedRect']
ok: FUNC <RotatedRect cv..CamShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.meanShift',
    u'int',
    [],
    [   ['Mat', u'probImage', '', []],
        [u'Rect', u'window', u'', ['/IO', '/Ref']],
        [u'TermCriteria', u'criteria', u'', []]],
    u'int']
ok: FUNC <int cv..meanShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>

--- Incoming ---
[   u'cv.buildOpticalFlowPyramid',
    u'int',
    [],
    [   ['Mat', u'img', '', []],
        ['vector_Mat', u'pyramid', '', ['/O']],
        [u'Size', u'winSize', u'', []],
        [u'int', u'maxLevel', u'', []],
        [u'bool', u'withDerivatives', u'true', []],
        [u'int', u'pyrBorder', u'BORDER_REFLECT_101', []],
        [u'int', u'derivBorder', u'BORDER_CONSTANT', []],
        [u'bool', u'tryReuseInputImage', u'true', []]],
    u'int']
ok: FUNC <int cv..buildOpticalFlowPyramid [ARG Mat img=, ARG vector_Mat pyramid=, ARG Size winSize=, ARG int maxLevel=, ARG bool withDerivatives=true, ARG int pyrBorder=BORDER_REFLECT_101, ARG int derivBorder=BORDER_CONSTANT, ARG bool tryReuseInputImage=true]>

--- Incoming ---
[   u'cv.calcOpticalFlowPyrLK',
    u'void',
    [],
    [   ['Mat', u'prevImg', '', []],
        ['Mat', u'nextImg', '', []],
        ['Mat', u'prevPts', '', []],
        ['Mat', u'nextPts', '', ['/IO']],
        ['Mat', u'status', '', ['/O']],
        ['Mat', u'err', '', ['/O']],
        [u'Size', u'winSize', u'Size(21,21)', []],
        [u'int', u'maxLevel', u'3', []],
        [   u'TermCriteria',
            u'criteria',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)',
            []],
        [u'int', u'flags', u'0', []],
        [u'double', u'minEigThreshold', u'1e-4', []]],
    u'void']
ok: FUNC <void cv..calcOpticalFlowPyrLK [ARG Mat prevImg=, ARG Mat nextImg=, ARG vector_Point2f prevPts=, ARG vector_Point2f nextPts=, ARG vector_uchar status=, ARG vector_float err=, ARG Size winSize=Size(21,21), ARG int maxLevel=3, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>

--- Incoming ---
[   u'cv.calcOpticalFlowFarneback',
    u'void',
    [],
    [   ['Mat', u'prev', '', []],
        ['Mat', u'next', '', []],
        ['Mat', u'flow', '', ['/IO']],
        [u'double', u'pyr_scale', u'', []],
        [u'int', u'levels', u'', []],
        [u'int', u'winsize', u'', []],
        [u'int', u'iterations', u'', []],
        [u'int', u'poly_n', u'', []],
        [u'double', u'poly_sigma', u'', []],
        [u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv..calcOpticalFlowFarneback [ARG Mat prev=, ARG Mat next=, ARG Mat flow=, ARG double pyr_scale=, ARG int levels=, ARG int winsize=, ARG int iterations=, ARG int poly_n=, ARG double poly_sigma=, ARG int flags=]>

--- Incoming ---
[   u'enum cv.<unnamed>',
    '',
    [],
    [   [u'const cv.MOTION_TRANSLATION', u'0', [], [], None, ''],
        [u'const cv.MOTION_EUCLIDEAN', u'1', [], [], None, ''],
        [u'const cv.MOTION_AFFINE', u'2', [], [], None, ''],
        [u'const cv.MOTION_HOMOGRAPHY', u'3', [], [], None, '']],
    None]
ok: CONST MOTION_TRANSLATION=0
ok: CONST MOTION_EUCLIDEAN=1
ok: CONST MOTION_AFFINE=2
ok: CONST MOTION_HOMOGRAPHY=3

--- Incoming ---
[   u'cv.computeECC',
    u'double',
    [],
    [   ['Mat', u'templateImage', '', []],
        ['Mat', u'inputImage', '', []],
        ['Mat', u'inputMask', u'Mat()', []]],
    u'double']
ok: FUNC <double cv..computeECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat inputMask=Mat()]>

--- Incoming ---
[   u'cv.findTransformECC',
    u'double',
    [],
    [   ['Mat', u'templateImage', '', []],
        ['Mat', u'inputImage', '', []],
        ['Mat', u'warpMatrix', '', ['/IO']],
        [u'int', u'motionType', u'', []],
        [u'TermCriteria', u'criteria', u'', []],
        ['Mat', u'inputMask', '', []],
        [u'int', u'gaussFiltSize', u'', []]],
    u'double']
ok: FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=, ARG TermCriteria criteria=, ARG Mat inputMask=, ARG int gaussFiltSize=]>

--- Incoming ---
[   u'class cv.KalmanFilter',
    '',
    [],
    [   [u'Mat', u'statePre', '', ['/RW']],
        [u'Mat', u'statePost', '', ['/RW']],
        [u'Mat', u'transitionMatrix', '', ['/RW']],
        [u'Mat', u'controlMatrix', '', ['/RW']],
        [u'Mat', u'measurementMatrix', '', ['/RW']],
        [u'Mat', u'processNoiseCov', '', ['/RW']],
        [u'Mat', u'measurementNoiseCov', '', ['/RW']],
        [u'Mat', u'errorCovPre', '', ['/RW']],
        [u'Mat', u'gain', '', ['/RW']],
        [u'Mat', u'errorCovPost', '', ['/RW']]],
    None]
ok: class CLASS cv::.KalmanFilter : , name: KalmanFilter, base: 

--- Incoming ---
[u'cv.KalmanFilter.KalmanFilter', '', [], [], None]
ok: FUNC < cv.KalmanFilter.KalmanFilter []>

--- Incoming ---
[   u'cv.KalmanFilter.KalmanFilter',
    '',
    [],
    [   [u'int', u'dynamParams', u'', []],
        [u'int', u'measureParams', u'', []],
        [u'int', u'controlParams', u'0', []],
        [u'int', u'type', u'CV_32F', []]],
    None]
ok: FUNC < cv.KalmanFilter.KalmanFilter [ARG int dynamParams=, ARG int measureParams=, ARG int controlParams=0, ARG int type=CV_32F]>

--- Incoming ---
[   u'cv.KalmanFilter.predict',
    u'Mat',
    [],
    [[u'Mat', u'control', u'Mat()', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.KalmanFilter.predict [ARG Mat control=Mat()]>

--- Incoming ---
[   u'cv.KalmanFilter.correct',
    u'Mat',
    [],
    [[u'Mat', u'measurement', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv.KalmanFilter.correct [ARG Mat measurement=]>

--- Incoming ---
[   u'cv.readOpticalFlow',
    u'Mat',
    [],
    [[u'String', u'path', u'', ['/C', '/Ref']]],
    u'Mat']
ok: FUNC <Mat cv..readOpticalFlow [ARG String path=]>

--- Incoming ---
[   u'cv.writeOpticalFlow',
    u'bool',
    [],
    [[u'String', u'path', u'', ['/C', '/Ref']], ['Mat', u'flow', '', []]],
    u'bool']
ok: FUNC <bool cv..writeOpticalFlow [ARG String path=, ARG Mat flow=]>

--- Incoming ---
[u'class cv.DenseOpticalFlow', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.DenseOpticalFlow : Algorithm, name: DenseOpticalFlow, base: Algorithm

--- Incoming ---
[   u'cv.DenseOpticalFlow.calc',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'I0', '', []],
        ['Mat', u'I1', '', []],
        ['Mat', u'flow', '', ['/IO']]],
    u'void']
ok: FUNC <void cv.DenseOpticalFlow.calc [ARG Mat I0=, ARG Mat I1=, ARG Mat flow=]>

--- Incoming ---
[u'cv.DenseOpticalFlow.collectGarbage', u'void', ['/V', '/PV'], [], u'void']
ok: FUNC <void cv.DenseOpticalFlow.collectGarbage []>

--- Incoming ---
[u'class cv.SparseOpticalFlow', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.SparseOpticalFlow : Algorithm, name: SparseOpticalFlow, base: Algorithm

--- Incoming ---
[   u'cv.SparseOpticalFlow.calc',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'prevImg', '', []],
        ['Mat', u'nextImg', '', []],
        ['Mat', u'prevPts', '', []],
        ['Mat', u'nextPts', '', ['/IO']],
        ['Mat', u'status', '', ['/O']],
        ['Mat', u'err', u'cv::Mat()', ['/O']]],
    u'void']
ok: FUNC <void cv.SparseOpticalFlow.calc [ARG Mat prevImg=, ARG Mat nextImg=, ARG Mat prevPts=, ARG Mat nextPts=, ARG Mat status=, ARG Mat err=cv::Mat()]>

--- Incoming ---
[u'class cv.FarnebackOpticalFlow', u': cv::DenseOpticalFlow', [], [], None]
ok: class CLASS cv::.FarnebackOpticalFlow : DenseOpticalFlow, name: FarnebackOpticalFlow, base: DenseOpticalFlow

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getNumLevels',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getNumLevels []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setNumLevels',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'numLevels', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setNumLevels [ARG int numLevels=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getPyrScale',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.FarnebackOpticalFlow.getPyrScale []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPyrScale',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'pyrScale', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPyrScale [ARG double pyrScale=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getFastPyramids',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.FarnebackOpticalFlow.getFastPyramids []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setFastPyramids',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'fastPyramids', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setFastPyramids [ARG bool fastPyramids=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getWinSize',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getWinSize []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setWinSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'winSize', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setWinSize [ARG int winSize=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getNumIters',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getNumIters []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setNumIters',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'numIters', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setNumIters [ARG int numIters=]>

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getPolyN', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getPolyN []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPolyN',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'polyN', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPolyN [ARG int polyN=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.getPolySigma',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.FarnebackOpticalFlow.getPolySigma []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setPolySigma',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'polySigma', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setPolySigma [ARG double polySigma=]>

--- Incoming ---
[u'cv.FarnebackOpticalFlow.getFlags', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.FarnebackOpticalFlow.getFlags []>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.setFlags',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv.FarnebackOpticalFlow.setFlags [ARG int flags=]>

--- Incoming ---
[   u'cv.FarnebackOpticalFlow.create',
    u'Ptr_FarnebackOpticalFlow',
    ['/S'],
    [   [u'int', u'numLevels', u'5', []],
        [u'double', u'pyrScale', u'0.5', []],
        [u'bool', u'fastPyramids', u'false', []],
        [u'int', u'winSize', u'13', []],
        [u'int', u'numIters', u'10', []],
        [u'int', u'polyN', u'5', []],
        [u'double', u'polySigma', u'1.1', []],
        [u'int', u'flags', u'0', []]],
    u'Ptr<FarnebackOpticalFlow>']
ok: FUNC <Ptr_FarnebackOpticalFlow cv.FarnebackOpticalFlow.create [ARG int numLevels=5, ARG double pyrScale=0.5, ARG bool fastPyramids=false, ARG int winSize=13, ARG int numIters=10, ARG int polyN=5, ARG double polySigma=1.1, ARG int flags=0]>

--- Incoming ---
[u'class cv.VariationalRefinement', u': cv::DenseOpticalFlow', [], [], None]
ok: class CLASS cv::.VariationalRefinement : DenseOpticalFlow, name: VariationalRefinement, base: DenseOpticalFlow

--- Incoming ---
[   u'cv.VariationalRefinement.calcUV',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'I0', '', []],
        ['Mat', u'I1', '', []],
        ['Mat', u'flow_u', '', ['/IO']],
        ['Mat', u'flow_v', '', ['/IO']]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.calcUV [ARG Mat I0=, ARG Mat I1=, ARG Mat flow_u=, ARG Mat flow_v=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getFixedPointIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.VariationalRefinement.getFixedPointIterations []>

--- Incoming ---
[   u'cv.VariationalRefinement.setFixedPointIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setFixedPointIterations [ARG int val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getSorIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.VariationalRefinement.getSorIterations []>

--- Incoming ---
[   u'cv.VariationalRefinement.setSorIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setSorIterations [ARG int val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getOmega',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.VariationalRefinement.getOmega []>

--- Incoming ---
[   u'cv.VariationalRefinement.setOmega',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setOmega [ARG float val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getAlpha',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.VariationalRefinement.getAlpha []>

--- Incoming ---
[   u'cv.VariationalRefinement.setAlpha',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setAlpha [ARG float val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getDelta',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.VariationalRefinement.getDelta []>

--- Incoming ---
[   u'cv.VariationalRefinement.setDelta',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setDelta [ARG float val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.getGamma',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.VariationalRefinement.getGamma []>

--- Incoming ---
[   u'cv.VariationalRefinement.setGamma',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.VariationalRefinement.setGamma [ARG float val=]>

--- Incoming ---
[   u'cv.VariationalRefinement.create',
    u'Ptr_VariationalRefinement',
    ['/S'],
    [],
    u'Ptr<VariationalRefinement>']
ok: FUNC <Ptr_VariationalRefinement cv.VariationalRefinement.create []>

--- Incoming ---
[u'class cv.DISOpticalFlow', u': cv::DenseOpticalFlow', [], [], None]
ok: class CLASS cv::.DISOpticalFlow : DenseOpticalFlow, name: DISOpticalFlow, base: DenseOpticalFlow

--- Incoming ---
[   u'enum cv.DISOpticalFlow.<unnamed>',
    '',
    [],
    [   [u'const cv.DISOpticalFlow.PRESET_ULTRAFAST', u'0', [], [], None, ''],
        [u'const cv.DISOpticalFlow.PRESET_FAST', u'1', [], [], None, ''],
        [u'const cv.DISOpticalFlow.PRESET_MEDIUM', u'2', [], [], None, '']],
    None]
ok: CONST PRESET_ULTRAFAST=0
ok: CONST PRESET_FAST=1
ok: CONST PRESET_MEDIUM=2

--- Incoming ---
[u'cv.DISOpticalFlow.getFinestScale', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.DISOpticalFlow.getFinestScale []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setFinestScale',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setFinestScale [ARG int val=]>

--- Incoming ---
[u'cv.DISOpticalFlow.getPatchSize', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.DISOpticalFlow.getPatchSize []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setPatchSize',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setPatchSize [ARG int val=]>

--- Incoming ---
[u'cv.DISOpticalFlow.getPatchStride', u'int', ['/C', '/V', '/PV'], [], u'int']
ok: FUNC <int cv.DISOpticalFlow.getPatchStride []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setPatchStride',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setPatchStride [ARG int val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getGradientDescentIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.DISOpticalFlow.getGradientDescentIterations []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setGradientDescentIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setGradientDescentIterations [ARG int val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getVariationalRefinementIterations',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.DISOpticalFlow.getVariationalRefinementIterations []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setVariationalRefinementIterations',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementIterations [ARG int val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getVariationalRefinementAlpha',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.DISOpticalFlow.getVariationalRefinementAlpha []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setVariationalRefinementAlpha',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementAlpha [ARG float val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getVariationalRefinementDelta',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.DISOpticalFlow.getVariationalRefinementDelta []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setVariationalRefinementDelta',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementDelta [ARG float val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getVariationalRefinementGamma',
    u'float',
    ['/C', '/V', '/PV'],
    [],
    u'float']
ok: FUNC <float cv.DISOpticalFlow.getVariationalRefinementGamma []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setVariationalRefinementGamma',
    u'void',
    ['/V', '/PV'],
    [[u'float', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setVariationalRefinementGamma [ARG float val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getUseMeanNormalization',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.DISOpticalFlow.getUseMeanNormalization []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setUseMeanNormalization',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setUseMeanNormalization [ARG bool val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.getUseSpatialPropagation',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.DISOpticalFlow.getUseSpatialPropagation []>

--- Incoming ---
[   u'cv.DISOpticalFlow.setUseSpatialPropagation',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'val', u'', []]],
    u'void']
ok: FUNC <void cv.DISOpticalFlow.setUseSpatialPropagation [ARG bool val=]>

--- Incoming ---
[   u'cv.DISOpticalFlow.create',
    u'Ptr_DISOpticalFlow',
    ['/S'],
    [[u'int', u'preset', u'DISOpticalFlow::PRESET_FAST', []]],
    u'Ptr<DISOpticalFlow>']
ok: FUNC <Ptr_DISOpticalFlow cv.DISOpticalFlow.create [ARG int preset=DISOpticalFlow::PRESET_FAST]>

--- Incoming ---
[u'class cv.SparsePyrLKOpticalFlow', u': cv::SparseOpticalFlow', [], [], None]
ok: class CLASS cv::.SparsePyrLKOpticalFlow : SparseOpticalFlow, name: SparsePyrLKOpticalFlow, base: SparseOpticalFlow

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getWinSize',
    u'Size',
    ['/C', '/V', '/PV'],
    [],
    u'Size']
ok: FUNC <Size cv.SparsePyrLKOpticalFlow.getWinSize []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setWinSize',
    u'void',
    ['/V', '/PV'],
    [[u'Size', u'winSize', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setWinSize [ARG Size winSize=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getMaxLevel',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.SparsePyrLKOpticalFlow.getMaxLevel []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setMaxLevel',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'maxLevel', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setMaxLevel [ARG int maxLevel=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getTermCriteria',
    u'TermCriteria',
    ['/C', '/V', '/PV'],
    [],
    u'TermCriteria']
ok: FUNC <TermCriteria cv.SparsePyrLKOpticalFlow.getTermCriteria []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setTermCriteria',
    u'void',
    ['/V', '/PV'],
    [[u'TermCriteria', u'crit', u'', ['/Ref']]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setTermCriteria [ARG TermCriteria crit=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getFlags',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.SparsePyrLKOpticalFlow.getFlags []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setFlags',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'flags', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setFlags [ARG int flags=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.getMinEigThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.SparsePyrLKOpticalFlow.getMinEigThreshold []>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.setMinEigThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'minEigThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.SparsePyrLKOpticalFlow.setMinEigThreshold [ARG double minEigThreshold=]>

--- Incoming ---
[   u'cv.SparsePyrLKOpticalFlow.create',
    u'Ptr_SparsePyrLKOpticalFlow',
    ['/S'],
    [   [u'Size', u'winSize', u'Size(21, 21)', []],
        [u'int', u'maxLevel', u'3', []],
        [   u'TermCriteria',
            u'crit',
            u'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01)',
            []],
        [u'int', u'flags', u'0', []],
        [u'double', u'minEigThreshold', u'1e-4', []]],
    u'Ptr<SparsePyrLKOpticalFlow>']
ok: FUNC <Ptr_SparsePyrLKOpticalFlow cv.SparsePyrLKOpticalFlow.create [ARG Size winSize=Size(21, 21), ARG int maxLevel=3, ARG TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/video/include/opencv2/video/background_segm.hpp =====
Namespaces: set([u'cv'])

--- Incoming ---
[u'class cv.BackgroundSubtractor', ': cv::Algorithm', [], [], None]
ok: class CLASS cv::.BackgroundSubtractor : Algorithm, name: BackgroundSubtractor, base: Algorithm

--- Incoming ---
[   u'cv.BackgroundSubtractor.apply',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'fgmask', '', ['/O']],
        [u'double', u'learningRate', u'-1', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractor.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   u'cv.BackgroundSubtractor.getBackgroundImage',
    u'void',
    ['/C', '/V', '/PV'],
    [['Mat', u'backgroundImage', '', ['/O']]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractor.getBackgroundImage [ARG Mat backgroundImage=]>

--- Incoming ---
[   u'class cv.BackgroundSubtractorMOG2',
    u': cv::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv::.BackgroundSubtractorMOG2 : BackgroundSubtractor, name: BackgroundSubtractorMOG2, base: BackgroundSubtractor

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getHistory',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getHistory []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setHistory',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'history', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setHistory [ARG int history=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getNMixtures',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getNMixtures []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setNMixtures',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'nmixtures', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setNMixtures [ARG int nmixtures=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getBackgroundRatio',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getBackgroundRatio []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setBackgroundRatio',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'ratio', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setBackgroundRatio [ARG double ratio=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varThreshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarThreshold [ARG double varThreshold=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarThresholdGen',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarThresholdGen []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarThresholdGen',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varThresholdGen', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarThresholdGen [ARG double varThresholdGen=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarInit',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarInit []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarInit',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varInit', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarInit [ARG double varInit=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarMin',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarMin []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarMin',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varMin', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarMin [ARG double varMin=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getVarMax',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getVarMax []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setVarMax',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'varMax', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setVarMax [ARG double varMax=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'ct', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold [ARG double ct=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getDetectShadows',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.BackgroundSubtractorMOG2.getDetectShadows []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setDetectShadows',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'detectShadows', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setDetectShadows [ARG bool detectShadows=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getShadowValue',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorMOG2.getShadowValue []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setShadowValue',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setShadowValue [ARG int value=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.getShadowThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorMOG2.getShadowThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.setShadowThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.setShadowThreshold [ARG double threshold=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorMOG2.apply',
    u'void',
    ['/V', '/PV'],
    [   ['Mat', u'image', '', []],
        ['Mat', u'fgmask', '', ['/O']],
        [u'double', u'learningRate', u'-1', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorMOG2.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>

--- Incoming ---
[   u'cv.createBackgroundSubtractorMOG2',
    u'Ptr_BackgroundSubtractorMOG2',
    [],
    [   [u'int', u'history', u'500', []],
        [u'double', u'varThreshold', u'16', []],
        [u'bool', u'detectShadows', u'true', []]],
    u'Ptr<BackgroundSubtractorMOG2>']
ok: FUNC <Ptr_BackgroundSubtractorMOG2 cv..createBackgroundSubtractorMOG2 [ARG int history=500, ARG double varThreshold=16, ARG bool detectShadows=true]>

--- Incoming ---
[   u'class cv.BackgroundSubtractorKNN',
    u': cv::BackgroundSubtractor',
    [],
    [],
    None]
ok: class CLASS cv::.BackgroundSubtractorKNN : BackgroundSubtractor, name: BackgroundSubtractorKNN, base: BackgroundSubtractor

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getHistory',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getHistory []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setHistory',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'history', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setHistory [ARG int history=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getNSamples',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getNSamples []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setNSamples',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'_nN', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setNSamples [ARG int _nN=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getDist2Threshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorKNN.getDist2Threshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setDist2Threshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'_dist2Threshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setDist2Threshold [ARG double _dist2Threshold=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getkNNSamples',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getkNNSamples []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setkNNSamples',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'_nkNN', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setkNNSamples [ARG int _nkNN=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getDetectShadows',
    u'bool',
    ['/C', '/V', '/PV'],
    [],
    u'bool']
ok: FUNC <bool cv.BackgroundSubtractorKNN.getDetectShadows []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setDetectShadows',
    u'void',
    ['/V', '/PV'],
    [[u'bool', u'detectShadows', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setDetectShadows [ARG bool detectShadows=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getShadowValue',
    u'int',
    ['/C', '/V', '/PV'],
    [],
    u'int']
ok: FUNC <int cv.BackgroundSubtractorKNN.getShadowValue []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setShadowValue',
    u'void',
    ['/V', '/PV'],
    [[u'int', u'value', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setShadowValue [ARG int value=]>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.getShadowThreshold',
    u'double',
    ['/C', '/V', '/PV'],
    [],
    u'double']
ok: FUNC <double cv.BackgroundSubtractorKNN.getShadowThreshold []>

--- Incoming ---
[   u'cv.BackgroundSubtractorKNN.setShadowThreshold',
    u'void',
    ['/V', '/PV'],
    [[u'double', u'threshold', u'', []]],
    u'void']
ok: FUNC <void cv.BackgroundSubtractorKNN.setShadowThreshold [ARG double threshold=]>

--- Incoming ---
[   u'cv.createBackgroundSubtractorKNN',
    u'Ptr_BackgroundSubtractorKNN',
    [],
    [   [u'int', u'history', u'500', []],
        [u'double', u'dist2Threshold', u'400.0', []],
        [u'bool', u'detectShadows', u'true', []]],
    u'Ptr<BackgroundSubtractorKNN>']
ok: FUNC <Ptr_BackgroundSubtractorKNN cv..createBackgroundSubtractorKNN [ARG int history=500, ARG double dist2Threshold=400.0, ARG bool detectShadows=true]>


===== Header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/video/include/opencv2/video/video.hpp =====
Namespaces: set([u'cv'])
Ignore header: /Users/virtualman/Downloads/MySource/opencv-4.3.0/modules/video/include/opencv2/video/video.hpp


===== Generating... =====
CLASS cv::.BackgroundSubtractorMOG2 : BackgroundSubtractor
FUNC <bool cv.BackgroundSubtractorMOG2.getDetectShadows []>
java: boolean getDetectShadows()
FUNC <double cv.BackgroundSubtractorMOG2.getBackgroundRatio []>
java: double getBackgroundRatio()
FUNC <double cv.BackgroundSubtractorMOG2.getComplexityReductionThreshold []>
java: double getComplexityReductionThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getShadowThreshold []>
java: double getShadowThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getVarInit []>
java: double getVarInit()
FUNC <double cv.BackgroundSubtractorMOG2.getVarMax []>
java: double getVarMax()
FUNC <double cv.BackgroundSubtractorMOG2.getVarMin []>
java: double getVarMin()
FUNC <double cv.BackgroundSubtractorMOG2.getVarThreshold []>
java: double getVarThreshold()
FUNC <double cv.BackgroundSubtractorMOG2.getVarThresholdGen []>
java: double getVarThresholdGen()
FUNC <int cv.BackgroundSubtractorMOG2.getHistory []>
java: int getHistory()
FUNC <int cv.BackgroundSubtractorMOG2.getNMixtures []>
java: int getNMixtures()
FUNC <int cv.BackgroundSubtractorMOG2.getShadowValue []>
java: int getShadowValue()
FUNC <void cv.BackgroundSubtractorMOG2.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.BackgroundSubtractorMOG2.setBackgroundRatio [ARG double ratio=]>
java: void setBackgroundRatio(double ratio)
FUNC <void cv.BackgroundSubtractorMOG2.setComplexityReductionThreshold [ARG double ct=]>
java: void setComplexityReductionThreshold(double ct)
FUNC <void cv.BackgroundSubtractorMOG2.setDetectShadows [ARG bool detectShadows=]>
java: void setDetectShadows(boolean detectShadows)
FUNC <void cv.BackgroundSubtractorMOG2.setHistory [ARG int history=]>
java: void setHistory(int history)
FUNC <void cv.BackgroundSubtractorMOG2.setNMixtures [ARG int nmixtures=]>
java: void setNMixtures(int nmixtures)
FUNC <void cv.BackgroundSubtractorMOG2.setShadowThreshold [ARG double threshold=]>
java: void setShadowThreshold(double threshold)
FUNC <void cv.BackgroundSubtractorMOG2.setShadowValue [ARG int value=]>
java: void setShadowValue(int value)
FUNC <void cv.BackgroundSubtractorMOG2.setVarInit [ARG double varInit=]>
java: void setVarInit(double varInit)
FUNC <void cv.BackgroundSubtractorMOG2.setVarMax [ARG double varMax=]>
java: void setVarMax(double varMax)
FUNC <void cv.BackgroundSubtractorMOG2.setVarMin [ARG double varMin=]>
java: void setVarMin(double varMin)
FUNC <void cv.BackgroundSubtractorMOG2.setVarThreshold [ARG double varThreshold=]>
java: void setVarThreshold(double varThreshold)
FUNC <void cv.BackgroundSubtractorMOG2.setVarThresholdGen [ARG double varThresholdGen=]>
java: void setVarThresholdGen(double varThresholdGen)
CLASS cv::.FarnebackOpticalFlow : DenseOpticalFlow
FUNC <Ptr_FarnebackOpticalFlow cv.FarnebackOpticalFlow.create [ARG int numLevels=5, ARG double pyrScale=0.5, ARG bool fastPyramids=false, ARG int winSize=13, ARG int numIters=10, ARG int polyN=5, ARG double polySigma=1.1, ARG int flags=0]>
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters, int polyN, double polySigma, int flags)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters, int polyN, double polySigma)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters, int polyN)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize, int numIters)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids, int winSize)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale, boolean fastPyramids)
java: FarnebackOpticalFlow create(int numLevels, double pyrScale)
java: FarnebackOpticalFlow create(int numLevels)
java: FarnebackOpticalFlow create()
FUNC <bool cv.FarnebackOpticalFlow.getFastPyramids []>
java: boolean getFastPyramids()
FUNC <double cv.FarnebackOpticalFlow.getPolySigma []>
java: double getPolySigma()
FUNC <double cv.FarnebackOpticalFlow.getPyrScale []>
java: double getPyrScale()
FUNC <int cv.FarnebackOpticalFlow.getFlags []>
java: int getFlags()
FUNC <int cv.FarnebackOpticalFlow.getNumIters []>
java: int getNumIters()
FUNC <int cv.FarnebackOpticalFlow.getNumLevels []>
java: int getNumLevels()
FUNC <int cv.FarnebackOpticalFlow.getPolyN []>
java: int getPolyN()
FUNC <int cv.FarnebackOpticalFlow.getWinSize []>
java: int getWinSize()
FUNC <void cv.FarnebackOpticalFlow.setFastPyramids [ARG bool fastPyramids=]>
java: void setFastPyramids(boolean fastPyramids)
FUNC <void cv.FarnebackOpticalFlow.setFlags [ARG int flags=]>
java: void setFlags(int flags)
FUNC <void cv.FarnebackOpticalFlow.setNumIters [ARG int numIters=]>
java: void setNumIters(int numIters)
FUNC <void cv.FarnebackOpticalFlow.setNumLevels [ARG int numLevels=]>
java: void setNumLevels(int numLevels)
FUNC <void cv.FarnebackOpticalFlow.setPolyN [ARG int polyN=]>
java: void setPolyN(int polyN)
FUNC <void cv.FarnebackOpticalFlow.setPolySigma [ARG double polySigma=]>
java: void setPolySigma(double polySigma)
FUNC <void cv.FarnebackOpticalFlow.setPyrScale [ARG double pyrScale=]>
java: void setPyrScale(double pyrScale)
FUNC <void cv.FarnebackOpticalFlow.setWinSize [ARG int winSize=]>
java: void setWinSize(int winSize)
CLASS cv::.SparseOpticalFlow : Algorithm
FUNC <void cv.SparseOpticalFlow.calc [ARG Mat prevImg=, ARG Mat nextImg=, ARG Mat prevPts=, ARG Mat nextPts=, ARG Mat status=, ARG Mat err=cv::Mat()]>
java: void calc(Mat prevImg, Mat nextImg, Mat prevPts, Mat nextPts, Mat status, Mat err)
java: void calc(Mat prevImg, Mat nextImg, Mat prevPts, Mat nextPts, Mat status)
CLASS cv::.DenseOpticalFlow : Algorithm
FUNC <void cv.DenseOpticalFlow.calc [ARG Mat I0=, ARG Mat I1=, ARG Mat flow=]>
java: void calc(Mat I0, Mat I1, Mat flow)
FUNC <void cv.DenseOpticalFlow.collectGarbage []>
java: void collectGarbage()
CLASS cv::.BackgroundSubtractor : Algorithm
FUNC <void cv.BackgroundSubtractor.apply [ARG Mat image=, ARG Mat fgmask=, ARG double learningRate=-1]>
java: void apply(Mat image, Mat fgmask, double learningRate)
java: void apply(Mat image, Mat fgmask)
FUNC <void cv.BackgroundSubtractor.getBackgroundImage [ARG Mat backgroundImage=]>
java: void getBackgroundImage(Mat backgroundImage)
CLASS ::.Video : 
[CONST CV_LKFLOW_INITIAL_GUESSES=4(manual), CONST CV_LKFLOW_GET_MIN_EIGENVALS=8(manual)]
[CONST OPTFLOW_USE_INITIAL_FLOW=4, CONST OPTFLOW_LK_GET_MIN_EIGENVALS=8, CONST OPTFLOW_FARNEBACK_GAUSSIAN=256, CONST MOTION_TRANSLATION=0, CONST MOTION_EUCLIDEAN=1, CONST MOTION_AFFINE=2, CONST MOTION_HOMOGRAPHY=3]
FUNC <Mat cv..readOpticalFlow [ARG String path=]>
java: Mat readOpticalFlow(String path)
FUNC <Ptr_BackgroundSubtractorKNN cv..createBackgroundSubtractorKNN [ARG int history=500, ARG double dist2Threshold=400.0, ARG bool detectShadows=true]>
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN(int history, double dist2Threshold, boolean detectShadows)
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN(int history, double dist2Threshold)
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN(int history)
java: BackgroundSubtractorKNN createBackgroundSubtractorKNN()
FUNC <Ptr_BackgroundSubtractorMOG2 cv..createBackgroundSubtractorMOG2 [ARG int history=500, ARG double varThreshold=16, ARG bool detectShadows=true]>
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2(int history, double varThreshold, boolean detectShadows)
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2(int history, double varThreshold)
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2(int history)
java: BackgroundSubtractorMOG2 createBackgroundSubtractorMOG2()
FUNC <RotatedRect cv..CamShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>
java: RotatedRect CamShift(Mat probImage, Rect window, TermCriteria criteria)
FUNC <bool cv..writeOpticalFlow [ARG String path=, ARG Mat flow=]>
java: boolean writeOpticalFlow(String path, Mat flow)
FUNC <double cv..computeECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat inputMask=Mat()]>
java: double computeECC(Mat templateImage, Mat inputImage, Mat inputMask)
java: double computeECC(Mat templateImage, Mat inputImage)
FUNC <double cv..findTransformECC [ARG Mat templateImage=, ARG Mat inputImage=, ARG Mat warpMatrix=, ARG int motionType=, ARG TermCriteria criteria=, ARG Mat inputMask=, ARG int gaussFiltSize=]>
java: double findTransformECC(Mat templateImage, Mat inputImage, Mat warpMatrix, int motionType, TermCriteria criteria, Mat inputMask, int gaussFiltSize)
FUNC <int cv..buildOpticalFlowPyramid [ARG Mat img=, ARG vector_Mat pyramid=, ARG Size winSize=, ARG int maxLevel=, ARG bool withDerivatives=true, ARG int pyrBorder=BORDER_REFLECT_101, ARG int derivBorder=BORDER_CONSTANT, ARG bool tryReuseInputImage=true]>
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives, int pyrBorder, int derivBorder, boolean tryReuseInputImage)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives, int pyrBorder, int derivBorder)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives, int pyrBorder)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel, boolean withDerivatives)
java: int buildOpticalFlowPyramid(Mat img, List<Mat> pyramid, Size winSize, int maxLevel)
FUNC <int cv..meanShift [ARG Mat probImage=, ARG Rect window=, ARG TermCriteria criteria=]>
java: int meanShift(Mat probImage, Rect window, TermCriteria criteria)
FUNC <void cv..calcOpticalFlowFarneback [ARG Mat prev=, ARG Mat next=, ARG Mat flow=, ARG double pyr_scale=, ARG int levels=, ARG int winsize=, ARG int iterations=, ARG int poly_n=, ARG double poly_sigma=, ARG int flags=]>
java: void calcOpticalFlowFarneback(Mat prev, Mat next, Mat flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)
FUNC <void cv..calcOpticalFlowPyrLK [ARG Mat prevImg=, ARG Mat nextImg=, ARG vector_Point2f prevPts=, ARG vector_Point2f nextPts=, ARG vector_uchar status=, ARG vector_float err=, ARG Size winSize=Size(21,21), ARG int maxLevel=3, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel, TermCriteria criteria, int flags)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel, TermCriteria criteria)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize, int maxLevel)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err, Size winSize)
java: void calcOpticalFlowPyrLK(Mat prevImg, Mat nextImg, MatOfPoint2f prevPts, MatOfPoint2f nextPts, MatOfByte status, MatOfFloat err)
CLASS cv::.DISOpticalFlow : DenseOpticalFlow
[CONST PRESET_ULTRAFAST=0, CONST PRESET_FAST=1, CONST PRESET_MEDIUM=2]
FUNC <Ptr_DISOpticalFlow cv.DISOpticalFlow.create [ARG int preset=DISOpticalFlow::PRESET_FAST]>
java: DISOpticalFlow create(int preset)
java: DISOpticalFlow create()
FUNC <bool cv.DISOpticalFlow.getUseMeanNormalization []>
java: boolean getUseMeanNormalization()
FUNC <bool cv.DISOpticalFlow.getUseSpatialPropagation []>
java: boolean getUseSpatialPropagation()
FUNC <float cv.DISOpticalFlow.getVariationalRefinementAlpha []>
java: float getVariationalRefinementAlpha()
FUNC <float cv.DISOpticalFlow.getVariationalRefinementDelta []>
java: float getVariationalRefinementDelta()
FUNC <float cv.DISOpticalFlow.getVariationalRefinementGamma []>
java: float getVariationalRefinementGamma()
FUNC <int cv.DISOpticalFlow.getFinestScale []>
java: int getFinestScale()
FUNC <int cv.DISOpticalFlow.getGradientDescentIterations []>
java: int getGradientDescentIterations()
FUNC <int cv.DISOpticalFlow.getPatchSize []>
java: int getPatchSize()
FUNC <int cv.DISOpticalFlow.getPatchStride []>
java: int getPatchStride()
FUNC <int cv.DISOpticalFlow.getVariationalRefinementIterations []>
java: int getVariationalRefinementIterations()
FUNC <void cv.DISOpticalFlow.setFinestScale [ARG int val=]>
java: void setFinestScale(int val)
FUNC <void cv.DISOpticalFlow.setGradientDescentIterations [ARG int val=]>
java: void setGradientDescentIterations(int val)
FUNC <void cv.DISOpticalFlow.setPatchSize [ARG int val=]>
java: void setPatchSize(int val)
FUNC <void cv.DISOpticalFlow.setPatchStride [ARG int val=]>
java: void setPatchStride(int val)
FUNC <void cv.DISOpticalFlow.setUseMeanNormalization [ARG bool val=]>
java: void setUseMeanNormalization(boolean val)
FUNC <void cv.DISOpticalFlow.setUseSpatialPropagation [ARG bool val=]>
java: void setUseSpatialPropagation(boolean val)
FUNC <void cv.DISOpticalFlow.setVariationalRefinementAlpha [ARG float val=]>
java: void setVariationalRefinementAlpha(float val)
FUNC <void cv.DISOpticalFlow.setVariationalRefinementDelta [ARG float val=]>
java: void setVariationalRefinementDelta(float val)
FUNC <void cv.DISOpticalFlow.setVariationalRefinementGamma [ARG float val=]>
java: void setVariationalRefinementGamma(float val)
FUNC <void cv.DISOpticalFlow.setVariationalRefinementIterations [ARG int val=]>
java: void setVariationalRefinementIterations(int val)
CLASS cv::.KalmanFilter : 
FUNC < cv.KalmanFilter.KalmanFilter [ARG int dynamParams=, ARG int measureParams=, ARG int controlParams=0, ARG int type=CV_32F]>
java:  KalmanFilter(int dynamParams, int measureParams, int controlParams, int type)
java:  KalmanFilter(int dynamParams, int measureParams, int controlParams)
java:  KalmanFilter(int dynamParams, int measureParams)
FUNC < cv.KalmanFilter.KalmanFilter []>
java:  KalmanFilter()
FUNC <Mat cv.KalmanFilter.correct [ARG Mat measurement=]>
java: Mat correct(Mat measurement)
FUNC <Mat cv.KalmanFilter.predict [ARG Mat control=Mat()]>
java: Mat predict(Mat control)
java: Mat predict()
FUNC <Mat cv.KalmanFilter.get_statePre []>
java: Mat get_statePre()
FUNC <void cv.KalmanFilter.set_statePre [ARG Mat statePre=]>
java: void set_statePre(Mat statePre)
FUNC <Mat cv.KalmanFilter.get_statePost []>
java: Mat get_statePost()
FUNC <void cv.KalmanFilter.set_statePost [ARG Mat statePost=]>
java: void set_statePost(Mat statePost)
FUNC <Mat cv.KalmanFilter.get_transitionMatrix []>
java: Mat get_transitionMatrix()
FUNC <void cv.KalmanFilter.set_transitionMatrix [ARG Mat transitionMatrix=]>
java: void set_transitionMatrix(Mat transitionMatrix)
FUNC <Mat cv.KalmanFilter.get_controlMatrix []>
java: Mat get_controlMatrix()
FUNC <void cv.KalmanFilter.set_controlMatrix [ARG Mat controlMatrix=]>
java: void set_controlMatrix(Mat controlMatrix)
FUNC <Mat cv.KalmanFilter.get_measurementMatrix []>
java: Mat get_measurementMatrix()
FUNC <void cv.KalmanFilter.set_measurementMatrix [ARG Mat measurementMatrix=]>
java: void set_measurementMatrix(Mat measurementMatrix)
FUNC <Mat cv.KalmanFilter.get_processNoiseCov []>
java: Mat get_processNoiseCov()
FUNC <void cv.KalmanFilter.set_processNoiseCov [ARG Mat processNoiseCov=]>
java: void set_processNoiseCov(Mat processNoiseCov)
FUNC <Mat cv.KalmanFilter.get_measurementNoiseCov []>
java: Mat get_measurementNoiseCov()
FUNC <void cv.KalmanFilter.set_measurementNoiseCov [ARG Mat measurementNoiseCov=]>
java: void set_measurementNoiseCov(Mat measurementNoiseCov)
FUNC <Mat cv.KalmanFilter.get_errorCovPre []>
java: Mat get_errorCovPre()
FUNC <void cv.KalmanFilter.set_errorCovPre [ARG Mat errorCovPre=]>
java: void set_errorCovPre(Mat errorCovPre)
FUNC <Mat cv.KalmanFilter.get_gain []>
java: Mat get_gain()
FUNC <void cv.KalmanFilter.set_gain [ARG Mat gain=]>
java: void set_gain(Mat gain)
FUNC <Mat cv.KalmanFilter.get_errorCovPost []>
java: Mat get_errorCovPost()
FUNC <void cv.KalmanFilter.set_errorCovPost [ARG Mat errorCovPost=]>
java: void set_errorCovPost(Mat errorCovPost)
CLASS cv::.SparsePyrLKOpticalFlow : SparseOpticalFlow
FUNC <Ptr_SparsePyrLKOpticalFlow cv.SparsePyrLKOpticalFlow.create [ARG Size winSize=Size(21, 21), ARG int maxLevel=3, ARG TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), ARG int flags=0, ARG double minEigThreshold=1e-4]>
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel, TermCriteria crit, int flags, double minEigThreshold)
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel, TermCriteria crit, int flags)
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel, TermCriteria crit)
java: SparsePyrLKOpticalFlow create(Size winSize, int maxLevel)
java: SparsePyrLKOpticalFlow create(Size winSize)
java: SparsePyrLKOpticalFlow create()
FUNC <Size cv.SparsePyrLKOpticalFlow.getWinSize []>
java: Size getWinSize()
FUNC <TermCriteria cv.SparsePyrLKOpticalFlow.getTermCriteria []>
java: TermCriteria getTermCriteria()
FUNC <double cv.SparsePyrLKOpticalFlow.getMinEigThreshold []>
java: double getMinEigThreshold()
FUNC <int cv.SparsePyrLKOpticalFlow.getFlags []>
java: int getFlags()
FUNC <int cv.SparsePyrLKOpticalFlow.getMaxLevel []>
java: int getMaxLevel()
FUNC <void cv.SparsePyrLKOpticalFlow.setFlags [ARG int flags=]>
java: void setFlags(int flags)
FUNC <void cv.SparsePyrLKOpticalFlow.setMaxLevel [ARG int maxLevel=]>
java: void setMaxLevel(int maxLevel)
FUNC <void cv.SparsePyrLKOpticalFlow.setMinEigThreshold [ARG double minEigThreshold=]>
java: void setMinEigThreshold(double minEigThreshold)
FUNC <void cv.SparsePyrLKOpticalFlow.setTermCriteria [ARG TermCriteria crit=]>
java: void setTermCriteria(TermCriteria crit)
FUNC <void cv.SparsePyrLKOpticalFlow.setWinSize [ARG Size winSize=]>
java: void setWinSize(Size winSize)
CLASS cv::.VariationalRefinement : DenseOpticalFlow
FUNC <Ptr_VariationalRefinement cv.VariationalRefinement.create []>
java: VariationalRefinement create()
FUNC <float cv.VariationalRefinement.getAlpha []>
java: float getAlpha()
FUNC <float cv.VariationalRefinement.getDelta []>
java: float getDelta()
FUNC <float cv.VariationalRefinement.getGamma []>
java: float getGamma()
FUNC <float cv.VariationalRefinement.getOmega []>
java: float getOmega()
FUNC <int cv.VariationalRefinement.getFixedPointIterations []>
java: int getFixedPointIterations()
FUNC <int cv.VariationalRefinement.getSorIterations []>
java: int getSorIterations()
FUNC <void cv.VariationalRefinement.calcUV [ARG Mat I0=, ARG Mat I1=, ARG Mat flow_u=, ARG Mat flow_v=]>
java: void calcUV(Mat I0, Mat I1, Mat flow_u, Mat flow_v)
FUNC <void cv.VariationalRefinement.setAlpha [ARG float val=]>
java: void setAlpha(float val)
FUNC <void cv.VariationalRefinement.setDelta [ARG float val=]>
java: void setDelta(float val)
FUNC <void cv.VariationalRefinement.setFixedPointIterations [ARG int val=]>
java: void setFixedPointIterations(int val)
FUNC <void cv.VariationalRefinement.setGamma [ARG float val=]>
java: void setGamma(float val)
FUNC <void cv.VariationalRefinement.setOmega [ARG float val=]>
java: void setOmega(float val)
FUNC <void cv.VariationalRefinement.setSorIterations [ARG int val=]>
java: void setSorIterations(int val)
CLASS cv::.BackgroundSubtractorKNN : BackgroundSubtractor
FUNC <bool cv.BackgroundSubtractorKNN.getDetectShadows []>
java: boolean getDetectShadows()
FUNC <double cv.BackgroundSubtractorKNN.getDist2Threshold []>
java: double getDist2Threshold()
FUNC <double cv.BackgroundSubtractorKNN.getShadowThreshold []>
java: double getShadowThreshold()
FUNC <int cv.BackgroundSubtractorKNN.getHistory []>
java: int getHistory()
FUNC <int cv.BackgroundSubtractorKNN.getNSamples []>
java: int getNSamples()
FUNC <int cv.BackgroundSubtractorKNN.getShadowValue []>
java: int getShadowValue()
FUNC <int cv.BackgroundSubtractorKNN.getkNNSamples []>
java: int getkNNSamples()
FUNC <void cv.BackgroundSubtractorKNN.setDetectShadows [ARG bool detectShadows=]>
java: void setDetectShadows(boolean detectShadows)
FUNC <void cv.BackgroundSubtractorKNN.setDist2Threshold [ARG double _dist2Threshold=]>
java: void setDist2Threshold(double _dist2Threshold)
FUNC <void cv.BackgroundSubtractorKNN.setHistory [ARG int history=]>
java: void setHistory(int history)
FUNC <void cv.BackgroundSubtractorKNN.setNSamples [ARG int _nN=]>
java: void setNSamples(int _nN)
FUNC <void cv.BackgroundSubtractorKNN.setShadowThreshold [ARG double threshold=]>
java: void setShadowThreshold(double threshold)
FUNC <void cv.BackgroundSubtractorKNN.setShadowValue [ARG int value=]>
java: void setShadowValue(int value)
FUNC <void cv.BackgroundSubtractorKNN.setkNNSamples [ARG int _nkNN=]>
java: void setkNNSamples(int _nkNN)
